/**
 * Data in memory.
 *
 * `Buffer` is used to temporarily store data in memory before writing to a
 * file, or after reading from a file. It follows the
 * [JSON](https://www.json.org) data model, where data is arranged
 * hierachically in *objects* (dictionaries) of key-value members, and
 * *arrays* of elements. Keys are strings. Values and elements may be strings,
 * reals, integers, Booleans or nulls. Special provisions are made for
 * efficient representation of numerical vectors and matrices. The
 * representation is schemaless and all types variant.
 *
 * Objects (in the JSON sense) are created using `set()`. Arrays (in the
 * JSON sense) are created using the various `push()` member functions. When
 * `push()` is called on a `Buffer` it may invoke a type conversion for the
 * values stored in that `Buffer`. Transitively, a scalar `Boolean` can be
 * converted to an `Integer`, can be converted to a `Real`. Similarly, a
 * scalar can be converted to a vector of the same basic type. So, for
 * example, calling `push(Real)` on a `Buffer` holding an `Integer` will
 * convert it to holding a `Real[_]` (`Integer` converts to `Real`, scalar
 * converts to vector).
 */
final class Buffer {
  /**
   * If this is an object (in the JSON sense), the keys of its entries.
   */
  keys:String[_]?;

  /**
   * If this is an object or array (in the JSON sense), the values of its
   * entries or the elements of the array, respectively.
   */
  values:Buffer[_]?;

  /**
   * If a string scalar, then the value.
   */
  scalarString:String?;

  /**
   * If a real scalar, then the value.
   */
  scalarReal:Real?;

  /**
   * If an integer scalar, then the value.
   */
  scalarInteger:Integer?;

  /**
   * If a Boolean scalar, then the value.
   */
  scalarBoolean:Boolean?;

  /**
   * If a real vector, then the value.
   */
  vectorReal:Real[_]?;

  /**
   * If an integer vector, then the value.
   */
  vectorInteger:Integer[_]?;

  /**
   * If a Boolean vector, then the value.
   */
  vectorBoolean:Boolean[_]?;

  /**
   * If a real matrix, then the value.
   */
  matrixReal:Real[_,_]?;

  /**
   * If an integer matrix, then the value.
   */
  matrixInteger:Integer[_,_]?;

  /**
   * If a Boolean matrix, then the value.
   */
  matrixBoolean:Boolean[_,_]?;

  /**
   * Clear the contents. This resets the buffer contents to nil;
   */
  function clear() {
    keys <- nil;
    values <- nil;
    scalarString <- nil;
    scalarReal <- nil;
    scalarInteger <- nil;
    scalarBoolean <- nil;
    vectorReal <- nil;
    vectorInteger <- nil;
    vectorBoolean <- nil;
    matrixReal <- nil;
    matrixInteger <- nil;
    matrixBoolean <- nil;
  }

  /**
   * Size of the buffer. For an uninitialized buffer this is zero,
   * for an array it is the array length, for anything else it is one.
   */
  function size() -> Integer {
    if keys? || scalarString? || scalarReal? || scalarInteger? ||
        scalarBoolean? {
      return 1;
    } else if values? {
      return length(values!);
    } else if vectorReal? {
      return length(vectorReal!);
    } else if vectorInteger? {
      return length(vectorInteger!);
    } else if vectorBoolean? {
      return length(vectorBoolean!);
    } else if matrixReal? {
      return rows(matrixReal!);
    } else if matrixInteger? {
      return rows(matrixInteger!);
    } else if matrixBoolean? {
      return rows(matrixBoolean!);
    } else {
      return 0;
    }
  }

  /**
   * Set the contents.
   *
   * - x: Value.
   */
  function set(x:Boolean) {
    clear();
    scalarBoolean <- x;
  }

  /**
   * Set the contents.
   *
   * - x: Value.
   */
  function set(x:Integer) {
    clear();
    scalarInteger <- x;
  }

  /**
   * Set the contents.
   *
   * - x: Value.
   */
  function set(x:Real) {
    clear();
    scalarReal <- x;
  }

  /**
   * Set the contents.
   *
   * - x: Value.
   */
  function set(x:String) {
    clear();
    scalarString <- x;
  }

  /**
   * Set the contents.
   *
   * - x: Value.
   */
  function set<Type>(x:Type) {
    clear();
    x.write(this);
  }

  /**
   * Set the contents.
   *
   * - x: Value.
   */
  function set(x:Boolean[_]) {
    clear();
    vectorBoolean <- x;
  }

  /**
   * Set the contents.
   *
   * - x: Value.
   */
  function set(x:Integer[_]) {
    clear();
    vectorInteger <- x;
  }

  /**
   * Set the contents.
   *
   * - x: Value.
   */
  function set(x:Real[_]) {
    clear();
    vectorReal <- x;
  }

  /**
   * Set the contents.
   *
   * - x: Value.   *
   * Use this version to write objects using their `write(Integer, Buffer)`
   * member function rather than `write(Buffer)`.

   */
  function set(x:Boolean[_,_]) {
    clear();
    matrixBoolean <- x;
  }

  /**
   * Set the contents.
   *
   * - x: Value.
   */
  function set(x:Integer[_,_]) {
    clear();
    matrixInteger <- x;
  }

  /**
   * Set the contents.
   *
   * - x: Value.
   */
  function set(x:Real[_,_]) {
    clear();
    matrixReal <- x;
  }

  /**
   * Set the contents.
   *
   * - x: Value.
   */
  function set(x:LLT) {
    set(canonical(x));
  }

  /**
   * Push an element onto the end of an array.
   *
   * - x: The element.
   */
  function push(x:Boolean) {
    if scalarBoolean? {
      set([scalarBoolean!, x]);
    } else if scalarInteger? {
      set([scalarInteger!, Integer(x)]);
    } else if scalarReal? {
      set([scalarReal!, Real(x)]);
    } else if vectorBoolean? {
      cpp{{
      vectorBoolean.get().insert(vectorBoolean.get().size(), x);
      }}
    } else if vectorInteger? {
      push(Integer(x));
    } else if vectorReal? {
      push(Real(x));
    } else {
      pushBuffer(Buffer(x));
    }
  }

  /**
   * Push an element onto the end of an array.
   *
   * - x: The element.
   */
  function push(x:Integer) {
    if scalarBoolean? {
      set([Integer(scalarBoolean!), x]);
    } else if scalarInteger? {
      set([scalarInteger!, x]);
    } else if scalarReal? {
      set([scalarReal!, Real(x)]);
    } else if vectorBoolean? {
      vectorInteger <- stack(Integer(vectorBoolean!), x);
    } else if vectorInteger? {
      cpp{{
      vectorInteger.get().insert(vectorInteger.get().size(), x);
      }}
    } else if vectorReal? {
      push(Real(x));
    } else {
      pushBuffer(Buffer(x));
    }
  }

  /**
   * Push an element onto the end of an array.
   *
   * - x: The element.
   */
  function push(x:Real) {
    if scalarBoolean? {
      set([Real(scalarBoolean!), x]);
    } else if scalarInteger? {
      set([Real(scalarInteger!), x]);
    } else if scalarReal? {
      set([scalarReal!, x]);
    } else if vectorBoolean? {
      vectorReal <- stack(Real(vectorBoolean!), x);
    } else if vectorInteger? {
      vectorReal <- stack(Real(vectorInteger!), x);
    } else if vectorReal? {
      cpp{{
      vectorReal.get().insert(vectorReal.get().size(), x);
      }}
    } else {
      pushBuffer(Buffer(x));
    }
  }

  /**
   * Push an element onto the end of an array.
   *
   * - x: The element.
   */
  function push(x:String) {
    pushBuffer(Buffer(x));
  }

  /**
   * Push an element onto the end of an array.
   *
   * - x: The element.
   */
  function push<Type>(x:Type) {
    pushBuffer(Buffer(x));
  }

  /**
   * Push an element onto the end of an array.
   *
   * - x: The element.
   */
  function push(x:Boolean[_]) {
    if matrixBoolean? {
      matrixBoolean <- stack(matrixBoolean!, row(x));
    } else if matrixInteger? {
      matrixInteger <- stack(matrixInteger!, Integer(row(x)));
    } else if matrixReal? {
      matrixReal <- stack(matrixReal!, Real(row(x)));
    } else {
      pushBuffer(Buffer(x));
    }
  }

  /**
   * Push an element onto the end of an array.
   *
   * - x: The element.
   */
  function push(x:Integer[_]) {
    if matrixBoolean? {
      matrixInteger <- stack(Integer(matrixBoolean!), row(x));
      matrixBoolean <- nil;
    } else if matrixInteger? {
      matrixInteger <- stack(matrixInteger!, row(x));
    } else if matrixReal? {
      matrixReal <- stack(matrixReal!, Real(row(x)));
    } else {
      pushBuffer(Buffer(x));
    }
  }

  /**
   * Push an element onto the end of an array.
   *
   * - x: The element.
   */
  function push(x:Real[_]) {
    if matrixBoolean? {
      matrixReal <- stack(Real(matrixBoolean!), row(x));
      matrixBoolean <- nil;
    } else if matrixInteger? {
      matrixReal <- stack(Real(matrixInteger!), row(x));
      matrixInteger <- nil;
    } else if matrixReal? {
      matrixReal <- stack(matrixReal!, row(x));
    } else {
      pushBuffer(Buffer(x));
    }
  }

  /**
   * Get the contents.
   *
   * - x: Placeholder, used to indicate desired type.
   *
   * Returns: If the contents of the buffer can be coerced to the desired
   * type, then an optional with that value; otherwise an optional with no
   * value.
   */
  function get(x:Boolean?) -> Boolean? {
    if scalarBoolean? {
      return Boolean(scalarBoolean!);
    } else if scalarInteger? {
      return Boolean(scalarInteger!);
    } else if scalarReal? {
      return Boolean(scalarReal!);
    } else if scalarString? {
      return Boolean(scalarString!);
    } else {
      return nil;
    }
  }

  /**
   * Get the contents.
   *
   * - x: Placeholder, used to indicate desired type.
   *
   * Returns: If the contents of the buffer can be coerced to the desired
   * type, then an optional with that value; otherwise an optional with no
   * value.
   */
  function get(x:Integer?) -> Integer? {
    if scalarBoolean? {
      return Integer(scalarBoolean!);
    } else if scalarInteger? {
      return Integer(scalarInteger!);
    } else if scalarReal? {
      return Integer(scalarReal!);
    } else if scalarString? {
      return Integer(scalarString!);
    } else {
      return nil;
    }
  }

  /**
   * Get the contents.
   *
   * - x: Placeholder, used to indicate desired type.
   *
   * Returns: If the contents of the buffer can be coerced to the desired
   * type, then an optional with that value; otherwise an optional with no
   * value.
   */
  function get(x:Real?) -> Real? {
    if scalarBoolean? {
      return Real(scalarBoolean!);
    } else if scalarInteger? {
      return Real(scalarInteger!);
    } else if scalarReal? {
      return Real(scalarReal!);
    } else if scalarString? {
      return Real(scalarString!);
    } else {
      return nil;
    }
  }

  /**
   * Get the contents.
   *
   * - x: Placeholder, used to indicate desired type.
   *
   * Returns: If the contents of the buffer can be coerced to the desired
   * type, then an optional with that value; otherwise an optional with no
   * value.
   */
  function get(x:String?) -> String? {
    if scalarBoolean? {
      return String(scalarBoolean!);
    } else if scalarInteger? {
      return String(scalarInteger!);
    } else if scalarReal? {
      return String(scalarReal!);
    } else if scalarString? {
      return String(scalarString!);
    } else {
      return nil;
    }
  }

  /**
   * Get the contents.
   *
   * - x: Placeholder, used to indicate desired type.
   *
   * Returns: If the contents of the buffer can be coerced to the desired
   * type, then an optional with that value; otherwise an optional with no
   * value.
   */
  function get<Type>(x:Type?) -> Type? {
    return make<Type>(this);
  }

  /**
   * Get the contents.
   *
   * - x: Placeholder, used to indicate desired type.
   *
   * Returns: If the contents of the buffer can be coerced to the desired
   * type, then an optional with that value; otherwise an optional with no
   * value.
   */
  function get(x:Boolean[_]?) -> Boolean[_]? {
    if vectorBoolean? {
      return Boolean(vectorBoolean!);
    } else if vectorInteger? {
      return Boolean(vectorInteger!);
    } else if vectorReal? {
      return Boolean(vectorReal!);
    } else {
      return nil;
    }
  }

  /**
   * Get the contents.
   *
   * - x: Placeholder, used to indicate desired type.
   *
   * Returns: If the contents of the buffer can be coerced to the desired
   * type, then an optional with that value; otherwise an optional with no
   * value.
   */
  function get(x:Integer[_]?) -> Integer[_]? {
    if vectorBoolean? {
      return Integer(vectorBoolean!);
    } else if vectorInteger? {
      return Integer(vectorInteger!);
    } else if vectorReal? {
      return Integer(vectorReal!);
    } else {
      return nil;
    }
  }

  /**
   * Get the contents.
   *
   * - x: Placeholder, used to indicate desired type.
   *
   * Returns: If the contents of the buffer can be coerced to the desired
   * type, then an optional with that value; otherwise an optional with no
   * value.
   */
  function get(x:Real[_]?) -> Real[_]? {
    if vectorBoolean? {
      return Real(vectorBoolean!);
    } else if vectorInteger? {
      return Real(vectorInteger!);
    } else if vectorReal? {
      return Real(vectorReal!);
    } else {
      return nil;
    }
  }

  /**
   * Get the contents.
   *
   * - x: Placeholder, used to indicate desired type.
   *
   * Returns: If the contents of the buffer can be coerced to the desired
   * type, then an optional with that value; otherwise an optional with no
   * value.
   */
  function get(x:Boolean[_,_]?) -> Boolean[_,_]? {
    if matrixBoolean? {
      return Boolean(matrixBoolean!);
    } else if matrixInteger? {
      return Boolean(matrixInteger!);
    } else if matrixReal? {
      return Boolean(matrixReal!);
    } else {
      return nil;
    }
  }

  /**
   * Get the contents.
   *
   * - x: Placeholder, used to indicate desired type.
   *
   * Returns: If the contents of the buffer can be coerced to the desired
   * type, then an optional with that value; otherwise an optional with no
   * value.
   */
  function get(x:Integer[_,_]?) -> Integer[_,_]? {
    if matrixBoolean? {
      return Integer(matrixBoolean!);
    } else if matrixInteger? {
      return Integer(matrixInteger!);
    } else if matrixReal? {
      return Integer(matrixReal!);
    } else {
      return nil;
    }
  }

  /**
   * Get the contents.
   *
   * - x: Placeholder, used to indicate desired type.
   *
   * Returns: If the contents of the buffer can be coerced to the desired
   * type, then an optional with that value; otherwise an optional with no
   * value.
   */
  function get(x:Real[_,_]?) -> Real[_,_]? {
    if matrixBoolean? {
      return Real(matrixBoolean!);
    } else if matrixInteger? {
      return Real(matrixInteger!);
    } else if matrixReal? {
      return Real(matrixReal!);
    } else {
      return nil;
    }
  }

  /**
   * Get the contents.
   *
   * - x: Placeholder, used to indicate desired type.
   *
   * Returns: If the contents of the buffer can be coerced to the desired
   * type, then an optional with that value; otherwise an optional with no
   * value.
   */
  function get(x:LLT?) -> LLT? {
    let y <- get<Real[_,_]>();
    if y? {
      return llt(y!);
    } else {
      return nil;
    }
  }

  /**
   * Get the contents.
   *
   * - Type: The desired type.
   *
   * Returns: If the contents of the buffer can be coerced to the desired
   * type, then an optional with that value; otherwise an optional with no
   * value.
   */
  function get<Type>() -> Type? {
    x:Type?;
    return Type?(get(x));
  }

  /**
   * Iterate through the elements of an array.
   */
  function walk() -> Iterator<Buffer> {
    if keys? || scalarString? || scalarReal? || scalarInteger? ||
        scalarBoolean? {
      return SingletonIterator(this);
    } else if values? {
      return BufferIterator(this);
    } else if vectorReal? {
      return VectorBufferIterator(vectorReal!);
    } else if vectorInteger? {
      return VectorBufferIterator(vectorInteger!);
    } else if vectorBoolean? {
      return VectorBufferIterator(vectorBoolean!);
    } else if matrixReal? {
      return MatrixBufferIterator(matrixReal!);
    } else if matrixInteger? {
      return MatrixBufferIterator(matrixInteger!);
    } else if matrixBoolean? {
      return MatrixBufferIterator(matrixBoolean!);
    } else {
      return EmptyIterator<Buffer>();
    }
  }

  /**
   * Size of an entry. For an uninitialized buffer this is zero,
   * for an array it is the array length, for anything else it is one.
   *
   * - key: Key of the entry.
   */
  function size(key:String) -> Integer {
    let buffer <- getBuffer(key);
    if buffer? {
      return buffer!.size();
    } else {
      return 0;
    }
  }

  /**
   * Set the contents of an entry.
   *
   * - key: Key of the entry.
   * - x: Value of the entry.
   */
  function set<Type>(key:String, x:Type) {
    set(key, Buffer(x));
  }

  /**
   * Push an element onto the end of an entry.
   *
   * - key: Key of the entry.
   * - x: The element.
   */
  function push<Type>(key:String, x:Type) {
    let buffer <- getBuffer(key);
    if buffer? {
      buffer!.push(x);
    } else {
      set(key, [x]);
    }
  }

  /**
   * Get the contents of an entry.
   *
   * - Type: The desired type.
   *
   * - key: Key of the entry.
   *
   * Returns: If the contents of the entry can be coerced to the desired
   * type, then an optional with that value; otherwise an optional with no
   * value.
   */
  function get<Type>(key:String) -> Type? {
    let buffer <- getBuffer(key);
    if buffer? {
      return buffer!.get<Type>();
    } else {
      return nil;
    }
  }

  /**
   * Get the contents of an entry.
   *
   * - key: Key of the entry.
   * - x: Placeholder, used to indicate desired type.
   *
   * Returns: If the contents of the entry can be coerced to the desired
   * type, then an optional with that value; otherwise an optional with no
   * value.
   */
  function get<Type>(key:String, x:Type?) -> Type? {
    let buffer <- getBuffer(key);
    if buffer? {
      return buffer!.get(x);
    } else {
      return nil;
    }
  }

  /**
   * Iterate through the elements of an array entry.
   *
   * - key: Key of the entry.
   */
  function walk(key:String) -> Iterator<Buffer> {
    let buffer <- getBuffer(key);
    if buffer? {
      return buffer!.walk();
    } else {
      return EmptyIterator<Buffer>();
    }
  }

  /**
   * Get this as a buffer.
   *
   * Return: An optional with a value.
   */
  function getBuffer() -> Buffer? {
    return this;
  }

  /**
   * Get an entry as a buffer.
   *
   * - key: Key of the entry.
   *
   * Return: An optional with a value if the entry exists .
   */
  function getBuffer(key:String) -> Buffer? {
    if keys? {
      for i in 1..length(keys!) {
        if keys![i] == key {
          return values![i];
        }
      }
    }
    return nil;
  }

  /**
   * Set an entry as a buffer.
   *
   * - key: Key of the entry.
   * - x: Content of the entry.
   *
   * If the buffer contents is not already an object (in the JSON sense), it
   * is cleared before setting the new entry.
   */
  function setBuffer(key:String, x:Buffer) {
    if !keys? {
      clear();
      keys:String[_];
      values:Buffer[_];
      this.keys <- keys;
      this.values <- values;
    }
    keys <- stack(keys!, key);
    values <- stack(values!, x);
  }

  /**
   * Set contents to nil. This is equivalent to `clear()`.
   */
  function setNil() {
    clear();
  }

  /**
   * Push a buffer onto the end of an array.
   *
   * - x: The element.
   */
  function pushBuffer(x:Buffer) {
    if keys? {
      y:Buffer;
      y.keys <- x.keys;
      y.values <- x.values;
      clear();
      values <- [y, x];
    } else if values? {
      values <- stack(values!, x);
    } else {
      a:Array<Buffer>;
      let iter <- walk();
      while iter.hasNext() {
        a.pushBack(iter.next());
      }
      a.pushBack(x);
      clear();
      values <- a.toArray();
    }
  }

  /**
   * Push a buffer onto the end of an array entry.
   *
   * - key: Key of the entry.
   * - x: The element.
   */
  function pushBuffer(key:String, x:Buffer) {
    let buffer <- getBuffer(key);
    if !buffer? {
      buffer <- Buffer();
      setBuffer(key, buffer!);
    }
    buffer!.pushBuffer(x);
  }

  /**
   * Push a nil element onto the end of an array.
   */
  function pushNil() {
    pushBuffer(Buffer());
  }

  /**
   * Push a nil element onto the end of an array.
   */
  function pushNil(key:String) {
    pushBuffer(key, Buffer());
  }

  /**
   * Accept a writer.
   */
  function accept(writer:Writer) {
    if keys? {
      writer.visit(keys!, values!);
    } else if values? {
      writer.visit(values!);
    } else if scalarString? {
      writer.visit(scalarString!);
    } else if scalarReal? {
      writer.visit(scalarReal!);
    } else if scalarInteger? {
      writer.visit(scalarInteger!);
    } else if scalarBoolean? {
      writer.visit(scalarBoolean!);
    } else if vectorReal? {
      writer.visit(vectorReal!);
    } else if vectorInteger? {
      writer.visit(vectorInteger!);
    } else if vectorBoolean? {
      writer.visit(vectorBoolean!);
    } else if matrixReal? {
      writer.visit(matrixReal!);
    } else if matrixInteger? {
      writer.visit(matrixInteger!);
    } else if matrixBoolean? {
      writer.visit(matrixBoolean!);
    } else {
      writer.visitNil();
    }
  }
}

/**
 * Create a Buffer.
 */
function Buffer() -> Buffer {
  return construct<Buffer>();
}

/**
 * Create a Buffer.
 *
 * - root: Root value.
 */
function Buffer<Type>(root:Type) -> Buffer {
  o:Buffer;
  o.set(root);
  return o;
}
