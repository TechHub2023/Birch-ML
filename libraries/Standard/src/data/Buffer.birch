/**
 * Data in memory.
 *
 * `Buffer` is used to temporarily store data in memory before writing to a
 * file, or after reading from a file. It follows the
 * [JSON](https://www.json.org) data model, where data is arranged
 * hierachically in *objects* (dictionaries) of key-value members, and
 * *arrays* of elements. Keys are strings. Values and elements may be strings,
 * reals, integers, Booleans or nulls. Special provisions are made for
 * efficient representation of numerical vectors and matrices. The
 * representation is schemaless and all types variant.
 *
 * Objects (in the JSON sense) are created using `set()`. Arrays (in the
 * JSON sense) are created using the various `push()` member functions. When
 * `push()` is called on a `Buffer` it may invoke a type conversion for the
 * values stored in that `Buffer`. Transitively, a scalar `Boolean` can be
 * converted to an `Integer`, can be converted to a `Real`. Similarly, a
 * scalar can be converted to a vector of the same basic type. So, for
 * example, calling `push(Real)` on a `Buffer` holding an `Integer` will
 * convert it to holding a `Real[_]` (`Integer` converts to `Real`, scalar
 * converts to vector).
 */
final class Buffer {
  /**
   * If this is an object (in the JSON sense), the keys of its entries.
   */
  keys:String[_]?;

  /**
   * If this is an object or array (in the JSON sense), the values of its
   * entries or the elements of the array, respectively.
   */
  values:Buffer[_]?;

  /**
   * If a string scalar, then the value.
   */
  scalarString:String?;

  /**
   * If a real scalar, then the value.
   */
  scalarReal:Real?;

  /**
   * If an integer scalar, then the value.
   */
  scalarInteger:Integer?;

  /**
   * If a Boolean scalar, then the value.
   */
  scalarBoolean:Boolean?;

  /**
   * If a real vector, then the value.
   */
  vectorReal:Real[_]?;

  /**
   * If an integer vector, then the value.
   */
  vectorInteger:Integer[_]?;

  /**
   * If a Boolean vector, then the value.
   */
  vectorBoolean:Boolean[_]?;

  /**
   * If a real matrix, then the value.
   */
  matrixReal:Real[_,_]?;

  /**
   * If an integer matrix, then the value.
   */
  matrixInteger:Integer[_,_]?;

  /**
   * If a Boolean matrix, then the value.
   */
  matrixBoolean:Boolean[_,_]?;

  /**
   * Clear the contents. This resets the buffer contents to nil;
   */
  function clear() {
    keys <- nil;
    values <- nil;
    scalarString <- nil;
    scalarReal <- nil;
    scalarInteger <- nil;
    scalarBoolean <- nil;
    vectorReal <- nil;
    vectorInteger <- nil;
    vectorBoolean <- nil;
    matrixReal <- nil;
    matrixInteger <- nil;
    matrixBoolean <- nil;
  }

  /**
   * Size. For a nil buffer this is zero, for an object or scalar it is one,
   * for an array or vector it is the length, for a matrix it is the number
   * of rows.
   */
  function size() -> Integer {
    if keys? || scalarString? || scalarReal? || scalarInteger? ||
        scalarBoolean? {
      return 1;
    } else if values? {
      return length(values!);
    } else if vectorReal? {
      return length(vectorReal!);
    } else if vectorInteger? {
      return length(vectorInteger!);
    } else if vectorBoolean? {
      return length(vectorBoolean!);
    } else if matrixReal? {
      return rows(matrixReal!);
    } else if matrixInteger? {
      return rows(matrixInteger!);
    } else if matrixBoolean? {
      return rows(matrixBoolean!);
    } else {
      return 0;
    }
  }

  /**
   * Size of an entry.
   *
   * - key: Key of the entry.
   */
  function size(key:String) -> Integer {
    let buffer <- get(key);
    if buffer? {
      return buffer!.size();
    } else {
      return 0;
    }
  }

  /**
   * Get the value.
   *
   * - Type: The desired type.
   *
   * Returns: An optional with a value if the contents of the entry can be
   * coerced to the desired type, otherwise with no value.
   */
  function get<Type>() -> Type? {
    x:Type?;
    return Type?(doGet(x));
  }

  /**
   * Get the value of an entry.
   *
   * - Type: The desired type.
   *
   * - key: Key of the entry.
   *
   * Returns: An optional with a value if the contents of the entry can be
   * coerced to the desired type, otherwise with no value.
   */
  function get<Type>(key:String) -> Type? {
    let buffer <- get(key);
    if buffer? {
      return buffer!.get<Type>();
    } else {
      return nil;
    }
  }

  /**
   * Get the value.
   *
   * - Type: The desired type.
   *
   * - o: Existing object.
   *
   * This version is used when reading objects of class type, where instead of
   * constructing a new object then calling its `read()` function, an existing
   * object is provided, calling its `read()` function directly.
   */
  function get<Type>(o:Type) {
    o.read(this);
  }

  /**
   * Get the value of an entry.
   *
   * - Type: The desired type.
   *
   * - key: Key of the entry.
   * - o: Existing object.
   *
   * This version is used when reading objects of class type, where instead of
   * constructing a new object then calling its `read()` function, an existing
   * object is provided, calling its `read()` function directly.
   */
  function get<Type>(key:String, o:Type) {
    let buffer <- get(key);
    if buffer? {
      buffer!.get(o);
    }
  }

  /**
   * Get the value of an entry as a buffer.
   *
   * - key: Key of the entry.
   *
   * Return: An optional with a value if the entry exists, otherwise no value.
   */
  function get(key:String) -> Buffer? {
    if keys? {
      for i in 1..length(keys!) {
        if keys![i] == key {
          return values![i];
        }
      }
    }
    return nil;
  }

  /**
   * Set the value.
   *
   * - x: Value.
   */
  function set<Type>(x:Type) {
    doSet(x);
  }

  /**
   * Set the value of an entry.
   *
   * - key: Key of the entry.
   * - x: Value of the entry.
   *
   * If the buffer value is not already an object (in the JSON sense), it
   * is cleared before setting the new entry.
   */
  function set<Type>(key:String, x:Type) {
    set(key, Buffer(x));
  }

  /**
   * Set the value of an entry as a buffer.
   *
   * - key: Key of the entry.
   * - x: Content of the entry.
   */
  function set(key:String, x:Buffer) {
    if !keys? {
      clear();
      keys:String[_];
      values:Buffer[_];
      this.keys <- keys;
      this.values <- values;
    }
    keys <- stack(keys!, key);
    values <- stack(values!, x);
  }

  /**
   * Set the value to nil. This is equivalent to `clear()`.
   */
  function setNil() {
    clear();
  }

  /**
   * Set the value of an entry to nil.
   */
  function setNil(key:String) {
    set(key, Buffer());
  }

  /**
   * Obtain an iterator. For a nil buffer this is an empty iterator, for an
   * object or scalar it is a singleton iterator, for an array or vector it is
   * over the elements, for a matrix it is over the rows.
   */
  function walk() -> Iterator<Buffer> {
    if keys? || scalarString? || scalarReal? || scalarInteger? ||
        scalarBoolean? {
      return SingletonIterator(this);
    } else if values? {
      return BufferIterator(this);
    } else if vectorReal? {
      return VectorBufferIterator(vectorReal!);
    } else if vectorInteger? {
      return VectorBufferIterator(vectorInteger!);
    } else if vectorBoolean? {
      return VectorBufferIterator(vectorBoolean!);
    } else if matrixReal? {
      return MatrixBufferIterator(matrixReal!);
    } else if matrixInteger? {
      return MatrixBufferIterator(matrixInteger!);
    } else if matrixBoolean? {
      return MatrixBufferIterator(matrixBoolean!);
    } else {
      return EmptyIterator<Buffer>();
    }
  }

  /**
   * Obtain an iterator over an entry.
   *
   * - key: Key of the entry.
   */
  function walk(key:String) -> Iterator<Buffer> {
    let buffer <- get(key);
    if buffer? {
      return buffer!.walk();
    } else {
      return EmptyIterator<Buffer>();
    }
  }

  /**
   * Push a value.
   *
   * - x: Value.
   *
   * If the buffer value is not already an array (in the JSON sense), it is
   * converted to such before pushing the new element onto the end.
   *
   * If the buffer value is a matrix and the new element of incompatible type
   * or incompatible size to form a new row, its rows are split into separate
   * vector elements of an array before pushing the new element onto the end.
   */
  function push<Type>(x:Type) {
    if size() == 0 {
      set([x]);
    } else {
      doPush(x);
    }
  }

  /**
   * Push a value as a buffer.
   *
   * - x: Value.
   */
  function push(x:Buffer) {
    if keys? {
      y:Buffer;
      y.keys <- x.keys;
      y.values <- x.values;
      clear();
      values <- [y, x];
    } else if values? {
      values <- stack(values!, x);
    } else {
      a:Array<Buffer>;
      let iter <- walk();
      while iter.hasNext() {
        a.pushBack(iter.next());
      }
      a.pushBack(x);
      clear();
      values <- a.toArray();
    }
  }

  /**
   * Push a value to an entry.
   *
   * - key: Key of the entry.
   * - x: Value.
   */
  function push<Type>(key:String, x:Type) {
    let buffer <- get(key);
    if buffer? {
      buffer!.push(x);
    } else {
      set(key, [x]);
    }
  }


  /**
   * Push a value to an entry as a buffer.
   *
   * - key: Key of the entry.
   * - x: Value.
   */
  function push(key:String, x:Buffer) {
    let buffer <- get(key);
    if !buffer? {
      buffer <- Buffer();
      set(key, buffer!);
    }
    buffer!.push(x);
  }

  /**
   * Push a nil value.
   */
  function pushNil() {
    push(Buffer());
  }

  /**
   * Push a nil value to an entry.
   *
   * - key: Key of the entry.
   */
  function pushNil(key:String) {
    push(key, Buffer());
  }

  function accept(writer:Writer) {
    if keys? {
      writer.visit(keys!, values!);
    } else if values? {
      writer.visit(values!);
    } else if scalarString? {
      writer.visit(scalarString!);
    } else if scalarReal? {
      writer.visit(scalarReal!);
    } else if scalarInteger? {
      writer.visit(scalarInteger!);
    } else if scalarBoolean? {
      writer.visit(scalarBoolean!);
    } else if vectorReal? {
      writer.visit(vectorReal!);
    } else if vectorInteger? {
      writer.visit(vectorInteger!);
    } else if vectorBoolean? {
      writer.visit(vectorBoolean!);
    } else if matrixReal? {
      writer.visit(matrixReal!);
    } else if matrixInteger? {
      writer.visit(matrixInteger!);
    } else if matrixBoolean? {
      writer.visit(matrixBoolean!);
    } else {
      writer.visitNil();
    }
  }

  function doGet(x:Boolean?) -> Boolean? {
    if scalarBoolean? {
      return Boolean(scalarBoolean!);
    } else if scalarInteger? {
      return Boolean(scalarInteger!);
    } else if scalarReal? {
      return Boolean(scalarReal!);
    } else if scalarString? {
      return Boolean(scalarString!);
    } else {
      return nil;
    }
  }

  function doGet(x:Integer?) -> Integer? {
    if scalarBoolean? {
      return Integer(scalarBoolean!);
    } else if scalarInteger? {
      return Integer(scalarInteger!);
    } else if scalarReal? {
      return Integer(scalarReal!);
    } else if scalarString? {
      return Integer(scalarString!);
    } else {
      return nil;
    }
  }

  function doGet(x:Real?) -> Real? {
    if scalarBoolean? {
      return Real(scalarBoolean!);
    } else if scalarInteger? {
      return Real(scalarInteger!);
    } else if scalarReal? {
      return Real(scalarReal!);
    } else if scalarString? {
      return Real(scalarString!);
    } else {
      return nil;
    }
  }

  function doGet(x:String?) -> String? {
    if scalarBoolean? {
      return String(scalarBoolean!);
    } else if scalarInteger? {
      return String(scalarInteger!);
    } else if scalarReal? {
      return String(scalarReal!);
    } else if scalarString? {
      return String(scalarString!);
    } else {
      return nil;
    }
  }

  function doGet<Type>(x:Type?) -> Type? {
    return make<Type>(this);
  }

  function doGet(x:Boolean[_]?) -> Boolean[_]? {
    if vectorBoolean? {
      return Boolean(vectorBoolean!);
    } else if vectorInteger? {
      return Boolean(vectorInteger!);
    } else if vectorReal? {
      return Boolean(vectorReal!);
    } else {
      return doGet<Boolean>(x);
    }
  }

  function doGet(x:Integer[_]?) -> Integer[_]? {
    if vectorBoolean? {
      return Integer(vectorBoolean!);
    } else if vectorInteger? {
      return Integer(vectorInteger!);
    } else if vectorReal? {
      return Integer(vectorReal!);
    } else {
      return doGet<Integer>(x);
    }
  }

  function doGet(x:Real[_]?) -> Real[_]? {
    if vectorBoolean? {
      return Real(vectorBoolean!);
    } else if vectorInteger? {
      return Real(vectorInteger!);
    } else if vectorReal? {
      return Real(vectorReal!);
    } else {
      return doGet<Real>(x);
    }
  }

  function doGet<Type>(x:Type[_]?) -> Type[_]? {
    y:Type[_];
    let iter <- walk();
    while iter.hasNext() {
      let z <- iter.next().get<Type>();
      if z? {
        cpp{{
        y.push(z.get());
        }}
      } else {
        return nil;
      }
    }
    return y;
  }

  function doGet(x:Boolean[_,_]?) -> Boolean[_,_]? {
    if matrixBoolean? {
      return Boolean(matrixBoolean!);
    } else if matrixInteger? {
      return Boolean(matrixInteger!);
    } else if matrixReal? {
      return Boolean(matrixReal!);
    } else {
      return doGetMatrix<Boolean>();
    }
  }

  function doGet(x:Integer[_,_]?) -> Integer[_,_]? {
    if matrixBoolean? {
      return Integer(matrixBoolean!);
    } else if matrixInteger? {
      return Integer(matrixInteger!);
    } else if matrixReal? {
      return Integer(matrixReal!);
    } else {
      return doGetMatrix<Integer>();
    }
  }

  function doGet(x:Real[_,_]?) -> Real[_,_]? {
    if matrixBoolean? {
      return Real(matrixBoolean!);
    } else if matrixInteger? {
      return Real(matrixInteger!);
    } else if matrixReal? {
      return Real(matrixReal!);
    } else {
      return doGetMatrix<Real>();
    }
  }

  function doGet<Type>(x:Type[_,_]?) -> Type[_,_]? {
    return doGetMatrix<Type>();
  }

  function doGet(x:LLT?) -> LLT? {
    let y <- doGetMatrix<Real>();
    if y? {
      return llt(y!);
    } else {
      return nil;
    }
  }

  function doGetMatrix<Type>() -> Type[_,_]? {
    y:Type[_];
    let nrows <- 0;
    let ncols <- 0;
    let iter <- walk();
    while iter.hasNext() {
      let z <- iter.next().get<Type[_]>();
      if z? && (nrows == 0 || ncols == length(z!)) {
        nrows <- nrows + 1;
        ncols <- length(z!);
        for i in 1..ncols {
          let element <- z![i];
          cpp{{
          y.push(element);
          }}
        }
      } else {
        return nil;
      }
    }
    return matrix(\(i:Integer, j:Integer) -> Type {
          return y[(i - 1)*ncols + j];
        }, nrows, ncols);
  }

  function doSet(x:Boolean) {
    clear();
    scalarBoolean <- x;
  }

  function doSet(x:Integer) {
    clear();
    scalarInteger <- x;
  }

  function doSet(x:Real) {
    clear();
    scalarReal <- x;
  }

  function doSet(x:String) {
    clear();
    scalarString <- x;
  }

  function doSet<Type>(x:Type) {
    clear();
    x.write(this);
  }

  function doSet(x:Boolean[_]) {
    clear();
    vectorBoolean <- x;
  }

  function doSet(x:Integer[_]) {
    clear();
    vectorInteger <- x;
  }

  function doSet(x:Real[_]) {
    clear();
    vectorReal <- x;
  }

  function doSet<Type>(x:Type[_]) {
    clear();
    for i in 1..length(x) {
      push(Buffer(x[i]));
    }
  }

  function doSet(x:Boolean[_,_]) {
    clear();
    matrixBoolean <- x;
  }

  function doSet(x:Integer[_,_]) {
    clear();
    matrixInteger <- x;
  }

  function doSet(x:Real[_,_]) {
    clear();
    matrixReal <- x;
  }

  function doSet(x:LLT) {
    clear();
    matrixReal <- canonical(x);
  }

  function doPush(x:Boolean) {
    if scalarBoolean? {
      set([scalarBoolean!, x]);
    } else if scalarInteger? {
      set([scalarInteger!, Integer(x)]);
    } else if scalarReal? {
      set([scalarReal!, Real(x)]);
    } else if vectorBoolean? {
      cpp{{
      vectorBoolean.get().push(x);
      }}
    } else if vectorInteger? {
      push(Integer(x));
    } else if vectorReal? {
      push(Real(x));
    } else {
      push(Buffer(x));
    }
  }

  function doPush(x:Integer) {
    if scalarBoolean? {
      set([Integer(scalarBoolean!), x]);
    } else if scalarInteger? {
      set([scalarInteger!, x]);
    } else if scalarReal? {
      set([scalarReal!, Real(x)]);
    } else if vectorBoolean? {
      set(stack(Integer(vectorBoolean!), x));
    } else if vectorInteger? {
      cpp{{
      vectorInteger.get().push(x);
      }}
    } else if vectorReal? {
      push(Real(x));
    } else {
      push(Buffer(x));
    }
  }

  function doPush(x:Real) {
    if scalarBoolean? {
      set([Real(scalarBoolean!), x]);
    } else if scalarInteger? {
      set([Real(scalarInteger!), x]);
    } else if scalarReal? {
      set([scalarReal!, x]);
    } else if vectorBoolean? {
      set(stack(Real(vectorBoolean!), x));
    } else if vectorInteger? {
      set(stack(Real(vectorInteger!), x));
    } else if vectorReal? {
      cpp{{
      vectorReal.get().push(x);
      }}
    } else {
      push(Buffer(x));
    }
  }

  function doPush(x:String) {
    push(Buffer(x));
  }

  function doPush<Type>(x:Type) {
    push(Buffer(x));
  }

  function doPush(x:Boolean[_]) {
    if matrixBoolean? {
      set(stack(matrixBoolean!, row(x)));
    } else if matrixInteger? {
      set(stack(matrixInteger!, Integer(row(x))));
    } else if matrixReal? {
      set(stack(matrixReal!, Real(row(x))));
    } else {
      push(Buffer(x));
    }
  }

  function doPush(x:Integer[_]) {
    if matrixBoolean? {
      set(stack(Integer(matrixBoolean!), row(x)));
    } else if matrixInteger? {
      set(stack(matrixInteger!, row(x)));
    } else if matrixReal? {
      set(stack(matrixReal!, Real(row(x))));
    } else {
      push(Buffer(x));
    }
  }

  function doPush(x:Real[_]) {
    if matrixBoolean? {
      set(stack(Real(matrixBoolean!), row(x)));
    } else if matrixInteger? {
      set(stack(Real(matrixInteger!), row(x)));
    } else if matrixReal? {
      set(stack(matrixReal!, row(x)));
    } else {
      push(Buffer(x));
    }
  }
}

/**
 * Create a Buffer.
 */
function Buffer() -> Buffer {
  return construct<Buffer>();
}

/**
 * Create a Buffer.
 *
 * - root: Root value.
 */
function Buffer<Type>(root:Type) -> Buffer {
  o:Buffer;
  o.set(root);
  return o;
}
