cpp{{
static auto make_handlers() {
  std::vector<libbirch::Shared<birch::type::Handler>> handlers(libbirch::get_max_threads(), nullptr);
  #pragma omp parallel num_threads(libbirch::get_max_threads())
  {
    handlers[libbirch::get_thread_num()] = birch::PlayHandler(true);
  }
  return handlers;
}

static auto& get_handler() {
  static auto handlers = make_handlers();
  return handlers[libbirch::get_thread_num()];
}
}}

/**
 * Get the event handler.
 */
function get_handler() -> Handler {
  cpp{{
  return ::get_handler();
  }}
}

/**
 * Set the event handler.
 *
 * !!! attention
 * Typically one does not call this directly, but rather uses the
 * [`with`](https://www.birch.sh/language/probability/) statement, which is
 * hard-wired to call this on exit to restore the previous handler.
 */
function set_handler(handler:Handler) {
  cpp{{
  ::get_handler() = handler;
  }}
}

/**
 * Swap the event handler with another.
 *
 * - handler: The new handler.
 *
 * Returns: The previous handler.
 *
 * !!! attention
 * Typically one does not call this directly, but rather uses the
 * [`with`](https://www.birch.sh/language/probability/) statement, which is
 * hard-wired to call this on entry to set the new handler.
 */
function swap_handler(handler:Handler) -> Handler {
  cpp{{
  auto& current = ::get_handler();
  auto previous = handler;
  std::swap(current, previous);
  return previous;
  }}
}

/**
 * Handle simulate event.
 *
 * - p: Distribution.
 *
 * !!! attention
 * Typically one does not call this directly, but rather uses the
 * [`<~`](https://www.birch.sh/language/probability/) operator, which is
 * hard-wired to call this internally.
 */
function handle_simulate<Right>(p:Right) -> Right.Value {
  let event <- SimulateEvent(p.distribution());
  get_handler().handle(event);
  return event.value();
}

/**
 * Handle observe event.
 *
 * - left: Variate.
 * - p: Distribution.
 *
 * !!! attention
 * Typically one does not call this directly, but rather uses the
 * [`~>`](https://www.birch.sh/language/probability/) operator, which is
 * hard-wired to call this internally.
 */
function handle_observe<Left,Right>(left:Left, p:Right) {
  get_handler().handle(ObserveEvent(left, p.distribution()));
}

/**
 * Handle assume event.
 *
 * - left: Random.
 * - p: Distribution.
 *
 * !!! attention
 * Typically one does not call this directly, but rather uses the
 * [`~`](https://www.birch.sh/language/probability/) operator, which is
 * hard-wired to call this internally.
 */
function handle_assume<Left,Right>(left:Left, p:Right) {
  get_handler().handle(AssumeEvent(left, p.distribution()));
}

/**
 * Handle factor event.
 *
 * - w: Log-weight.
 *
 * !!! attention
 * Typically one does not call this directly, but rather uses the
 * [`factor`](https://www.birch.sh/language/probability/) statement, which is
 * hard-wired to call this internally.
 */
function handle_factor(w:Real) {
  get_handler().handle(FactorEvent(w));
}
