/**
 * Event handler.
 *
 * - delaySampling: Enable delayed sampling.
 * - delayExpressions: Enable delayed expressions.
 *
 * Events are triggered as code executes. Each event is handled via a call to
 * the currently-installed event handler, which is an object of type Handler.
 *
 * The events are:
 *
 * | Code       | Triggers                          |
 * | -----------| ----------------------------------|
 * | `x ~ p`    | [handleAssume](#handleassume)     |
 * | `x <~ p`   | [handleSimulate](#handlesimulate) |
 * | `x ~> p`   | [handleObserve](#handleobserve)   |
 * | `factor w` | [handleFactor](#handlefactor)     |
 * 
 * After `x ~ p`, certain operations on `x` may further trigger events:
 *
 * | Code                   | Triggers                                    |
 * | ---------------------- | --------------------------------------------|
 * | `x.value()`/`x.eval()` | [handleDelaySimulate](#handledelaysimulate) |
 * | `x <- y`               | [handleDelayObserve](#handledelayobserve)   |
 *
 * Finally, any manipulations of a Random `x` that is an interior node on the
 * delayed sampling $M$-path will require pruning of the path, which will
 * trigger [handleDelayPrune](handledelayprune).
 */
final class Handler(delaySampling:Boolean, delayExpressions:Boolean) {
  /**
   * Accumulated log-posterior.
   */
  π:Expression<Real>?;

  /**
   * Accumulated weight.
   */
  w:Real! <- 0.0;

  /**
   * Is delayed sampling enabled?
   */
  delaySampling:Boolean <- delaySampling;

  /**
   * Are delayed expressions enabled?
   */
  delayExpressions:Boolean <- delayExpressions;

  /**
   * Handle an assume event.
   *
   * - x: Random.
   * - p: Distribution.
   *
   * Returns: `x`.
   */
  function handleAssume<Value>(x:Random<Value>, p:Distribution<Value>) ->
      Random<Value> {
    if x.hasValue() {
      handleObserve(x, p);
    } else if !delaySampling {
      handleSimulate(x, p);
    } else {
      x.assume(p);
    }
    return x;
  }

  /**
   * Handle a simulate event.
   *
   * - x: Random.
   * - p: Distribution.
   *
   * Returns: `x`.
   */
  function handleSimulate<Value>(x:Random<Value>, p:Distribution<Value>) ->
      Random<Value> {
    x.assume(p);
    handleDelaySimulate(x);
    return x;
  }

  /**
   * Handle a simulate event.
   *
   * - p: Distribution.
   *
   * Returns: `x`.
   */
  function handleSimulate<Value>(p:Distribution<Value>) -> Value {
    if delayExpressions && p.supportsLazy() {
      let x <- p.simulateLazy()!;
      p.graft(x);
      return x;
    } else {
      let x <- p.simulate();
      p.graft(x);
      return x;
    }
  }

  /**
   * Handle an observe event.
   *
   * - x: Random.
   * - p: Distribution.
   *
   * Returns: `x`.
   */
  function handleObserve<Value>(x:Random<Value>, p:Distribution<Value>) ->
      Random<Value> {
    x.assume(p);
    handleDelayObserve(x);
    return x;
  }

  /**
   * Handle an observe event.
   *
   * - x: Variate.
   * - p: Distribution.
   *
   * Returns: `x`.
   */
  function handleObserve<Value>(x:Value, p:Distribution<Value>) -> Value {
    if delayExpressions && p.supportsLazy() {
      handleFactor(p.hitch(box(x))!);
    } else {
      handleFactor(p.logpdf(x));
    }
    p.graft(x);
    return x;
  }

  /**
   * Handle a factor event.
   *
   * - w: Log-weight.
   *
   * A factor event is triggered by the `factor` statement.
   */
  function handleFactor<Arg>(w:Arg) {
    if delayExpressions {
      this.w <- this.w + global.eval(w);
      if π? {
        π <- box(π! + w);
      } else {
        π <- box(w);
      }
    } else {
      this.w <- this.w + global.value(w);
    }
  }

  /**
   * Handle a delayed simulation event.
   *
   * - x: Random.
   */
  function handleDelaySimulate<Value>(x:Random<Value>) {
    let p <- x.getDistribution();
    if delayExpressions && p.supportsLazy() {
      x.set(p.simulateLazy()!);
      arg(x);
    } else {
      x.set(p.simulate());
    }
    x.p <- nil;
  }

  /**
   * Handle a delayed observation event.
   *
   * - x: Random.
   */
  function handleDelayObserve<Value>(x:Random<Value>) {
    let p <- x.getDistribution();
    if delayExpressions && p.supportsLazy() {
      handleFactor(p.hitch(x)!);
    } else {
      handleFactor(p.logpdf(x.value()));
    }
    x.p <- nil;
  }

  /**
   * Handle a prune event.
   *
   * - p: Distribution.
   * - x: Child of `p` on $M$-path.
   *
   * Returns: Updated distribution.
   */
  function handleDelayPrune<Value>(p:Distribution<Value>, x:Random<Value>) ->
      Delay {
    if delayExpressions && p.supportsLazy() {
      return p.updateLazy(x)!;
    } else {
      return p.update(x.value())!;
    }
  }

  /**
   * Handle a prune event.
   *
   * - p: Distribution.
   * - x: Child of `p` on $M$-path.
   *
   * Returns: Updated distribution.
   */
  function handleDelayPrune<Value>(p:Distribution<Value>, x:Value) -> Delay {
    if delayExpressions && p.supportsLazy() {
      return p.updateLazy(box(x))!;
    } else {
      return p.update(x)!;
    }
  }

  function arg(x:Random<Boolean>) {
    let p <- x.getDistribution().hitch(x);
    if p? {
      if π? {
        π <- box(π! + p!);
      } else {
        π <- box(p!);
      }
    }
  }

  function arg(x:Random<Integer>) {
    let p <- x.getDistribution().hitch(x);
    if p? {
      if π? {
        π <- box(π! + p!);
      } else {
        π <- box(p!);
      }
    }
  }

  function arg(x:Random<Integer[_]>) {
    let p <- x.getDistribution().hitch(x);
    if p? {
      if π? {
        π <- box(π! + p!);
      } else {
        π <- box(p!);
      }
    }
  }

  function arg(x:Random<Real>) {
    let p <- x.getDistribution().hitch(x);
    if p? {
      if π? {
        π <- box(π! + p!);
      } else {
        π <- box(p!);
      }
    }
  }

  function arg(x:Random<Real[_]>) {
    let p <- x.getDistribution().hitch(x);
    if p? {
      if π? {
        π <- box(π! + p!);
      } else {
        π <- box(p!);
      }
    }
  }

  function arg(x:Random<Real[_,_]>) {
    let p <- x.getDistribution().hitch(x);
    if p? {
      if π? {
        π <- box(π! + p!);
      } else {
        π <- box(p!);
      }
    }
  }
}
