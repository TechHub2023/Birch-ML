/**
 * Event handler.
 *
 * - delaySampling: Enable delayed sampling.
 * - delayExpressions: Enable delayed expressions.
 *
 * ```mermaid
 * classDiagram
 *    Handler <|-- ModelHandler
 *    link Handler "../Handler/"
 *    link ModelHandler "../ModelHandler/"
 * ```
 */
final class Handler(delaySampling:Boolean, delayExpressions:Boolean) {
  /**
   * Log-posterior, if delayed expressions are enabled.
   */
  π:Expression<Real>?;

  /*
   * Arguments.
   */
  b1:Tape<Random<Boolean>>?;
  i1:Tape<Random<Integer>>?;
  i2:Tape<Random<Integer[_]>>?;
  r1:Tape<Random<Real>>?;
  r2:Tape<Random<Real[_]>>?;
  r3:Tape<Random<Real[_,_]>>?;

  /**
   * Number of arguments.
   */
  n:Integer <- 0;

  /**
   * Accumulated weight.
   */
  w:Real <- 0.0;

  /**
   * Is delayed sampling enabled?
   */
  delaySampling:Boolean <- delaySampling;

  /**
   * Are delayed expressions enabled?
   */
  delayExpressions:Boolean <- delayExpressions;

  /**
   * Handle a simulate event.
   *
   * - p: Distribution.
   *
   * Returns: A value simulated from `p`.
   *
   * A simulate event is triggered by the `<~` operator.
   */
  function handleSimulate<Value>(p:Distribution<Value>) -> Value {
    let x <- p.simulate();
    p.graft(x);
    return x;
  }

  /**
   * Handle a simulate event.
   *
   * - x: Random.
   * - p: Distribution.
   *
   * Returns: `x`.
   *
   * A simulate event is triggered by the `<~` operator.
   */
  function handleSimulate<Value>(x:Random<Value>, p:Distribution<Value>) ->
      Random<Value> {
    x.assume(p);
    if delayExpressions && p.supportsLazy() {
      x.eval();
    } else {
      x.value();
    }
    return x;
  }

  /**
   * Handle an observe event.
   *
   * - x: Value.
   * - p: Distribution.
   *
   * Returns: `x`.
   *
   * An observe event is triggered by the `~>` operator.
   */
  function handleObserve<Value>(x:Value, p:Distribution<Value>) -> Value {
    if delayExpressions && p.supportsLazy() {
      handleFactor(p.logpdfLazy(box(x))!);
    } else {
      handleFactor(p.logpdf(x));
    }
    p.graft(x);
    return x;
  }

  /**
   * Handle an observe event.
   *
   * - x: Random.
   * - p: Distribution.
   *
   * Returns: `x`.
   *
   * An observe event is triggered by the `~>` operator.
   */
  function handleObserve<Value>(x:Random<Value>, p:Distribution<Value>) ->
      Random<Value> {
    if delayExpressions && p.supportsLazy() {
      handleFactor(p.logpdfLazy(x)!);
    } else {
      handleFactor(p.logpdf(x.value()));
    }
    p.graft(x);
    return x;
  }

  /**
   * Handle an assume event.
   *
   * - p: Distribution.
   *
   * Returns: A new Random with the associated distribution.
   *
   * An assume event is triggered by the `~` operator.
   */
  function handleAssume<Value>(p:Distribution<Value>) -> Random<Value> {
    x:Random<Value>;
    if !delaySampling {
      handleSimulate(x, p);
    } else {
      x.assume(p);
    }
    return x;
  }

  /**
   * Handle an assume event.
   *
   * - x: Random.
   * - p: Distribution.
   *
   * Returns: `x`.
   *
   * An assume event is triggered by the `~` operator.
   */
  function handleAssume<Value>(x:Random<Value>, p:Distribution<Value>) ->
      Random<Value> {
    if x.hasValue() {
      handleObserve(x, p);
    } else if !delaySampling {
      handleSimulate(x, p);
    } else {
      x.assume(p);
    }
    return x;
  }

  /**
   * Handle a realize event.
   *
   * - x: Random.
   * - p: Distribution.
   *
   * Returns: `x`.
   *
   * A prune event is triggered when the delayed sampling heuristic forces
   * the realization of a random variate on the $M$-path. The $M$-path is
   * pruned back to just below that random variate, which will be subsequently
   * realized.
   *
   * The $M$-path is implemented as a linked list of alternating Random and
   * Distribution objects. This overload handles the removal of nodes from
   * that list following a Random node.
   */
  function handleRealize<Value>(x:Random<Value>, p:Distribution<Value>) ->
      Delay {
    if delayExpressions && p.supportsLazy() {
      x.move(p.simulateLazy()!);
    } else {
      x.set(p.simulate());
    }
    return x;
  }

  /**
   * Handle an updated event.
   *
   * - p: Distribution.
   * - x: Value.
   *
   * Returns: Updated distribution.
   *
   * A prune event is triggered when the delayed sampling heuristic forces
   * the realization of a random variate on the $M$-path. The $M$-path is
   * pruned back to just below that random variate, which will be subsequently
   * realized.
   *
   * The $M$-path is implemented as a linked list of alternating Random and
   * Distribution objects. This overload handles the removal of nodes from
   * that list following a Distribution node.
   */
  function handleUpdate<Value>(p:Distribution<Value>, x:Value) -> Delay {
    if delayExpressions && p.supportsLazy() {
      return p.updateLazy(box(x))!;
    } else {
      return p.update(x)!;
    }
  }

  /**
   * Handle an updated event.
   *
   * - p: Distribution.
   * - x: Random.
   *
   * Returns: Updated distribution.
   *
   * A prune event is triggered when the delayed sampling heuristic forces
   * the realization of a random variate on the $M$-path. The $M$-path is
   * pruned back to just below that random variate, which will be subsequently
   * realized.
   *
   * The $M$-path is implemented as a linked list of alternating Random and
   * Distribution objects. This overload handles the removal of nodes from
   * that list following a Distribution node.
   */
  function handleUpdate<Value>(p:Distribution<Value>, x:Random<Value>) ->
      Delay {
    if delayExpressions && p.supportsLazy() {
      return p.updateLazy(x)!;
    } else {
      return p.update(x.value())!;
    }
  }

  /**
   * Handle a factor event.
   *
   * - w: Log-weight.
   *
   * A factor event is triggered by the `factor` statement.
   */
  function handleFactor<Arg>(w:Arg) {
    if delayExpressions {
      this.w <- this.w + global.eval(w);
      if π? {
        π <- box(π! + w);
      } else {
        π <- box(w);
      }
    } else {
      this.w <- this.w + global.value(w);
    }
  }

  /**
   * Evaluate the log-posterior.
   */
  function eval() -> Real {
    if π? {
      return π!.eval();
    } else {
      return 0.0;
    }
  }

  /**
   * Get value of real arguments.
   */
  function args() -> Real[_] {
    /* determine size */
    n <- 0;
    if r1? {
      n <- n + argSize(r1!);
    }
    if r2? {
      n <- n + argSize(r2!);
    }
    if r3? {
      n <- n + argSize(r3!);
    }
    assert π? || n == 0;

    /* get argument values */
    x:Real[n];
    let i <- 1;
    if r1? {
      let iter1 <- r1!.walk();
      while iter1.hasNext() {
        let v <- iter1.next();
        x[i] <- v.eval();
        i <- i + 1;
      }
    }
    if r2? {
      let iter2 <- r2!.walk();
      while iter2.hasNext() {
        let v <- iter2.next();
        let m <- i + v.size() - 1;
        x[i..m] <- v.eval();
        i <- m + 1;
      }
    }
    if r3? {
      let iter3 <- r3!.walk();
      while iter3.hasNext() {
        let v <- iter3.next();
        let m <- i + v.size() - 1;
        x[i..m] <- vec(v.eval());
        i <- m + 1;
      }
    }
    assert n == length(x) + 1;
    return x;
  }

  /**
   * Compute the gradient.
   */
  function grad() -> Real[_] {
    d:Real[n];
    if π? {
      /* compute gradient */
      π!.grad(1.0);

      /* get argument gradients */
      let i <- 1;
      if r1? {
        let iter1 <- r1!.walk();
        while iter1.hasNext() {
          let v <- iter1.next();
          d[i] <- v.d!;
          i <- i + 1;
        }
      }
      if r2? {
        let iter2 <- r2!.walk();
        while iter2.hasNext() {
          let v <- iter2.next();
          let j <- i + v.size() - 1;
          d[i..j] <- v.d!;
          i <- j + 1;
        }
      }
      if r3? {
        let iter3 <- r3!.walk();
        while iter3.hasNext() {
          let v <- iter3.next();
          let j <- i + v.size() - 1;
          d[i..j] <- vec(v.d!);
          i <- j + 1;
        }
      }
      assert i == n + 1;
    }
    return d;
  }

  /**
   * Move the expression.
   */
  function move(x:Real[_]) -> Real {
    let p <- 0.0;
    if π? {
      /* set argument values */
      let i <- 1;
      if r1? {
        let iter1 <- r1!.walk();
        while iter1.hasNext() {
          let v <- iter1.next();
          v.move(x[i]);
          i <- i + 1;
        }
      }
      if r2? {
        let iter2 <- r2!.walk();
        while iter2.hasNext() {
          let v <- iter2.next();
          let j <- i + v.size() - 1;
          v.move(x[i..j]);
          i <- j + 1;
        }
      }
      if r3? {
        let iter3 <- r3!.walk();
        while iter3.hasNext() {
          let v <- iter3.next();
          let j <- i + v.size() - 1;
          v.move(mat(x[i..j], v.columns()));
          i <- j + 1;
        }
      }
      assert i == n + 1;

      /* re-evaluate */
      p <- π!.reval();
    }
    return p;
  }

  /**
   * Label generations.
   *
   * See also: [Expression](../Expression/)
   */
  function label(gen:Integer) {
    π!.label(gen);
  }

  /**
   * Prune generations.
   *
   * See also: [Expression](../Expression/)
   */
  function prune(gen:Integer) {
    π!.prune(gen);
  }

  function arg(x:Random<Boolean>) {
    if !b1? {
      b1 <- construct<Tape<Random<Boolean>>>();
    }
    b1!.pushBack(x);
  }

  function arg(x:Random<Integer>) {
    if !i1? {
      i1 <- construct<Tape<Random<Integer>>>();
    }
    i1!.pushBack(x);
  }

  function arg(x:Random<Integer[_]>) {
    if !i2? {
      i2 <- construct<Tape<Random<Integer[_]>>>();
    }
    i2!.pushBack(x);
  }

  function arg(x:Random<Real>) {
    if !r1? {
      r1 <- construct<Tape<Random<Real>>>();
    }
    r1!.pushBack(x);
  }

  function arg(x:Random<Real[_]>) {
    if !r2? {
      r2 <- construct<Tape<Random<Real[_]>>>();
    }
    r2!.pushBack(x);
  }

  function arg(x:Random<Real[_,_]>) {
    if !r3? {
      r3 <- construct<Tape<Random<Real[_,_]>>>();
    }
    r3!.pushBack(x);
  }
}

/*
 * Determine the total size of all arguments in a [Tape](../Tape/),
 * simultaneously removing all constants.
 *
 * - o: The tape.
 */
function argSize<Value>(o:Tape<Random<Value>>) -> Integer {
  let n <- 0;
  let i <- 1;
  while i <= o.size() {
    if !o[i].isConstant() {
      n <- n + o[i].size();
      i <- i + 1;
    } else {
      o.erase(i);
    }
  }
  return n;
}

/*
 * As `argSize()`, but traverses the `Tape` in reverse, which may be more
 * efficient if its current position is closer to the back than the front.
 */
function argSizeReverse<Value>(o:Tape<Random<Value>>) ->
    Integer {
  let n <- 0;
  let i <- o.size();
  while i >= 1 {
    if !o[i].isConstant() {
      n <- n + o[i].size();
    } else {
      o.erase(i);
    }
    i <- i - 1;
  }
  return n;
}
