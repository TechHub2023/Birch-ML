/**
 * Event handler.
 *
 * - delaySampling: Enable delayed sampling.
 * - delayExpressions: Enable delayed expressions.
 */
final class Handler(delaySampling:Boolean, delayExpressions:Boolean) {
  /**
   * Input trace, if any.
   */
  input:Tape<Record>?;

  /**
   * Output trace, if any.
   */
  output:Tape<Record>?;

  /**
   * Delayed log-likelihood, if delayed expressions are enabled.
   */
  l:Expression<Real>?;

  /**
   * Delayed log-prior, if delayed expressions are enabled.
   */
  p:Expression<Real>?;

  /**
   * Accumulated weight.
   */
  w:Real <- 0.0;

  /**
   * Is delayed sampling enabled?
   */
  delaySampling:Boolean <- delaySampling;

  /**
   * Are delayed expressions enabled?
   */
  delayExpressions:Boolean <- delayExpressions;

  /**
   * Handle a simulate event.
   *
   * - p: The distribution from which to simulate.
   *
   * A simulate event is triggered by the `<~` operator.
   */
  final function handleSimulate<Value>(p:Distribution<Value>) -> Value {
    if input? {
      p.clamp(coerce<Value>());
    }
    let x <- p.realize();
    if output? {
      output!.pushBack(construct<ValueRecord<Value>>(x));
    }
    return x;
  }

  /**
   * Handle an observe event.
   *
   * - x: The observation.
   * - p: The distribution from which to observe.
   *
   * A simulate event is triggered by the `~>` operator.
   */
  final function handleObserve<Value>(x:Value, p:Distribution<Value>) ->
      Value {
    if delayExpressions && p.supportsLazy() {
      let v <- p.observeLazy(box(x));
      assert v?;
      if l? {
        l <- l! + v!;
      } else {
        l <- v;
      }
    } else {
      w <- w + p.observe(x);
    }
    return x;
  }

  /**
   * Handle an assume event.
   *
   * - x: The random variate.
   * - p: The distribution to associate with the random variate.
   *
   * An assume event is triggered by the `~` operator.
   */
  final function handleAssume<Value>(x:Random<Value>,
      p:Distribution<Value>) -> Random<Value> {
    if x.hasValue() {
      handleObserve(x.value(), p);
    } else {
      x.assume(p);
      if !delaySampling {
        handleRealize(p);
      }
    }
    return x;
  }

  /**
   * Handle a realize event.
   *
   * - p: Distribution.
   *
   * A realize event is triggered when the delayed sampling heuristic forces
   * the realization of a random variate that was previously associated with
   * a distribution using the `~` operator.
   */
  final function handleRealize<Value>(p:Distribution<Value>) -> Value {
    if input? {
      p.clamp(coerce<Value>());
    }
    x:Value;
    if delayExpressions && p.supportsLazy() {
      /* unlike a simulate event, as a realization is always associated with a
       * Random object, it is possible to realize without making Random
       * constant */
      x <- p.realizeLazy();

      /* record the prior log-density */
      let p1 <- p.logpdfLazy(p.v!);
      assert p1?;
      if this.p? {
        this.p <- this.p! + p1!;
      } else {
        this.p <- p1!;
      }
    } else {
      x <- p.realize();
    }
    if output? {
      output!.pushBack(construct<ValueRecord<Value>>(x));
    }
    if this.p? {
      /* evaluate the prior log-density, as it may required that further
       * Random objects are realized */
      this.p!.get();
    }
    return x;
  }

  /**
   * Handle a factor event.
   *
   * - w: Log-weight.
   *
   * A factor event is triggered by the `factor` statement.
   */
  final function handleFactor(w:Expression<Real>) {
    if delayExpressions {
      if l? {
        l <- l! + w;
      } else {
        l <- w;
      }
    } else {
      this.w <- this.w + w.value();
    }
  }

  /**
   * Handle a factor event.
   *
   * - w: Log-weight.
   *
   * A factor event is triggered by the `factor` statement.
   */
  final function handleFactor(w:Real) {
    this.w <- this.w + w;
  }

  /**
   * Coerce a value of the given type out of a record.
   */
  final function coerce<Value>() -> Value {
    assert input?;
    let r <- ValueRecord<Value>?(input!.front());
    if !r? {
      error("incompatible trace");
    }
    input!.popFront();
    return r!.x;
  }
}
