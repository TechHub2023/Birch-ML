/**
 * Random variate.
 *
 * @tparam Value Value type.
 */
struct Random<Value> < Form {
  phantom x;
  phantom p;

  hpp{{
  std::optional<numbirch::Future<Value>> x;
  std::optional<Distribution<Value>> p;

  /**
   * Copy assignment.
   */
  Random& operator=(const Random& o) {
    if (o.hasDistribution()) {
      setDistribution(*o.p);
    } else {
      this->x = o.x;
    }
    return *this;
  }

  /**
   * Value assignment.
   */
  Random& operator=(const Value& x) {
    assert(!this->x.has_value());
    if (hasDistribution()) {
      getDistribution()->assign(x);
    }
    this->x = x;
    this->constant();
    return *this;
  }

  /**
   * Does this have a value?
   */
  bool hasValue() const {
    return x.has_value() || (hasDistribution() &&
        getDistribution()->hasValue());
  }

  /**
   * Does this have a distribution?
   */
  bool hasDistribution() const {
    return p.has_value();
  }

  /**
   * Get the distribution.
   */
  Distribution<Value> getDistribution() const {
    assert(hasDistribution());
    return *p;
  }

  /**
   * Set the distribution.
   *
   * @param p Distribution.
   */
  void setDistribution(const Distribution<Value>& p);

  /**
   * Does this have a marginalized distribution?
   */
  bool hasMarginalized() const {
    return hasDistribution() && getDistribution()->hasMarginalized();
  }

  /**
   * Get the marginalized distribution.
   */
  Delay getMarginalized() const {
    assert(hasMarginalized());
    return getDistribution()->getMarginalized();
  }

  int rows() const {
    return birch::rows(peek());
  }

  int columns() const {
    return birch::columns(peek());
  }

  int length() const {
    return birch::length(peek());
  }

  int size() const {
    return birch::size(peek());
  }

  void reset() {
    if (hasDistribution()) {
      getDistribution()->reset();
    }
  }

  void relink(const RelinkVisitor& visitor) {
    if (hasDistribution()) {
      getDistribution()->relink(visitor);
    }
  }

  void constant() {
    if (hasDistribution()) {
      x = getDistribution()->eval();
      getDistribution()->constant();
    }
    assert(x.has_value());
    this->p.reset();
  }

  bool isConstant() const {
    return !hasDistribution() || getDistribution()->isConstant();
  }

  void clear() {
    this->x.reset();
  }
 
  auto value() const {
    const_cast<Random*>(this)->constant();  // also evaluates
    return *x;
  }
 
  auto eval() const {
    if (hasDistribution()) {
      return getDistribution()->eval();
    } else {
      assert(x.has_value());
      return *x;
    }
  }
 
  auto peek() const {
    if (!x) {
      assert(hasDistribution());
      const_cast<Random*>(this)->x = getDistribution()->peek();
    }
    return *x;
  }
 
  auto move(const MoveVisitor& visitor) {
    if (hasDistribution()) {
      return getDistribution()->move(visitor);
    } else {
      assert(x.has_value());
      return *x;
    }
  }
 
  void args(const ArgsVisitor& visitor) {
    if (hasDistribution()) {
      getDistribution()->args(visitor);
    }
  }
 
  template<class G>
  void shallowGrad(const G& g, const GradVisitor& visitor) {
    if (hasDistribution()) {
      getDistribution()->grad(g, visitor);
      clear();
    }
  }
 
  void deepGrad(const GradVisitor& visitor) {
    //
  }

  Delay graft() const {
    assert(hasDistribution());
    return *getDistribution()->graft();
  }

  bool isGaussian() const {
    return hasDistribution() && getDistribution()->getUpdated()->isGaussian();
  }

  bool isBeta() const {
    return hasDistribution() && getDistribution()->getUpdated()->isBeta();
  }

  bool isGamma() const {
    return hasDistribution() && getDistribution()->getUpdated()->isGamma();
  }

  bool isInverseGamma() const {
    return hasDistribution() && getDistribution()->getUpdated()->isInverseGamma();
  }

  bool isInverseWishart() const {
    return hasDistribution() && getDistribution()->getUpdated()->isInverseWishart();
  }

  bool isNormalInverseGamma() const {
    return hasDistribution() && getDistribution()->getUpdated()->isNormalInverseGamma();
  }

  bool isDirichlet() const {
    return hasDistribution() && getDistribution()->getUpdated()->isDirichlet();
  }

  bool isRestaurant() const {
    return hasDistribution() && getDistribution()->getUpdated()->isRestaurant();
  }

  bool isMultivariateGaussian() const {
    return hasDistribution() && getDistribution()->getUpdated()->isMultivariateGaussian();
  }

  bool isMultivariateNormalInverseGamma() const {
    return hasDistribution() && getDistribution()->getUpdated()->isMultivariateNormalInverseGamma();
  }

  bool isMultivariateNormalInverseWishart() const {
    return hasDistribution() && getDistribution()->getUpdated()->isMultivariateNormalInverseWishart();
  }

  bool isMultivariateNormalWishart() const {
    return hasDistribution() && getDistribution()->getUpdated()->isMultivariateNormalWishart();
  }

  bool isMatrixGaussian() const {
    return hasDistribution() && getDistribution()->getUpdated()->isMatrixGaussian();
  }

  bool isMatrixNormalInverseWishart() const {
    return hasDistribution() && getDistribution()->getUpdated()->isMatrixNormalInverseWishart();
  }

  bool isBoundedDiscrete() const {
    return hasDistribution() && getDistribution()->getUpdated()->isBoundedDiscrete();
  }

  void read(const Buffer& buffer);
  void read(const Integer t, const Buffer& buffer);
  void write(const Buffer& buffer);
  void write(const Integer t, const Buffer& buffer);
  }}

  cpp{{
  template<class Value>
  void Random<Value>::setDistribution(const Distribution<Value>& p) {
    assert(!hasDistribution());
    this->p = p;
    if (x) {
      getDistribution()->assign(*x);
    } else if (!get_handler()->autoconj) {
      getDistribution()->realize();
    }
  }

  template<class Value>
  void Random<Value>::read(const Buffer& buffer) {
    birch::optional_assign(*this, buffer->get<Value>());
  }

  template<class Value>
  void Random<Value>::read(const Integer t, const Buffer& buffer) {
    return read(buffer);
  }

  template<class Value>
  void Random<Value>::write(const Buffer& buffer) {
    if (x || p) {
      buffer->set(value());
    } else {
      buffer->setNil();
    }
  }

  template<class Value>
  void Random<Value>::write(const Integer t, const Buffer& buffer) {
    return write(buffer);
  }
  }}
}

/**
 * Create a Random.
 */
function make_random<Value>() -> Random<Value> {
  o:Random<Value>;
  return o;
}

/**
 * Box a value in a Random.
 *
 * @param x Value to assign.
 */
function make_random<Value>(x:Value) -> Random<Value> {
  o:Random<Value>;
  o <- x;
  return o;
}

/**
 * Box a value in a Random.
 *
 * @param x Value to assign.
 */
function make_random<Value>(x:Value?) -> Random<Value> {
  o:Random<Value>;
  o <-? x;
  return o;
}

/**
 * Box a value in a Random.
 *
 * @param x Value to assign.
 */
function make_random<Value>(x:Value!) -> Random<Value> {
  o:Random<Value>;
  o <- x;
  return o;
}

/**
 * Box a value in a Random.
 *
 * @param x Optional value to assign.
 */
function make_random<Value>(x:Value!?) -> Random<Value> {
  o:Random<Value>;
  if x? {
    o <- x!;
  }
  return o;
}

/**
 * Box a value in a Random (identity operation).
 *
 * @param x Existing object.
 */
function make_random<Value>(x:Random<Value>) -> Random<Value> {
  return x;
}
