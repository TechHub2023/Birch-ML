struct Vector<Value,Middle>(m:Middle) < Unary<Middle>(m) {
  //
}

function eval<Value,Middle>(x:Vector<Value,Middle>) -> {
  return vector<Value>(eval(x.m));
}

function value<Value,Middle>(x:Vector<Value,Middle>) -> {
  return vector<Value>(value(x.m));
}

function peek<Value,Middle>(x:Vector<Value,Middle>) -> {
  return vector<Value>(peek(x.m));
}

function grad<Value,Middle,Gradient>(x:Vector<Value,Middle>, d:Gradient) {
  grad(x.m, grad_vector<Value>(d, peek(x.m)));
}

/**
 * Convert to vector.
 */
function vector<Value,Middle>(m:Middle) -> Vector<Value,Middle> {
  return construct<Vector<Value,Middle>>(m);
}

hpp{{
namespace birch {
/**
 * Convert to vector.
 */
template<class Value, class Middle,
    std::enable_if_t<is_delay<Middle>::value,int> = 0>
Vector<Value,Middle> vector(Middle&& m) {
  return construct<Vector<Value,Middle>>(std::forward<Middle>(m));
}
}
}}

/**
 * Convert to vector.
 */
function vector<Value,Type>(m:Type[_]) -> Value[_] {
  return transform(m, \(x:Type) -> Value { return scalar<Value>(x); });
}

/**
 * Convert to vector.
 */
function vector<Value,Type>(m:Type[_,_]) -> Value[_] {
  assert columns(m) == 1;
  return vector<Value>(m[1..rows(m),1]);
}

/**
 * Convert to vector.
 */
function vector<Value>(m:Boolean) -> Value[_] {
  return [scalar<Value>(m)];
}

/**
 * Convert to vector.
 */
function vector<Value>(m:Integer) -> Value[_] {
  return [scalar<Value>(m)];
}

/**
 * Convert to vector.
 */
function vector<Value>(m:Real) -> Value[_] {
  return [scalar<Value>(m)];
}

function grad_vector<Gradient,Type>(d:Gradient[_], m:Type) -> {
  return scalar<Type>(d);
}

function grad_vector<Gradient,Type>(d:Gradient[_], m:Type[_]) -> {
  return vector<Type>(d);
}

function grad_vector<Gradient,Type>(d:Gradient[_], m:Type[_,_]) -> {
  return matrix<Type>(d);
}
