/*
 * Linear combination of four arguments.
 */
struct Combine<Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7,Arg8>(a:Arg1, w:Arg2,
    b:Arg3, x:Arg4, c:Arg5, y:Arg6, d:Arg7, z:Arg8) < Form {
  a:Arg1 <- a;
  w:Arg2 <- w;
  b:Arg3 <- b;
  x:Arg4 <- x;
  c:Arg5 <- c;
  y:Arg6 <- y;
  d:Arg7 <- d;
  z:Arg8 <- z;
}

function link<Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7,Arg8>(x:Combine<Arg1,Arg2,
    Arg3,Arg4,Arg5,Arg6,Arg7,Arg8>) {
  link(x.a);
  link(x.w);
  link(x.b);
  link(x.x);
  link(x.c);
  link(x.y);
  link(x.d);
  link(x.z);
}

function label<Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7,Arg8>(x:Combine<Arg1,Arg2,
    Arg3,Arg4,Arg5,Arg6,Arg7,Arg8>, gen:Integer) {
  label(x.a, gen);
  label(x.w, gen);
  label(x.b, gen);
  label(x.x, gen);
  label(x.c, gen);
  label(x.y, gen);
  label(x.d, gen);
  label(x.z, gen);
}

function constant<Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7,Arg8>(x:Combine<Arg1,
    Arg2,Arg3,Arg4,Arg5,Arg6,Arg7,Arg8>, gen:Integer) {
  constant(x.a, gen);
  constant(x.w, gen);
  constant(x.b, gen);
  constant(x.x, gen);
  constant(x.c, gen);
  constant(x.y, gen);
  constant(x.d, gen);
  constant(x.z, gen);
}

function constant<Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7,Arg8>(x:Combine<Arg1,
    Arg2,Arg3,Arg4,Arg5,Arg6,Arg7,Arg8>) {
  constant(x.a);
  constant(x.w);
  constant(x.b);
  constant(x.x);
  constant(x.c);
  constant(x.y);
  constant(x.d);
  constant(x.z);
}

function value<Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7,Arg8>(x:Combine<Arg1,Arg2,
    Arg3,Arg4,Arg5,Arg6,Arg7,Arg8>) -> {
  return combine(value(x.a), value(x.w), value(x.b), value(x.x), value(x.c),
      value(x.y), value(x.d), value(x.z));
}

function peek<Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7,Arg8>(x:Combine<Arg1,Arg2,
    Arg3,Arg4,Arg5,Arg6,Arg7,Arg8>) -> {
  return combine(peek(x.a), peek(x.w), peek(x.b), peek(x.x), peek(x.c),
      peek(x.y), peek(x.d), peek(x.z));
}

function eval<Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7,Arg8>(x:Combine<Arg1,Arg2,
    Arg3,Arg4,Arg5,Arg6,Arg7,Arg8>) -> {
  return combine(eval(x.a), eval(x.w), eval(x.b), eval(x.x), eval(x.c),
      eval(x.y), eval(x.d), eval(x.z));
}

function grad<Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7,Arg8,Gradient>(x:Combine<
    Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7,Arg8>, d:Gradient) {
  grad(x.a, d*peek(x.w));
  grad(x.w, d*peek(x.a));
  grad(x.b, d*peek(x.x));
  grad(x.x, d*peek(x.b));
  grad(x.c, d*peek(x.y));
  grad(x.y, d*peek(x.c));
  grad(x.d, d*peek(x.z));
  grad(x.z, d*peek(x.d));
}

hpp{{
namespace birch {
/**
 * Linear combination of four arguments.
 */
template<class Arg1, class Arg2, class Arg3, class Arg4, class Arg5,
    class Arg6, class Arg7, class Arg8, std::enable_if_t<
    is_delay<Arg1>::value || is_delay<Arg2>::value || is_delay<Arg3>::value ||
    is_delay<Arg4>::value || is_delay<Arg5>::value || is_delay<Arg6>::value ||
    is_delay<Arg7>::value || is_delay<Arg8>::value,int> = 0>
Combine<Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7,Arg8> combine(Arg1&& a, Arg2&& w,
    Arg3&& b, Arg4&& x, Arg5&& c, Arg6&& y, Arg7&& d, Arg8&& z) {
  return construct<Combine<Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7,Arg8>>(
      std::forward<Arg1>(a), std::forward<Arg2>(w), std::forward<Arg3>(b),
      std::forward<Arg4>(x), std::forward<Arg5>(c), std::forward<Arg6>(y),
      std::forward<Arg7>(d), std::forward<Arg8>(z));
}
}
}}
