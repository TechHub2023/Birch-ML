struct TraceFunction {
  function compute<Value>(m:Value) -> {
    return trace(m);
  }

  function grad<Gradient,Value>(d:Gradient, m:Value) -> {
    return d;
  }

  function grad<Gradient,Value>(d:Gradient, m:Value[_]) -> {
    return vector(d, global.length(m));
  }

  function grad<Gradient,Value>(d:Gradient, m:Value[_,_]) -> {
    return diagonal(d, global.rows(m));
  }
}
struct Trace<Middle> = Unary<TraceFunction,Middle>;

/**
 * Trace.
 */
function trace<Middle>(m:Middle) -> {
  return construct<Trace<Middle>>(m);
}

/**
 * Trace.
 */
function trace(m:Real) -> Real {
  return m;
}

/**
 * Trace.
 */
function trace(x:Real[_]) -> Real {
  return sum(x);
}

/**
 * Trace.
 */
function trace(A:Real[_,_]) -> Real {
  cpp{{
  return numbirch::trace(A.rows(), A.columns(), A.data(), A.rowStride());
  }}
}
