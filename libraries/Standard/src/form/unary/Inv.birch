struct InvFunction {
function compute<Value>(m:Value) -> {
    return inv(m);
  }

function grad<Gradient,Value>(d:Gradient, m:Value) -> {
    let m1 <- inv(m);
    return -outer(inner(m1, d), m1);
  }
}
struct Inv<Middle> = Unary<InvFunction,Middle>;

/**
 * Inverse of a matrix.
 */
function inv<Middle>(m:Middle) -> {
  return construct<Inv<Middle>>(m);
}

/**
 * Inverse of a matrix.
 */
function inv(A:Real[_,_]) -> Real[_,_] {
  B:Real[rows(A), columns(A)];
  cpp{{
  numbirch::inv(A.rows(), A.data(), A.rowStride(), B.data(), B.rowStride());
  }}
  return B;
}
