/**
 * Linear combination of four arguments.
 */
struct Combine<Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7,Arg8>(a:Arg1, w:Arg2,
    b:Arg3, x:Arg4, c:Arg5, y:Arg6, d:Arg7, z:Arg8) {
  a:Arg1 <- a;
  w:Arg2 <- w;
  b:Arg3 <- b;
  x:Arg4 <- x;
  c:Arg5 <- c;
  y:Arg6 <- y;
  d:Arg7 <- d;
  z:Arg8 <- z;

  function value() -> {
    return combine(global.value(a), global.value(w), global.value(b),
        global.value(x), global.value(c), global.value(y), global.value(d),
        global.value(z));
  }

  function peek() -> {
    return combine(global.peek(a), global.peek(w), global.peek(b),
        global.peek(x), global.peek(c), global.peek(y), global.peek(d),
        global.peek(z));
  }

  function eval() -> {
    return combine(global.eval(a), global.eval(w), global.eval(b),
        global.eval(x), global.eval(c), global.eval(y), global.eval(d),
        global.eval(z));
  }

  function reval() -> {
    return combine(global.reval(a), global.reval(w), global.reval(b),
        global.reval(x), global.reval(c), global.reval(y), global.reval(d),
        global.reval(z));
  }
  
  function grad<Gradient>(g:Gradient) {
    global.grad(a, g*w);
    global.grad(w, g*a);
    global.grad(b, g*x);
    global.grad(x, g*b);
    global.grad(c, g*y);
    global.grad(y, g*c);
    global.grad(d, g*z);
    global.grad(z, g*d);
  }

  function label(gen:Integer) {
    global.label(a, gen);
    global.label(w, gen);
    global.label(b, gen);
    global.label(x, gen);
    global.label(c, gen);
    global.label(y, gen);
    global.label(d, gen);
    global.label(z, gen);
  }

  function constant(gen:Integer) {
    global.constant(a, gen);
    global.constant(w, gen);
    global.constant(b, gen);
    global.constant(x, gen);
    global.constant(c, gen);
    global.constant(y, gen);
    global.constant(d, gen);
    global.constant(z, gen);
  }

  function constant() {
    global.constant(a);
    global.constant(w);
    global.constant(b);
    global.constant(x);
    global.constant(c);
    global.constant(y);
    global.constant(d);
    global.constant(z);
  }
}

/**
 * Linear combination of four arguments.
 */
function combine<Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7,Arg8>(a:Arg1, w:Arg2,
    b:Arg3, x:Arg4, c:Arg5, y:Arg6, d:Arg7, z:Arg8) -> {
  return construct<Combine<Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7,Arg8>>(a, w, b,
      x, c, y, d, z);
}

/**
 * Linear combination of four arguments.
 */
function combine(a:Real, A:Real[_,_], b:Real, B:Real[_,_], c:Real,
    C:Real[_,_], d:Real, D:Real[_,_]) -> Real[_,_] {
  assert rows(A) == rows(B);
  assert rows(A) == rows(C);
  assert rows(A) == rows(D);
  assert columns(A) == columns(B);
  assert columns(A) == columns(C);
  assert columns(A) == columns(D);

  E:Real[rows(A),columns(A)];
  cpp{{
  numbirch::combine(E.rows(), E.columns(), a, A.data(), A.stride(), b,
      B.data(), B.stride(), c, C.data(), C.stride(), d, D.data(), D.stride(),
      E.data(), E.stride());
  }}
  return E;
}
