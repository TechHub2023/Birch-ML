struct LogZConwayMaxwellPoisson<Left,Middle,Right>(l:Left, m:Middle,
    r:Right) < Ternary<Left,Middle,Right>(l, m, r) {
  /**
   * Memoized result.
   */
  phantom x;

  hpp{{
  BIRCH_TERNARY_FUNCTION_FORM(logz_conway_maxwell_poisson, logz_conway_maxwell_poisson_grad)
  }}
}

hpp{{
namespace birch {
/**
 * Logarithm of the normalizing constant of a Conway-Maxwell-Poisson
 * distribution truncated on a finite interval $[0,n]$.
 *
 * - λ: Rate.
 * - ν: Dispersion.
 * - n: Truncation point.
 *
 * Return: vector of probabilities on $[0,n]$.
 */
template<class Left, class Middle, class Right, std::enable_if_t<
    is_delay<Left,Middle,Right>::value,int> = 0>
LogZConwayMaxwellPoisson<Left,Middle,Right> logz_conway_maxwell_poisson(
    const Left& λ, const Middle& ν, const Right& n) {
  return construct<LogZConwayMaxwellPoisson<Left,Middle,Right>>(λ, ν, n);
}
}
}}

function logz_conway_maxwell_poisson(λ:Real, ν:Real, n:Integer) -> Real {
  let log_λ <- log(λ);

  /* to avoid taking exp() of large negative values, normalize each term in
   * this sum using the maximum term, which is the unnormalized log
   * probability at the mode; this is similar to log_sum_exp() */
  let μ <- min(pow(λ, 1.0/ν), cast<Real>(n));  // mode
  let mx <- μ*log_λ - ν*lgamma(μ + 1.0);  // max unnormalized log probability

  /* sum renormalized terms */
  let log_xf <- 0.0;  // accumulator of log(x!)
  let Z <- exp(-mx);  // for x == 0
  for x in 1..n {
    log_xf <- log_xf + log(cast<Real>(x));
    Z <- Z + exp(x*log_λ - ν*log_xf - mx);
  }

  return mx + log(Z);
}

function logz_conway_maxwell_poisson_grad<Gradient>(g:Gradient, λ:Real,
    ν:Real, n:Integer) -> (Real, Real, Real) {
  let log_λ <- log(λ);
  let μ <- min(pow(λ, 1.0/ν), cast<Real>(n));  // mode
  let mx <- μ*log_λ - ν*lgamma(μ + 1.0);  // renormalizer
  let log_xf <- 0.0;  // accumulator of lfact(x)
  let z <- 0.0;
  let Z <- exp(-mx);  // for x == 0
  let gλ <- 0.0;
  let gν <- 0.0;
  for x in 1..n {
    log_xf <- log_xf + log(x);
    z <- exp(x*log_λ - ν*log_xf - mx);
    Z <- Z + z;
    gλ <- gλ + x*z;
    gν <- gν + log_xf*z;
  }
  gλ <- g*gλ/(λ*Z);
  gν <- -g*gν/Z;

  return (gλ, gν, 0.0);
}
