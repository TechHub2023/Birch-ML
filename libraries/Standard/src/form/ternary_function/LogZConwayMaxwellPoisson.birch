struct LogZConwayMaxwellPoisson<Left,Middle,Right>(l:Left, m:Middle,
    r:Right) < Ternary<Left,Middle,Right>(l, m, r) {
  //
}

function value<Left,Middle,Right>(
      x:LogZConwayMaxwellPoisson<Left,Middle,Right>) -> {
  let λ <- value(x.l);
  let ν <- value(x.m);
  let n <- value(x.r);
  return logz_conway_maxwell_poisson(λ, ν, n);
}

function peek<Left,Middle,Right>(
      x:LogZConwayMaxwellPoisson<Left,Middle,Right>) -> {
  let λ <- peek(x.l);
  let ν <- peek(x.m);
  let n <- peek(x.r);
  return logz_conway_maxwell_poisson(λ, ν, n);
}

function eval<Left,Middle,Right>(
      x:LogZConwayMaxwellPoisson<Left,Middle,Right>) -> {
  let λ <- eval(x.l);
  let ν <- eval(x.m);
  let n <- eval(x.r);
  return logz_conway_maxwell_poisson(λ, ν, n);
}

function grad<Left,Middle,Right,Gradient>(
      x:LogZConwayMaxwellPoisson<Left,Middle,Right>, d:Gradient) {
  let λ <- peek(x.l);
  let ν <- peek(x.m);
  let n <- peek(x.r);
  let (dλ, dν, dn) <- logz_conway_maxwell_poisson_grad(d, λ, ν, n);
  grad(x.l, dλ);
  grad(x.m, dν);
  grad(x.r, dn);
}

hpp{{
namespace birch {
/**
 * Logarithm of the normalizing constant of a Conway-Maxwell-Poisson
 * distribution truncated on a finite interval $[0,n]$.
 *
 * - λ: Rate.
 * - ν: Dispersion.
 * - n: Truncation point.
 *
 * Return: vector of probabilities on $[0,n]$.
 */
template<class Left, class Middle, class Right, std::enable_if_t<
    is_delay<Left,Middle,Right>::value,int> = 0>
LogZConwayMaxwellPoisson<Left,Middle,Right> logz_conway_maxwell_poisson(
    const Left& λ, const Middle& ν, const Right& n) {
  return construct<LogZConwayMaxwellPoisson<Left,Middle,Right>>(λ, ν, n);
}
}
}}

function logz_conway_maxwell_poisson(λ:Real, ν:Real, n:Integer) -> Real {
  let log_λ <- log(λ);

  /* to avoid taking exp() of large negative values, normalize each term in
   * this sum using the maximum term, which is the unnormalized log
   * probability at the mode; this is similar to log_sum_exp() */
  let μ <- min(pow(λ, 1.0/ν), scalar<Real>(n));  // mode
  let mx <- μ*log_λ - ν*lgamma(μ + 1.0);  // max unnormalized log probability

  /* sum renormalized terms */
  let log_xf <- 0.0;  // accumulator of log(x!)
  let Z <- exp(-mx);  // for x == 0
  for x in 1..n {
    log_xf <- log_xf + log(scalar<Real>(x));
    Z <- Z + exp(x*log_λ - ν*log_xf - mx);
  }

  return mx + log(Z);
}

function logz_conway_maxwell_poisson_grad(d:Real, λ:Real, ν:Real,
    n:Integer) -> (Real, Real, Real) {
  let log_λ <- log(λ);
  let μ <- min(pow(λ, 1.0/ν), scalar<Real>(n));  // mode
  let mx <- μ*log_λ - ν*lgamma(μ + 1.0);  // renormalizer
  let log_xf <- 0.0;  // accumulator of lfact(x)
  let z <- 0.0;
  let Z <- exp(-mx);  // for x == 0
  let dλ <- 0.0;
  let dν <- 0.0;
  for x in 1..n {
    log_xf <- log_xf + log(x);
    z <- exp(x*log_λ - ν*log_xf - mx);
    Z <- Z + z;
    dλ <- dλ + x*z;
    dν <- dν + log_xf*z;
  }
  dλ <- d*dλ/(λ*Z);
  dν <- -d*dν/Z;

  return (dλ, dν, 0.0);
}
