final class MultiplyAddFunction {
function compute<LeftValue,MiddleValue,RightValue>(l:LeftValue, m:MiddleValue, r:RightValue) -> {
    return multiply_add(l, m, r);
  }

function gradLeft<Gradient,LeftValue,MiddleValue,RightValue>(d:Gradient, l:LeftValue, m:MiddleValue, r:RightValue) -> {
    return d*transpose(m);
  }

function gradMiddle<Gradient,LeftValue,MiddleValue,RightValue>(d:Gradient, l:LeftValue, m:MiddleValue, r:RightValue) -> {
    return transpose(l)*d;
  }

function gradRight<Gradient,LeftValue,MiddleValue,RightValue>(d:Gradient, l:LeftValue, m:MiddleValue, r:RightValue) -> {
    return d;
  }
}
class MultiplyAdd<Left,Middle,Right> = Ternary<MultiplyAddFunction,Left,Middle,Right>;

/**
 * Multiply and add.
 */
function multiply_add<Left,Middle,Right>(l:Left, m:Middle, r:Right) -> {
  return construct<MultiplyAdd<Left,Middle,Right>>(l, m, r);
}

/**
 * Multiply and add.
 */
function multiply_add(l:Boolean, m:Boolean, r:Boolean) -> Boolean {
  return l*m + r;
}

/**
 * Multiply and add.
 */
function multiply_add(l:Integer, m:Integer, r:Integer) -> Integer {
  return l*m + r;
}

/**
 * Multiply and add.
 */
function multiply_add(l:Integer, m:Integer, r:Real) -> Real {
  return l*m + r;
}

/**
 * Multiply and add.
 */
function multiply_add(l:Integer, m:Real, r:Integer) -> Real {
  return l*m + r;
}

/**
 * Multiply and add.
 */
function multiply_add(l:Integer, m:Real, r:Real) -> Real {
  return l*m + r;
}

/**
 * Multiply and add.
 */
function multiply_add(l:Real, m:Integer, r:Integer) -> Real {
  return l*m + r;
}

/**
 * Multiply and add.
 */
function multiply_add(l:Real, m:Integer, r:Real) -> Real {
  return l*m + r;
}

/**
 * Multiply and add.
 */
function multiply_add(l:Real, m:Real, r:Integer) -> Real {
  return l*m + r;
}

/**
 * Multiply and add.
 */
function multiply_add(l:Real, m:Real, r:Real) -> Real {
  return l*m + r;
}

/**
 * Multiply and add.
 */
function multiply_add(l:Integer[_,_], m:Integer[_], r:Integer[_]) -> Integer[_] {
  return l*m + r;
}

/**
 * Multiply and add.
 */
function multiply_add(l:Integer[_,_], m:Integer[_], r:Real[_]) -> Real[_] {
  return l*m + r;
}

/**
 * Multiply and add.
 */
function multiply_add(l:Integer[_,_], m:Real[_], r:Integer[_]) -> Real[_] {
  return l*m + r;
}

/**
 * Multiply and add.
 */
function multiply_add(l:Integer[_,_], m:Real[_], r:Real[_]) -> Real[_] {
  return l*m + r;
}

/**
 * Multiply and add.
 */
function multiply_add(l:Real[_,_], m:Integer[_], r:Integer[_]) -> Real[_] {
  return l*m + r;
}

/**
 * Multiply and add.
 */
function multiply_add(l:Real[_,_], m:Integer[_], r:Real[_]) -> Real[_] {
  return l*m + r;
}

/**
 * Multiply and add.
 */
function multiply_add(l:Real[_,_], m:Real[_], r:Integer[_]) -> Real[_] {
  return l*m + r;
}

/**
 * Multiply and add.
 */
function multiply_add(l:Real[_,_], m:Real[_], r:Real[_]) -> Real[_] {
  return l*m + r;
}

/**
 * Multiply and add.
 */
function multiply_add(l:Integer[_,_], m:Integer[_,_], r:Integer[_,_]) -> Integer[_,_] {
  return l*m + r;
}

/**
 * Multiply and add.
 */
function multiply_add(l:Integer[_,_], m:Integer[_,_], r:Real[_,_]) -> Real[_,_] {
  return l*m + r;
}

/**
 * Multiply and add.
 */
function multiply_add(l:Integer[_,_], m:Real[_,_], r:Integer[_,_]) -> Real[_,_] {
  return l*m + r;
}

/**
 * Multiply and add.
 */
function multiply_add(l:Integer[_,_], m:Real[_,_], r:Real[_,_]) -> Real[_,_] {
  return l*m + r;
}

/**
 * Multiply and add.
 */
function multiply_add(l:Real[_,_], m:Integer[_,_], r:Integer[_,_]) -> Real[_,_] {
  return l*m + r;
}

/**
 * Multiply and add.
 */
function multiply_add(l:Real[_,_], m:Integer[_,_], r:Real[_,_]) -> Real[_,_] {
  return l*m + r;
}

/**
 * Multiply and add.
 */
function multiply_add(l:Real[_,_], m:Real[_,_], r:Integer[_,_]) -> Real[_,_] {
  return l*m + r;
}

/**
 * Multiply and add.
 */
function multiply_add(l:Real[_,_], m:Real[_,_], r:Real[_,_]) -> Real[_,_] {
  return l*m + r;
}
