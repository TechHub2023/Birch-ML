/*
 * Function form with two arguments.
 */
struct Binary<Left,Right>(l:Left, r:Right) < Form {
  /**
   * Left argument.
   */
  l:Left <- l;

  /**
   * Right argument.
   */
  r:Right <- r;
}

function link<Left,Right>(x:Binary<Left,Right>) {
  link(x.l);
  link(x.r);
}

function label<Left,Right>(x:Binary<Left,Right>, gen:Integer) {
  label(x.l, gen);
  label(x.r, gen);
}

function constant<Left,Right>(x:Binary<Left,Right>, gen:Integer) {
  constant(x.l, gen);
  constant(x.r, gen);
}

function constant<Left,Right>(x:Binary<Left,Right>) {
  constant(x.l);
  constant(x.r);
}

hpp{{
#define BIRCH_BINARY_FUNCTION_FORM(f) \
  using Value = decltype(f(birch::peek(std::declval<Left>()), \
        birch::peek(std::declval<Right>()))); \
  std::optional<Value> x; \
  \
  const Value& value() const { \
    if (!x) { \
      const_cast<std::optional<Value>&>(x) = f(birch::value(this->l), \
          birch::value(this->r)); \
    } \
    return *x; \
  } \
  \
  const Value& peek() const { \
    if (!x) { \
      const_cast<std::optional<Value>&>(x) = f(birch::peek(this->l), \
          birch::peek(this->r)); \
    } \
    return *x; \
  } \
  \
  const Value& eval() const { \
    const_cast<std::optional<Value>&>(x) = f(birch::eval(this->l), \
        birch::eval(this->r)); \
    return *x; \
  }
}}
