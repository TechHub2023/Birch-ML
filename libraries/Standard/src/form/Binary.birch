/*
 * Function form with two arguments.
 */
struct Binary<Left,Right>(l:Left, r:Right) < Form {
  /**
   * Left argument.
   */
  l:Left <- l;

  /**
   * Right argument.
   */
  r:Right <- r;

  hpp{{
  void link() const {
    birch::link(l);
    birch::link(r);
  }

  void label(const Integer gen) const {
    birch::label(l, gen);
    birch::label(r, gen);
  }

  void constant(const Integer gen) const {
    birch::constant(l, gen);
    birch::constant(r, gen);
  }

  void constant() const {
    birch::constant(l);
    birch::constant(r);
  }
  }}
}

hpp{{
#define BIRCH_BINARY_FUNCTION_FORM(f, f_grad, args...) \
  using Value = decltype(f(birch::peek(std::declval<Left>()), \
        birch::peek(std::declval<Right>()), ##args)); \
  std::optional<Value> x; \
  \
  auto eval() const { \
    const_cast<std::optional<Value>&>(x).reset(); \
    return f(birch::eval(this->l), birch::eval(this->r), ##args);; \
  } \
  \
  auto move() const { \
    const_cast<std::optional<Value>&>(x).reset(); \
    return f(birch::move(this->l), birch::move(this->r), ##args); \
  } \
  \
  auto value() const { \
    auto x = this->eval(); \
    this->constant(); \
    return x; \
  } \
  \
  auto peek() const { \
    if (!x) { \
      const_cast<std::optional<Value>&>(x) = f(birch::peek(this->l), \
          birch::peek(this->r), ##args); \
    } \
    return *x; \
  } \
  \
  template<class G> \
  void shallowGrad(const G& g) const { \
    const_cast<std::optional<Value>&>(x).reset(); \
    auto [gl, gr] = f_grad(g, birch::peek(this->l), birch::peek(this->r), \
        ##args); \
    birch::shallow_grad(this->l, gl); \
    birch::shallow_grad(this->r, gr); \
  } \
  \
  void deepGrad() const { \
    birch::deep_grad(this->l); \
    birch::deep_grad(this->r); \
  }
}}
