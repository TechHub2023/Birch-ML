struct MatrixPack<Left,Right>(l:Left, r:Right) < Binary<Left,Right>(l, r) {
  //
}

function value<Left,Right>(x:MatrixPack<Left,Right>) -> {
  return pack(value(x.l), value(x.r));
}

function peek<Left,Right>(x:MatrixPack<Left,Right>) -> {
  return pack(peek(x.l), peek(x.r));
}

function eval<Left,Right>(x:MatrixPack<Left,Right>) -> {
  return pack(eval(x.l), eval(x.r));
}

function grad<Left,Right,Gradient>(x:MatrixPack<Left,Right>, d:Gradient) {
  let (dl, dr) <- grad_pack(d, peek(x.l), peek(x.r));
  grad(x.l, dl);
  grad(x.r, dr);
}

hpp{{
namespace birch {
/**
 * Pack two matrices next to one another (i.e. append rows) to create a
 * new matrix.
 */
template<class Left, class Right, std::enable_if_t<
    is_delay<Left,Right>::value,int> = 0>
MatrixPack<Left,Right> pack(Left&& l, Right&& r) {
  return construct<MatrixPack<Left,Right>>(std::forward<Left>(l),
      std::forward<Right>(r));
}
}
}}

/**
 * Pack two scalars next to one another as a row to create a new matrix.
 */
function pack(x:Real, y:Real) -> Real[_,_] {
  return [[x, y]];
}

/**
 * Pack two scalars next to one another as a row to create a new matrix.
 */
function pack(x:Integer, y:Integer) -> Integer[_,_] {
  return [[x, y]];
}

/**
 * Pack two vectors next to one another as columns of a new matrix.
 */
function pack<Type>(x:Type[_], y:Type[_]) -> Type[_,_] {
  assert length(x) == length(y);
  let R <- length(x);
  Z:Type[R,2];
  Z[1..R,1] <- x;
  Z[1..R,2] <- y;
  return Z;
}

/**
 * Pack two matrices next to one another (i.e. append rows) to create a
 * new matrix.
 */
function pack<Type>(l:Type[_,_], r:Type[_,_]) -> Type[_,_] {
  assert rows(l) == rows(r);
  let R <- rows(l);
  let C1 <- columns(l);
  let C2 <- columns(r);
  Z:Type[R,C1 + C2];
  Z[1..R,1..C1] <- l;
  Z[1..R,(C1 + 1)..(C1 + C2)] <- r;
  return Z;
}

function grad_pack<Gradient,Type>(d:Gradient, x:Type, y:Type) -> {
  assert rows(d) == 1 && columns(d) == 2;
  return (d[1,1], d[1,2]);
}

function grad_pack<Gradient,Type>(d:Gradient, x:Type[_], y:Type[_]) -> {
  assert columns(d) == 2;
  return (column(d, 1), column(d, 2));
}

function grad_pack<Gradient,Type>(d:Gradient, l:Type[_,_], r:Type[_,_]) -> {
  let r1 <- rows(l);
  let c1 <- columns(l);
  let c2 <- columns(r);
  return (d[1..r1, 1..c1], d[1..r1, (c1 + 1)..(c1 + c2)]);
}
