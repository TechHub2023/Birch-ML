struct MatrixSingle<Value,Left,Right>(l:Left, r:Right, m:Integer, n:Integer) <
    Binary<Left,Right>(l, r) {
  /**
   * Number of rows.
   */
  m:Integer <- m;

  /**
   * Number of columns.
   */
  n:Integer <- n;
}

function value<Value,Left,Right>(x:MatrixSingle<Value,Left,Right>) -> {
  return single<Value>(value(x.l), value(x.r), x.m, x.n);
}

function peek<Value,Left,Right>(x:MatrixSingle<Value,Left,Right>) -> {
  return single<Value>(peek(x.l), peek(x.r), x.m, x.n);
}

function eval<Value,Left,Right>(x:MatrixSingle<Value,Left,Right>) -> {
  return single<Value>(eval(x.l), eval(x.r), x.m, x.n);
}

function grad<Value,Left,Right,Gradient>(x:MatrixSingle<Value,Left,Right>,
    d:Gradient) {
  //
}

hpp{{
namespace birch {
using numbirch::single;

/**
 * Create single-entry matrix. One of the elements of the matrix is one, all
 * others are zero.
 *
 * - i: Row of single entry.
 * - j: Column of single entry.
 * - m: Number of rows.
 * - n: Number of columns.
 */
template<class Value, class Left, class Right, std::enable_if_t<
    is_delay<Left,Right>::value,int> = 0>
MatrixSingle<Value,Left,Right> single(const Left& i, const Right& j,
    const int m, const int n) {
  return construct<MatrixSingle<Value,Left,Right>>(i, j, m, n);
}
}
}}
