struct MatrixStack<Left,Right>(l:Left, r:Right) < Binary<Left,Right>(l, r) {
  //
}

function value<Left,Right>(x:MatrixStack<Left,Right>) -> {
  return stack(value(x.l), value(x.r));
}

function peek<Left,Right>(x:MatrixStack<Left,Right>) -> {
  return stack(peek(x.l), peek(x.r));
}

function eval<Left,Right>(x:MatrixStack<Left,Right>) -> {
  return stack(eval(x.l), eval(x.r));
}

function grad<Left,Right,Gradient>(x:MatrixStack<Left,Right>, d:Gradient) {
  let (dl, dr) <- grad_stack(d, peek(x.l), peek(x.r));
  grad(x.l, dl);
  grad(x.r, dr);
}

hpp{{
namespace birch {
/**
 * Stack two matrices atop one another (i.e. append columns) to create a
 * new matrix.
 */
template<class Left, class Right, std::enable_if_t<is_delay<Left>::value ||
    is_delay<Right>::value,int> = 0>
MatrixStack<Left,Right> stack(Left&& l, Right&& r) {
  return construct<MatrixStack<Left,Right>>(std::forward<Left>(l),
      std::forward<Right>(r));
}
}
}}

/**
 * Stack two scalars atop one another (i.e. append them) to create a
 * new vector of length two.
 */
function stack<Type>(x:Type, y:Type) -> Type[_] {
  return [x, y];
}

/**
 * Stack two vectors atop one another (i.e. append them) to create a
 * new vector.
 */
function stack<Type>(x:Type[_], y:Type[_]) -> Type[_] {
  let l1 <- length(x);
  let l2 <- length(y);
  z:Type[l1 + l2];
  z[1..l1] <- x;
  z[(l1 + 1)..(l1 + l2)] <- y;
  return z;
}

/**
 * Stack a vector and scalar atop one another (i.e. append them) to create a
 * new vector.
 */
function stack<Type>(x:Type[_], y:Type) -> Type[_] {
  let l1 <- length(x);
  z:Type[l1 + 1];
  z[1..l1] <- x;
  z[l1 + 1] <- y;
  return z;
}

/**
 * Stack a scalar and vector atop one another (i.e. append them) to create a
 * new vector.
 */
function stack<Type>(x:Type, y:Type[_]) -> Type[_] {
  let l2 <- length(y);
  z:Type[1 + l2];
  z[2..(1 + l2)] <- y;
  z[1] <- x;
  return z;
}

/**
 * Stack two matrices atop one another (i.e. append columns) to create a
 * new matrix.
 */
function stack<Type>(X:Type[_,_], Y:Type[_,_]) -> Type[_,_] {
  assert columns(X) == columns(Y);
  let R1 <- rows(X);
  let R2 <- rows(Y);
  let C <- columns(X);
  Z:Type[R1 + R2, C];
  Z[1..R1,1..C] <- X;
  Z[(R1 + 1)..(R1 + R2),1..C] <- Y;
  return Z;
}

function grad_stack<Gradient,Left,Right>(d:Gradient, l:Left, r:Right) -> {
  return (d[1], d[2]);
}

function grad_stack<Gradient,Left,Right>(d:Gradient, l:Left[_], r:Right) -> {
  return (d[1..(length(d) - 1)], d[length(d)]);
}

function grad_stack<Gradient,Left,Right>(d:Gradient, l:Left, r:Right[_]) -> {
  return (d[1], d[2..length(d)]);
}

function grad_stack<Gradient,Left,Right>(d:Gradient, l:Left[_],
    r:Right[_]) -> {
  return (d[1..length(l)], d[(length(l) + 1)..length(d)]);
}

function grad_stack<Gradient,Left,Right>(d:Gradient, l:Left[_,_],
    r:Right[_,_]) -> {
  let r1 <- rows(l);
  let r2 <- rows(r);
  let c1 <- columns(l);
  return (d[1..r1,1..c1], d[(r1 + 1)..(r1 + r2),1..c1]);
}
