struct MatrixStack<Left,Right>(l:Left, r:Right) < Binary<Left,Right>(l, r) {
  //
}

function value<Left,Right>(x:MatrixStack<Left,Right>) -> {
  return stack(value(x.l), value(x.r));
}

function peek<Left,Right>(x:MatrixStack<Left,Right>) -> {
  return stack(peek(x.l), peek(x.r));
}

function eval<Left,Right>(x:MatrixStack<Left,Right>) -> {
  return stack(eval(x.l), eval(x.r));
}

function grad<Left,Right,Gradient>(x:MatrixStack<Left,Right>, d:Gradient) {
  let (dl, dr) <- grad_stack(d, peek(x.l), peek(x.r));
  grad(x.l, dl);
  grad(x.r, dr);
}

/**
 * Stack two matrices atop one another (i.e. append columns) to create a
 * new matrix.
 */
function stack<Left,Right>(l:Left, r:Right) -> MatrixStack<Left,Right> {
  cpp{{
  static_assert(is_form<Left,Right>::value, "argument types not supported");
  }}
  return construct<MatrixStack<Left,Right>>(l, r);
}

/**
 * Stack two scalars atop one another (i.e. append them) to create a
 * new vector.
 */
function stack(x:Real, y:Real) -> Real[_] {
  return [x, y];
}

/**
 * Stack two scalars atop one another (i.e. append them) to create a
 * new vector.
 */
function stack(x:Integer, y:Integer) -> Integer[_] {
  return [x, y];
}

/**
 * Stack two vectors atop one another (i.e. append them) to create a
 * new vector.
 */
function stack<Type>(x:Type[_], y:Type[_]) -> Type[_] {
  let l1 <- length(x);
  let l2 <- length(y);
  z:Type[l1 + l2];
  z[1..l1] <- x;
  z[(l1 + 1)..(l1 + l2)] <- y;
  return z;
}

/**
 * Stack a vector and scalar atop one another (i.e. append them) to create a
 * new vector.
 */
function stack<Type>(x:Type[_], y:Type) -> Type[_] {
  let l1 <- length(x);
  z:Type[l1 + 1];
  z[1..l1] <- x;
  z[l1 + 1] <- y;
  return z;
}

/**
 * Stack a scalar and vector atop one another (i.e. append them) to create a
 * new vector.
 */
function stack<Type>(x:Type, y:Type[_]) -> Type[_] {
  let l2 <- length(y);
  z:Type[1 + l2];
  z[2..(1 + l2)] <- y;
  z[1] <- x;
  return z;
}

/**
 * Stack two matrices atop one another (i.e. append columns) to create a
 * new matrix.
 */
function stack<Type>(X:Type[_,_], Y:Type[_,_]) -> Type[_,_] {
  assert columns(X) == columns(Y);
  let R1 <- rows(X);
  let R2 <- rows(Y);
  let C <- columns(X);
  Z:Type[R1 + R2, C];
  Z[1..R1,1..C] <- X;
  Z[(R1 + 1)..(R1 + R2),1..C] <- Y;
  return Z;
}

function grad_stack(d:Real[_], l:Real, r:Real) -> (Real, Real) {
  return (d[1], d[2]);
}

function grad_stack(d:Real[_], l:Integer, r:Integer) -> (Real, Real) {
  return (d[1], d[2]);
}

function grad_stack<Type>(d:Real[_], l:Type[_], r:Type) -> (Real[_], Real) {
  return (d[1..(length(d) - 1)], d[length(d)]);
}

function grad_stack<Type>(d:Real[_], l:Type, r:Type[_]) -> (Real, Real[_]) {
  return (d[1], d[2..length(d)]);
}

function grad_stack<Type>(d:Real[_], l:Type[_], r:Type[_]) ->
    (Real[_], Real[_]) {
  return (d[1..length(l)], d[(length(l) + 1)..length(d)]);
}

function grad_stack<Type>(d:Real[_,_], l:Type[_,_], r:Type[_,_]) ->
    (Real[_,_], Real[_,_]) {
  let r1 <- rows(l);
  let r2 <- rows(r);
  let c1 <- columns(l);
  return (d[1..r1,1..c1], d[(r1 + 1)..(r1 + r2),1..c1]);
}
