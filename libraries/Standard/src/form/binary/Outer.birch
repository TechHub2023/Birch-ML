struct OuterFunction {
  function compute<LeftValue,RightValue>(l:LeftValue, r:RightValue) -> {
    return outer(l, r);
  }

  function grad<Gradient,LeftValue,RightValue>(d:Gradient, l:LeftValue,
      r:RightValue) -> {
    return (d*r, inner(d, l));
  }
}
struct Outer<Left,Right> = Binary<OuterFunction,Left,Right>;

/**
 * Outer product.
 */
function outer<Left,Right>(l:Left, r:Right) -> {
  return construct<Outer<Left,Right>>(l, r);
}

/**
 * Scalar product.
 */
function outer(x:Real, y:Real) -> Real {
  return x*y;
}

/**
 * Scalar product.
 */
function outer(x:Integer, y:Real) -> Real {
  return outer(scalar<Real>(x), y);
}

/**
 * Scalar product.
 */
function outer(x:Real, y:Integer) -> Real {
  return outer(x, scalar<Real>(y));
}

/**
 * Scalar-vector outer product.
 */
function outer(x:Real, y:Real[_]) -> Real[_,_] {
  Z:Real[1,length(y)];
  cpp{{
  numbirch::transpose(Z.rows(), Z.columns(), x, y.data(), y.stride(),
      Z.data(), Z.stride());
  }}
  return Z;
}

/**
 * Scalar-vector outer product.
 */
function outer(x:Integer, y:Real[_]) -> Real[_,_] {
  return outer(scalar<Real>(x), y);
}

/**
 * Scalar-vector product.
 */
function outer(x:Real[_], y:Real) -> Real[_] {
  return x*y;
}

/**
 * Scalar-vector product.
 */
function outer(x:Real[_], y:Integer) -> Real[_] {
  return outer(x, scalar<Real>(y));
}

/**
 * Scalar-matrix outer product.
 */
function outer(x:Real, Y:Real[_,_]) -> Real[_,_] {
  Z:Real[columns(Y),rows(Y)];
  cpp{{
  numbirch::transpose(Z.rows(), Z.columns(), x, Y.data(), Y.stride(),
      Z.data(), Z.stride());
  }}
  return Z;
}

/**
 * Scalar-matrix outer product.
 */
function outer(x:Integer, Y:Real[_,_]) -> Real[_,_] {
  return outer(scalar<Real>(x), Y);
}

/**
 * Scalar-matrix product.
 */
function outer(X:Real[_,_], y:Real) -> Real[_,_] {
  return X*y;
}

/**
 * Scalar-matrix product.
 */
function outer(X:Real[_,_], y:Integer) -> Real[_,_] {
  return outer(X, scalar<Real>(y));
}

/**
 * Vector outer product.
 */
function outer(x:Real[_], y:Real[_]) -> Real[_,_] {
  z:Real[length(x), length(y)];
  cpp{{
  numbirch::outer(x.rows(), y.rows(), x.data(), x.stride(), y.data(),
      y.stride(), z.data(), z.stride());
  }}
  return z;
}

/**
 * Matrix outer product.
 */
function outer(X:Real[_,_], Y:Real[_,_]) -> Real[_,_] {
  assert columns(X) == columns(Y);

  Z:Real[rows(X), rows(Y)];
  cpp{{
  numbirch::outer(Z.rows(), Z.columns(), X.columns(), X.data(), X.stride(),
      Y.data(), Y.stride(), Z.data(), Z.stride());
  }}
  return Z;
}
