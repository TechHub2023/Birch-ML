struct DivideFunction {  
  function compute<LeftValue,RightValue>(l:LeftValue, r:RightValue) -> {
    return l/r;
  }

  function grad<Gradient,LeftValue,RightValue>(d:Gradient, l:LeftValue,
      r:RightValue) -> {
    return (d/r, -trace(inner(d, l))/pow(r, 2.0));
  }
}
struct Divide<Left,Right> = Binary<DivideFunction,Left,Right>;

/**
 * Division.
 */
operator<Left,Right> (l:Left/r:Right) -> Divide<Left,Right> {
  return construct<Divide<Left,Right>>(l, r);
}

/**
 * Division.
 */
operator (x:Integer/y:Integer) -> Integer;

/**
 * Division.
 */
operator (x:Integer/y:Real) -> Real;

/**
 * Division.
 */
operator (x:Real/y:Integer) -> Real;

/**
 * Division.
 */
operator (x:Real/y:Real) -> Real;

/**
 * Division.
 */
operator (x:Real[_]/y:Real) -> Real[_] {
  z:Real[length(x)];
  cpp{{
  numbirch::div(x.rows(), x.data(), x.stride(), y, z.data(), z.stride());
  }}
  return z;
}

/**
 * Division.
 */
operator (x:Real[_]/y:Integer) -> Real[_] {
  return x/scalar<Real>(y);
}

/**
 * Division.
 */
operator (X:Real[_,_]/y:Real) -> Real[_,_] {
  Z:Real[rows(X), columns(X)];
  cpp{{
  numbirch::div(X.rows(), X.columns(), X.data(), X.stride(), y, Z.data(),
      Z.stride());
  }}
  return Z;
}

/**
 * Division.
 */
operator (X:Real[_,_]/y:Integer) -> Real[_,_] {
  return X/scalar<Real>(y);
}
