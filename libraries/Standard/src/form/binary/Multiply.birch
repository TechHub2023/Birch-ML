struct MultiplyFunction {  
  function compute<LeftValue,RightValue>(l:LeftValue, r:RightValue) -> {
    return l*r;
  }

  function grad<Gradient,LeftValue,RightValue>(d:Gradient, l:LeftValue,
      r:RightValue) -> {
    return (trace(outer(d, r)), trace(inner(l, d)));
  }

  function grad<Gradient,LeftValue,RightValue>(d:Gradient, l:LeftValue,
      r:RightValue[_]) -> {
    return (trace(outer(d, r)), inner(l, d));
  }

  function grad<Gradient,LeftValue,RightValue>(d:Gradient, l:LeftValue,
      r:RightValue[_,_]) -> {
    return (trace(outer(d, r)), inner(l, d));
  }

  function grad<Gradient,LeftValue,RightValue>(d:Gradient, l:LeftValue[_],
      r:RightValue) -> {
    return (outer(d, r), trace(inner(l, d)));
  }

  function grad<Gradient,LeftValue,RightValue>(d:Gradient, l:LeftValue[_],
      r:RightValue[_]) -> {
    return (outer(d, r), inner(l, d));
  }

  function grad<Gradient,LeftValue,RightValue>(d:Gradient, l:LeftValue[_],
      r:RightValue[_,_]) -> {
    return (outer(d, r), inner(l, d));
  }

  function grad<Gradient,LeftValue,RightValue>(d:Gradient,
      l:LeftValue[_,_], r:RightValue) -> {
    return (outer(d, r), trace(inner(l, d)));
  }

  function grad<Gradient,LeftValue,RightValue>(d:Gradient,
      l:LeftValue[_,_], r:RightValue[_]) -> {
    return (outer(d, r), inner(l, d));
  }

  function grad<Gradient,LeftValue,RightValue>(d:Gradient,
      l:LeftValue[_,_], r:RightValue[_,_]) -> {
    return (outer(d, r), inner(l, d));
  }
}
struct Multiply<Left,Right> = Binary<MultiplyFunction,Left,Right>;

/**
 * Multiplication.
 */
operator<Left,Right> (l:Left*r:Right) -> Multiply<Left,Right> {
  return construct<Multiply<Left,Right>>(l, r);
}

/**
 * Multiplication.
 */
operator (x:Integer*y:Integer) -> Integer;

/**
 * Multiplication.
 */
operator (x:Integer*y:Real) -> Real;

/**
 * Multiplication.
 */
operator (x:Real*y:Integer) -> Real;

/**
 * Multiplication.
 */
operator (x:Real*y:Real) -> Real;

/**
 * Scalar-vector multiplication.
 */
operator (x:Real*y:Real[_]) -> Real[_] {
  z:Real[length(y)];
  cpp{{
  numbirch::mul(y.rows(), x, y.data(), y.stride(), z.data(),
      z.stride());
  }}
  return z;
}

/**
 * Scalar-vector multiplication.
 */
operator (x:Real[_]*y:Real) -> Real[_] {
  return y*x;
}

/**
 * Scalar-vector multiplication.
 */
operator (x:Integer*y:Real[_]) -> Real[_] {
  return scalar<Real>(x)*y;
}

/**
 * Scalar-vector multiplication.
 */
operator (x:Real[_]*y:Integer) -> Real[_] {
  return x*scalar<Real>(y);
}

/**
 * Scalar-matrix multiplication.
 */
operator (x:Real*Y:Real[_,_]) -> Real[_,_] {
  Z:Real[rows(Y), columns(Y)];
  cpp{{
  numbirch::mul(Y.rows(), Y.columns(), x, Y.data(), Y.stride(), Z.data(),
      Z.stride());
  }}
  return Z;
}

/**
 * Scalar-matrix multiplication.
 */
operator (X:Real[_,_]*y:Real) -> Real[_,_] {
  return y*X;
}

/**
 * Scalar-matrix multiplication.
 */
operator (x:Integer*y:Real[_,_]) -> Real[_,_] {
  return scalar<Real>(x)*y;
}

/**
 * Scalar-matrix multiplication.
 */
operator (x:Real[_,_]*y:Integer) -> Real[_,_] {
  return x*scalar<Real>(y);
}

/**
 * Matrix-vector multiplication.
 */
operator (X:Real[_,_]*y:Real[_]) -> Real[_] {
  assert columns(X) == length(y);

  z:Real[rows(X)];
  cpp{{
  numbirch::mul(X.rows(), X.columns(), X.data(), X.stride(), y.data(),
      y.stride(), z.data(), z.stride());
  }}
  return z;
}

/**
 * Multiplication.
 */
operator (X:Real[_,_]*Y:Real[_,_]) -> Real[_,_] {
  assert columns(X) == rows(Y);

  Z:Real[rows(X), columns(Y)];
  cpp{{
  numbirch::mul(Z.rows(), Z.columns(), X.columns(), X.data(), X.stride(),
      Y.data(), Y.stride(), Z.data(), Z.stride());
  }}
  return Z;
}
