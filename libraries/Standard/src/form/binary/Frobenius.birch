struct FrobeniusFunction {  
  function compute<LeftValue,RightValue>(l:LeftValue, r:RightValue) -> {
    return frobenius(l, r);
  }

  function grad<Gradient,LeftValue,RightValue>(d:Gradient, l:LeftValue,
      r:RightValue) -> {
    return (d*r, d*l);
  }
}
struct Frobenius<Left,Right> = Binary<FrobeniusFunction,Left,Right>;

/**
 * Frobenius product.
 */
function frobenius<Left,Right>(l:Left, r:Right) -> Frobenius<Left,Right> {
  return construct<Frobenius<Left,Right>>(l, r);
}

/**
 * Frobenius matrix product.
 */
function frobenius(X:Real[_,_], Y:Real[_,_]) -> Real {
  assert rows(X) == rows(Y);
  assert columns(X) == columns(Y);
  cpp{{
  return numbirch::frobenius(X.rows(), X.columns(), X.data(), X.stride(),
      Y.data(), Y.stride());
  }}
}
