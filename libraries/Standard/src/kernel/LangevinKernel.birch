/**
 * Langevin Markov kernel, with Metropolis adjustment.
 *
 * ```mermaid
 * classDiagram
 *    Kernel <|-- LangevinKernel
 *    link Kernel "../Kernel/"
 *    link LangevinKernel "../LangevinKernel/"
 * ```
 */
class LangevinKernel < Kernel {
  /**
   * Scale of each move.
   */
  scale:Real <- 1.0;

  function apply(t:Integer, π:Particle) -> Real {
    let δ <- scale/pow(min(t, nlags), 3);

    /* apply lag */
    π.label(t);
    π.prune(t - nlags);

    /* initial state */
    let x <- π.args();
    let p <- π.eval();
    let d <- π.grad();
    let μ <- x + d*δ;
    let Σ <- diagonal(2.0*δ, length(x));

    /* moves */
    let naccepts <- 0;
    let accept <- false;
    for n in 1..nmoves {
      /* proposed state */
      let x' <- simulate_multivariate_gaussian(μ, Σ);
      let p' <- π.move(x');
      let d' <- π.grad();
      let μ' <- x' + d'*δ;

      /* accept/reject */
      let q <- logpdf_multivariate_gaussian(x, μ', Σ);
      let q' <- logpdf_multivariate_gaussian(x', μ, Σ);      
      accept <- simulate_uniform(0.0, 1.0) <= p' - p + q - q';
      if accept {
        naccepts <- naccepts + 1;
        x <- x';
        p <- p';
        d <- d';
        μ <- μ';
      }
    }
    if !accept {
      /* if last proposal was not accepted, restore correct arguments,
       * otherwise already correct */
      π.move(x);
    }
    return scalar<Real>(naccepts)/nmoves;
  }

  override function read(buffer:Buffer) {
    super.read(buffer);
    scale <-? buffer.get<Real>("scale");
  }
  
  override function write(buffer:Buffer) {
    super.write(buffer);
    buffer.set("scale", scale);
  }
}
