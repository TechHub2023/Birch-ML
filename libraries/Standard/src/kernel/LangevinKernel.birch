/**
 * Langevin Markov kernel, with Metropolis adjustment.
 *
 * ```mermaid
 * classDiagram
 *    Kernel <|-- LangevinKernel
 *    link Kernel "../Kernel/"
 *    link LangevinKernel "../LangevinKernel/"
 * ```
 */
class LangevinKernel < Kernel {
  /**
   * Scale of each move.
   */
  scale:Real <- 1.0;

  function apply(t:Integer, π:Particle) -> Real {
    let δ <- scale/pow(min(t, nlags), 3);
    let σ2 <- 2.0*δ;
    let s <- t - nlags;

    /* initial state */
    let x <- π.args(s);
    let p <- π.eval(s);
    let d <- π.grad(s);
    let μ <- x + d*δ;

    /* moves */
    let naccepts <- 0;
    let accept <- false;
    for n in 1..nmoves {
      /* proposed state */
      let x' <- simulate_multivariate_gaussian(μ, σ2);
      let p' <- π.move(s, x');
      let d' <- π.grad(s);
      let μ' <- x' + d'*δ;

      /* accept/reject */
      let q <- logpdf_multivariate_gaussian(x, μ', σ2);
      let q' <- logpdf_multivariate_gaussian(x', μ, σ2);      
      accept <- simulate_uniform(0.0, 1.0) <= p' - p + q - q';
      if accept {
        naccepts <- naccepts + 1;
        x <- x';
        p <- p';
        d <- d';
        μ <- μ';
      }
    }
    if !accept {
      /* if last proposal was not accepted, restore correct arguments,
       * otherwise already correct */
      π.move(s, x);
    }
    return Real(naccepts)/nmoves;
  }

  override function read(buffer:Buffer) {
    super.read(buffer);
    scale <-? buffer.get<Real>("scale");
  }
  
  override function write(buffer:Buffer) {
    super.write(buffer);
    buffer.set("scale", scale);
  }
}
