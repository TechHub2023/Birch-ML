hpp{{
#include <yaml.h>
}}

/**
 * Reader for YAML files.
 *
 * ```mermaid
 * classDiagram
 *   class Iterator~Buffer~ {
 *     hasNext() Boolean
 *     next() Buffer
 *   }
 *   Iterator~Buffer~ <|-- Reader
 *   Reader <|-- YAMLReader
 *   Reader <|-- JSONReader
 *   YAMLReader -- JSONReader
 *   link Iterator "../Iterator/"
 *   link Reader "../Reader/"
 *   link YAMLReader "../YAMLReader/"
 *   link JSONReader "../JSONReader/"
 * ```
 */
class YAMLReader < Reader {
  /**
   * The file.
   */
  file:File;

  hpp{{
  yaml_parser_t parser;
  yaml_event_t event;
  }}

  override function open(path:String) {
    file <- fopen(path, READ);
    cpp{{
    yaml_parser_initialize(&this->parser);
    yaml_parser_set_input_file(&this->parser, this->file);
    }}
  }

  override function slurp() -> Buffer {
    buffer:Buffer;
    cpp{{
    int done = 0;
    while (!done) {
      if (!yaml_parser_parse(&this->parser, &this->event)) {
        error("parse error", handler_);
      }
      if (this->event.type == YAML_SEQUENCE_START_EVENT) {
        this->parseSequence(buffer, handler_);
      } else if (this->event.type == YAML_MAPPING_START_EVENT) {
        this->parseMapping(buffer, handler_);
      } else {
        done = this->event.type == YAML_STREAM_END_EVENT;
        yaml_event_delete(&this->event);
      }
    }
    yaml_parser_delete(&this->parser);
    }}
    return buffer;
  }

  override function hasNext() -> Boolean {
    cpp{{
    bool repeat = false, eof = false;
    do {
      if (!yaml_parser_parse(&this->parser, &this->event)) {
        error("parse error", handler_);
      }
      switch (this->event.type) {
        case YAML_SCALAR_EVENT:
        case YAML_SEQUENCE_START_EVENT:
        case YAML_MAPPING_START_EVENT:
          break;
        case YAML_STREAM_END_EVENT:
          eof = true;
          break;
        default:
          yaml_event_delete(&this->event);
          repeat = true;
          break;
      }
    } while (repeat);
    return !eof;
    }}
  }

  override function next() -> Buffer {
    buffer:Buffer;
    cpp{{
    switch (this->event.type) {
      case YAML_SCALAR_EVENT:
        this->parseValue(buffer, handler_);
        break;
      case YAML_SEQUENCE_START_EVENT:
        this->parseSequence(buffer, handler_);
        break;
      case YAML_MAPPING_START_EVENT:
        this->parseMapping(buffer, handler_);
        break;
      default:
        /* hasNext() should have dealt with all other events */
        assert(false);
    }
    }}
    return buffer;
  }

  override function close() {
    fclose(file);
  }
  
  function parseMapping(buffer:Buffer) {
    cpp{{
    yaml_event_delete(&this->event);
    int done = 0;
    while (!done) {
      /* read one name/value pair on each iteration */
      if (!yaml_parser_parse(&this->parser, &this->event)) {
        error("parse error", handler_);
      }
      if (this->event.type == YAML_SCALAR_EVENT) {
        /* key */
        char* data = (char*)this->event.data.scalar.value;
        size_t length = this->event.data.scalar.length;
        std::string key(data, length);
        yaml_event_delete(&this->event);
        
        /* value */
        if (!yaml_parser_parse(&this->parser, &this->event)) {
          error("parse error", handler_);
        }
        auto value = birch::Buffer(handler_);
        buffer->set(key, value, handler_);
        if (this->event.type == YAML_SCALAR_EVENT) {
          this->parseValue(value, handler_);
        } else if (this->event.type == YAML_SEQUENCE_START_EVENT) {
          this->parseSequence(value, handler_);
        } else if (this->event.type == YAML_MAPPING_START_EVENT) {
          this->parseMapping(value, handler_);
        } else {
          yaml_event_delete(&this->event);
        }
      } else {
        done = this->event.type == YAML_MAPPING_END_EVENT;
        yaml_event_delete(&this->event);
      }
    }
    }}
  }
  
  function parseSequence(buffer:Buffer) {
    cpp{{
    yaml_event_delete(&this->event);
    int done = 0;
    while (!done) {
      if (!yaml_parser_parse(&this->parser, &this->event)) {
        error("parse error", handler_);
      }
      if (this->event.type == YAML_SCALAR_EVENT) {
        this->parseElement(buffer, handler_);
      } else if (this->event.type == YAML_SEQUENCE_START_EVENT) {
        auto element = birch::Buffer(handler_);
        buffer->push(element, handler_);
        this->parseSequence(element, handler_);
      } else if (this->event.type == YAML_MAPPING_START_EVENT) {
        auto element = birch::Buffer(handler_);
        buffer->push(element, handler_);
        this->parseMapping(element, handler_);
      } else {
        done = this->event.type == YAML_SEQUENCE_END_EVENT;
        yaml_event_delete(&this->event);
      }
    }
    }}
  }
  
  function parseValue(buffer:Buffer) {
    cpp{{
    auto data = (char*)this->event.data.scalar.value;
    auto length = this->event.data.scalar.length;
    auto endptr = data;
    auto intValue = int64_t(std::strtoll(data, &endptr, 10));
    if (endptr == data + length) {
      buffer->set(intValue, handler_);
    } else {
      auto realValue = std::strtod(data, &endptr);
      if (endptr == data + length) {
        buffer->set(realValue, handler_);
      } else if (std::strcmp(data, "true") == 0) {
        buffer->set(true, handler_);
      } else if (std::strcmp(data, "false") == 0) {
        buffer->set(false, handler_);
      } else if (std::strcmp(data, "null") == 0) {
        buffer->setNil(handler_);
      } else if (std::strcmp(data, "Infinity") == 0) {
        buffer->set(std::numeric_limits<Real>::infinity(), handler_);
      } else if (std::strcmp(data, "-Infinity") == 0) {
        buffer->set(-std::numeric_limits<Real>::infinity(), handler_);
      } else if (std::strcmp(data, "NaN") == 0) {
        buffer->set(std::numeric_limits<Real>::quiet_NaN(), handler_);
      } else {
        buffer->set(std::string(data, length), handler_);
      }
    }
    yaml_event_delete(&this->event);
    }}
  }

  function parseElement(buffer:Buffer) {
    cpp{{
    auto data = (char*)this->event.data.scalar.value;
    auto length = this->event.data.scalar.length;
    auto endptr = data;
    auto intValue = int64_t(std::strtoll(data, &endptr, 10));
    if (endptr == data + length) {
      buffer->push(intValue, handler_);
    } else {
      auto realValue = std::strtod(data, &endptr);
      if (endptr == data + length) {
        buffer->push(realValue, handler_);
      } else if (std::strcmp(data, "true") == 0) {
        buffer->push(true, handler_);
      } else if (std::strcmp(data, "false") == 0) {
        buffer->push(false, handler_);
      } else if (std::strcmp(data, "null") == 0) {
        buffer->pushNil(handler_);
      } else if (std::strcmp(data, "Infinity") == 0) {
        buffer->push(std::numeric_limits<Real>::infinity(), handler_);
      } else if (std::strcmp(data, "-Infinity") == 0) {
        buffer->push(-std::numeric_limits<Real>::infinity(), handler_);
      } else if (std::strcmp(data, "NaN") == 0) {
        buffer->push(std::numeric_limits<Real>::quiet_NaN(), handler_);
      } else {
        buffer->push(std::string(data, length), handler_);
      }
    }
    yaml_event_delete(&this->event);
    }}
  }
}
