/**
 * Conditional particle filter.
 *
 * ```mermaid
 * classDiagram
 *    ParticleFilter <|-- AliveParticleFilter
 *    ParticleFilter <|-- ConditionalParticleFilter
 *    link ParticleFilter "../ParticleFilter/"
 *    link AliveParticleFilter "../AliveParticleFilter/"
 *    link ConditionalParticleFilter "../ConditionalParticleFilter/"
 * ```
 */
class ConditionalParticleFilter < ParticleFilter {
  /**
   * Trace of the reference particle. This will have no value for the first
   * iteration of the filter. Subsequent iterations will draw a particle from
   * the previous iteration to condition the new iteration, setting this
   * variable.
   */
  r:Tape<Record>?;

  override function simulate(input:Buffer) {
    parallel for n in 1..nparticles {
      let m <- x[n].m;
      let h <- x[n].h;
      if r? && n == b {
        h.input <- r!;
      }
      with h {
        m.read(input);
        m.simulate();
        w[n] <- w[n] + h.w;
      }
    }
  }

  override function simulate(t:Integer, input:Buffer) {
    parallel for n in 1..nparticles {
      let m <- x[n].m;
      let h <- x[n].h;
      if r? && n == b {
        h.input <- r!;
      }
      with h {
        m.read(t, input);
        m.simulate(t);
        w[n] <- w[n] + h.w;
      }
    }
  }


  override function resample(t:Integer) {
    if ess <= trigger*nparticles {
      if r? {
        (a, b) <- conditional_resample_multinomial(w, b);
      } else {
        a <- resample_multinomial(w);
      }
      w <- vector(0.0, nparticles);
      copy();
      collect();
    } else {
      /* normalize weights to sum to nparticles */
      w <- w - vector(lsum - log(Real(nparticles)), nparticles);
    }
  }
}
