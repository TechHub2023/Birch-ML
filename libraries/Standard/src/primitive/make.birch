hpp{{
namespace birch {
/**
 * Make a shared object.
 *
 * @tparam T Type.
 * @tparam Args Argument types.
 * 
 * @param args Arguments.
 *
 * @return If the type is constructible with the given arguments, then an
 * optional with a so-constructed value, otherwise an optional with no value.
 */
template<class T, class... Args, std::enable_if_t<
    libbirch::is_pointer<T>::value &&
    std::is_constructible<typename T::value_type,Args...>::value,int> = 0>
std::optional<T> make_optional(Args&&... args) {
  return T(std::forward<Args>(args)...);
}

/**
 * Make a shared object.
 *
 * @tparam T Type.
 * @tparam Args Argument types.
 * 
 * @param args Arguments.
 *
 * @return If the type is constructible with the given arguments, then an
 * optional with a so-constructed value, otherwise an optional with no value.
 */
template<class T, class... Args, std::enable_if_t<
    libbirch::is_pointer<T>::value &&
    !std::is_constructible<typename T::value_type,Args...>::value,int> = 0>
std::optional<T> make_optional(Args&&... args) {
  return std::nullopt;
}

/**
 * Make an inplace object.
 *
 * @tparam T Type.
 * @tparam Args Argument types.
 * 
 * @param args Arguments.
 *
 * @return If the type is constructible with the given arguments, then an
 * optional with a so-constructed value, otherwise an optional with no value.
 */
template<class T, class... Args, std::enable_if_t<
    libbirch::is_inplace<T>::value &&
    std::is_constructible<typename T::value_type,Args...>::value,int> = 0>
std::optional<T> make_optional(Args&&... args) {
  return T(std::forward<Args>(args)...);
}

/**
 * Make an inplace object.
 *
 * @tparam T Type.
 * @tparam Args Argument types.
 * 
 * @param args Arguments.
 *
 * @return If the type is constructible with the given arguments, then an
 * optional with a so-constructed value, otherwise an optional with no value.
 */
template<class T, class... Args, std::enable_if_t<
    libbirch::is_inplace<T>::value &&
    !std::is_constructible<typename T::value_type,Args...>::value,int> = 0>
std::optional<T> make_optional(Args&&... args) {
  return std::nullopt;
}

/**
 * Make a value or object.
 *
 * @tparam T Type.
 * @tparam Args Argument types.
 * 
 * @param args Arguments.
 *
 * @return If the type is constructible with the given arguments, then an
 * optional with a so-constructed value, otherwise an optional with no value.
 */
template<class T, class... Args, std::enable_if_t<
    !libbirch::is_pointer<T>::value &&
    !libbirch::is_inplace<T>::value &&
    std::is_constructible<T,Args...>::value,int> = 0>
std::optional<T> make_optional(Args&&... args) {
  return T(std::forward<Args>(args)...);
}

/**
 * Make a value or object.
 *
 * @tparam T Type.
 * @tparam Args Argument types.
 * 
 * @param args Arguments.
 *
 * @return If the type is constructible with the given arguments, then an
 * optional with a so-constructed value, otherwise an optional with no value.
 */
template<class T, class... Args, std::enable_if_t<
    !libbirch::is_pointer<T>::value &&
    !libbirch::is_inplace<T>::value &&
    !std::is_constructible<T,Args...>::value,int> = 0>
std::optional<T> make_optional(Args&&... args) {
  return std::nullopt;
}

}
}}

/**
 * Make an object, with the type given as an argument.
 *
 *   - Type: The type.
 *
 * Returns: An optional with a value if successful, or no value if not
 * successful.
 *
 * The make will not succeed if the type is a class with initialization
 * parameters, or a compound type that includes such a class.
 */
function make<Type>() -> Type? {
  return make_optional<Type>();
}

/**
 * Make an object, with the class given as a string.
 *
 *   - Type: Base type, which may be Object.
 *   - name: Name of the class.
 *
 * Returns: An optional with a value if successful, or no value if not
 * successful.
 *
 * The make will not succeed if the class has initialization parameters.
 */
function make<Type>(name:String) -> Type? {
  result:Object?;
  symbol:String <- "make_" + name + "_";
  cpp{{
  using make_t = Object_*();
  void* addr = dlsym(RTLD_DEFAULT, symbol.c_str());
  if (addr) {
    result = Object(reinterpret_cast<make_t*>(addr)());
  }
  }}
  return Type?(result);
}

/**
 * Make an object, with the class given in a buffer.
 *
 *   - buffer: The buffer.
 *
 * Returns: An optional with a value if successful, or no value if not
 * successful.
 *
 * If the buffer contains a key `class`, an object of that class is 
 * constructed. The buffer is then passed to the `read()` function of the new
 * object.
 *
 * The make will not succeed if the class has initialization parameters.
 */
function make(buffer:Buffer) -> Object? {
  result:Object?;
  let className <- buffer.get<String>("class");
  if className? {
    result <- make<Object>(className!);
  }
  if result? {
    result!.read(buffer);
  }
  return result;
}

/**
 * Make an object, with the class given in a buffer, otherwise by a generic
 * type.
 *
 * - Type: Class if not given in buffer.
 *
 * - buffer: The buffer.
 *
 * Returns: An optional with a value if successful, or no value if not
 * successful.
 *
 * If the buffer contains a key `class`, an object of that class is 
 * constructed. Otherwise, an object of class `Type` is constructed, if
 * possible. The buffer is then passed to the `read()` function of the new
 * object.
 *
 * The make will not succeed if the class has initialization parameters.
 */
function make<Type>(buffer:Buffer) -> Type? {
  result:Type?;
  let className <- buffer.get<String>("class");
  if className? {
    result <- make<Type>(className!);
  } else {
    result <- make<Type>();
  }
  if result? {
    result!.read(buffer);
  }
  return result;
}
