/*
 * Take the exponential of a value, where NaN is treated as though `-inf`.
 */
function nan_exp(x:Real) -> Real {
  if isnan(x) {
    return 0.0;
  } else {
    return exp(x);
  }
}

/*
 * Return the minimum and maximum of two tuples with respect to their
 * first element.
 */
function minmax_by_first(x:(Real, Real), y:(Real, Real)) -> ((Real, Real), (Real, Real)) {
  let (x1, x2) <- x;
  let (y1, y2) <- y;
  if x1 > y1 {
    return (y, x);
  } else {
    return (x, y);
  }
}

/*
 * Return the minimum and maximum of two tuples with respect to their
 * first element.
 */
function minmax_by_first(x:(Real, Real, Real), y:(Real, Real, Real)) -> ((Real, Real, Real), (Real, Real, Real)) {
  let (x1, x2, x3) <- x;
  let (y1, y2, y3) <- y;
  if x1 > y1 {
    return (y, x);
  } else {
    return (x, y);
  }
}

/*
 * Take the maximum of two values, where NaN are treated as though `-inf`.
 */
function nan_max(x:Real, y:Real) -> Real {
  if isnan(x) && isnan(y) {
    return -inf;
  } else if isnan(x) {
    return y;
  } else if isnan(y) {
    return x;
  } else {
    return max(x, y);
  }
}

/*
 * Find the maximum of a log weight vector, where NaN are treated as though
 * `-inf`.
 */
function nan_max(w:Real[_]) -> Real {
  return reduce(w, -inf, \(x:Real, y:Real) -> { return nan_max(x, y); });
}

/*
 * Exponentiate and sum a log weight vector.
 *
 * The result is computed in a numerically stable way that avoids
 * intermediate over- and underflow, using a single pass over the data.
 *
 * @param w Log weights.
 *
 * @return the logarithm of the sum.
 *
 * !!! note
 *     NaN log weights are treated as though `-inf`.
 */
function log_sum_exp(w:Real[_]) -> Real {
  if length(w) > 0 {
    let (mx, r) <- transform_reduce(w, (-inf, 0.0),
        \(x:(Real, Real), y:(Real, Real)) -> {
          let (xymin, xymax) <- minmax_by_first(x, y);
          let (xymin1, xymin2) <- xymin;
          let (xymax1, xymax2) <- xymax;
          return (xymax1, xymax2 + (xymin2 + 1.0)*nan_exp(xymin1 - xymax1));
        },
        \(x:Real) -> {
          if isnan(x) {
            return (-inf, 0.0);
          } else {
            return (x, 0.0);
          }
        });
    return mx + log1p(r);
  } else {
    return -inf;
  }
}

/*
 * Convert a log weight vector into a normalized weight vector.
 *
 * @param w Log weights.
 *
 * @return normalized weights.
 *
 * !!! note
 *     NaN log weights are treated as though `-inf`.
 */
function norm_exp(w:Real[_]) -> Real[_] {
  if length(w) == 0 {
    return w;
  } else {
    let W <- log_sum_exp(w);
    return transform(w, \(x:Real) -> { return nan_exp(x - W); });
  }
}

/*
 * Resample with systematic resampling.
 *
 * @param w Log weights.
 *
 * @return the vector of ancestor indices (permuted) and vector of offspring
 * counts.
 *
 * See also: permute_ancestors()
 *
 * !!! note
 *     NaN log weights are treated as though `-inf`.
 */
function resample_systematic(w:Real[_]) -> (Integer[_], Integer[_]) {
  let O <- systematic_cumulative_offspring(cumulative_weights(w));
  let a <- permute_ancestors(cumulative_offspring_to_ancestors(O));
  let o <- cumulative_offspring_to_offspring(O);
  return (a, o);
}

/*
 * Resample with multinomial resampling.
 *
 * @param w Log weights.
 *
 * @return the vector of ancestor indices, in non-descending order.
 *
 * !!! note
 *     NaN log weights are treated as though `-inf`.
 */
function resample_multinomial(w:Real[_]) -> Integer[_] {
  return offspring_to_ancestors(simulate_multinomial(length(w),
      norm_exp(w)));
}

/*
 * Sample a single ancestor for a cumulative weight vector.
 *
 * @param W Cumulative weight vector.
 *
 * @return an ancestor index, or zero on failure (e.g. weights are zero).
 *
 * !!! note
 *     NaN log weights are treated as though `-inf`.
 */
function cumulative_ancestor(W:Real[_]) -> Integer {
  let n <- 0;
  let N <- length(W);
  if N > 0 && W[N] > 0.0 {
    /* binary search for uniform random variate */
    let u <- simulate_uniform(0.0, W[N]);
    let l <- 0;
    let r <- N;
    while l < r {
      n <- (l + r)/2;
      if W[n + 1] < u {
        l <- n + 1;
      } else {
        r <- n;
      }
    }
    n <- l + 1;
  }
  assert n <= N;
  return n;
}

/*
 * Sample a single ancestor for a log weight vector.
 *
 * @param w Log weight vector.
 *
 * @return an ancestor index, or zero on failure (e.g. weights are zero).
 *
 * !!! note
 *     NaN log weights are treated as though `-inf`.
 */
function ancestor(w:Real[_]) -> Integer {
  return cumulative_ancestor(cumulative_weights(w));
}

/*
 * Systematic resampling.
 */
function systematic_cumulative_offspring(W:Real[_]) -> Integer[_] {
  let N <- length(W);
  O:Integer[N];
  let u <- simulate_uniform(0.0, 1.0);
  for n in 1..N {
    let r <- N*W[n]/W[N];
    O[n] <- min(N, cast<Integer>(r + u));
  }
  return O;
}

/*
 * Convert an offspring vector into an ancestry vector.
 */
function offspring_to_ancestors(o:Integer[_]) -> Integer[_] {
  let N <- length(o);
  let i <- 1;
  a:Integer[N];
  for n in 1..N {
    for j in 1..o[n] {
      a[i] <- n;
      i <- i + 1;
    }
  }
  assert i == N + 1;
  assert is_sorted(a);
  return a;
}

/*
 * Convert a cumulative offspring vector into an ancestry vector.
 */
function cumulative_offspring_to_ancestors(O:Integer[_]) -> Integer[_] {
  let N <- length(O);
  a:Integer[N];
  for n in 1..N {
    let start <- 0;
    if n > 1 {
      start <- O[n - 1];
    }
    let o <- O[n] - start;
    for j in 1..o {
      a[start + j] <- n;
    }
  }
  assert is_sorted(a);
  return a;
}

/*
 * Convert a cumulative offspring vector into an offspring vector.
 */
function cumulative_offspring_to_offspring(O:Integer[_]) -> Integer[_] {
  return adjacent_difference(O, \(x:Integer, y:Integer) -> Integer {
        return x - y;
      });
}

/*
 * Permute an ancestry vector to ensure that, when a particle survives, at
 * least one of its instances remains in the same place.
 */
function permute_ancestors(a:Integer[_]) -> Integer[_] {
  let N <- length(a);
  let b <- a;
  let n <- 1;
  while n <= N {
    let c <- b[n];
    if c != n && b[c] != c {
      b[n] <- b[c];
      b[c] <- c;
    } else {
      n <- n + 1;
    }
  }
  return b;
}

/*
 * Compute the cumulative weight vector from the log-weight vector.
 */
function cumulative_weights(w:Real[_]) -> Real[_] {
  let N <- length(w);
  W:Real[N];
  if N > 0 {
    let mx <- nan_max(w);
    W[1] <- nan_exp(w[1] - mx);
    for n in 2..N {
      W[n] <- W[n - 1] + nan_exp(w[n] - mx);
    }
  }
  return W;
}

/*
 * Compute the effective sample size (ESS) and logarithm of the average
 * weight, given a log-weight vector.
 *
 * @return A pair, the first element of which gives the ESS, the second
 * element of which gives the logarithm of the sum of weights.
 *
 * !!! note
 *     NaN log weights are treated as though `-inf`.
 */
function resample_reduce(w:Real[_]) -> (Real, Real) {
  if length(w) == 0 {
    return (0.0, 0.0);
  } else {
    let (mx, r, q) <- transform_reduce(w, (-inf, 0.0, 0.0),
        \(x:(Real, Real, Real), y:(Real, Real, Real)) -> {
          let (xymin, xymax) <- minmax_by_first(x, y);
          let (xymin1, xymin2, xymin3) <- xymin;
          let (xymax1, xymax2, xymax3) <- xymax;
          let v <- nan_exp(xymin1 - xymax1);
          return (xymax1, xymax2 + (xymin2 + 1.0)*v, xymax3 + (xymin3 + 1.0)*v*v);
        },
        \(x:Real) -> {
          if isnan(x) {
            return (-inf, 0.0, 0.0);
          } else {
            return (x, 0.0, 0.0);
          }
        });
    let rp1 <- r + 1.0;
    let ess <- rp1*rp1/(q + 1.0);
    let log_sum_weights <- mx + log1p(r);
    return (ess, log_sum_weights);
  }
}
