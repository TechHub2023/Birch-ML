/**
 * Resample with systematic resampling.
 *
 * - w: Log weights.
 *
 * Return: the vector of ancestor indices, in non-descending order.
 *
 *
 */
function resample_systematic(w:Real[_]) -> Integer[_] {
  return cumulative_offspring_to_ancestors(
      systematic_cumulative_offspring(cumulative_weights(w)));
}

/**
 * Resample with multinomial resampling.
 *
 * - w: Log weights.
 *
 * Return: the vector of ancestor indices, in non-descending order.
 */
function resample_multinomial(w:Real[_]) -> Integer[_] {
  return offspring_to_ancestors(simulate_multinomial(length(w),
      norm_exp(w)));
}

/**
 * Exponentiate and sum a vector, return the logarithm of the sum.
 *
 * The result is computed in a numerically stable way that avoids
 * intermediate over- and underflow, using a single pass over the data.
 *
 * Reference: [Sebastian Nowozin: Streaming Log-sum-exp Computation](http://www.nowozin.net/sebastian/blog/streaming-log-sum-exp-computation.html)
 */
function log_sum_exp(x:Real[_]) -> Real {
  if length(x) > 0 {
    let (mx, r) <- transform_reduce(x, (-inf, 0.0),
        \(x:(Real, Real), y:(Real, Real)) -> {
          let (xa, xb) <- x;
          let (ya, yb) <- y;
          if xa > ya {
            return (xa, xb + (yb + 1.0)*nan_exp(ya - xa));
          } else {
            return (ya, yb + (xb + 1.0)*nan_exp(xa - ya));
          }
        },
        \(x:Real) -> {
          return (x, 0.0);
        });
    return mx + log1p(r);
  } else {
    return -inf;
  }
}

/**
 * Take the logarithm of each element of a vector and return the sum.
 */
function log_sum(x:Real[_]) -> Real {
  return transform_reduce(x, 0.0, \(x:Real, y:Real) -> { return x + y; },
      \(x:Real) -> { return log(x); });
}

/**
 * Take the exponential of a value, where `nan` is treated as `-inf`.
 */
function nan_exp(x:Real) -> Real {
  if isnan(x) {
    return 0.0;
  } else {
    return exp(x);
  }
}


/**
 * Take the exponential of each element of a vector and normalize to sum to
 * one.
 */
function norm_exp(x:Real[_]) -> Real[_] {
  if length(x) == 0 {
    return x;
  } else {
    let W <- log_sum_exp(x);
    return transform(x, \(x:Real) -> { return nan_exp(x - W); });
  }
}

/**
 * Sample a single ancestor for a cumulative weight vector.
 */
function cumulative_ancestor(W:Real[_]) -> Integer {
  let N <- length(W);
  if N > 0 {
    assert W[N] > 0.0;
    let u <- simulate_uniform(0.0, W[N]);
    let n <- 1;
    while W[n] < u {
      n <- n + 1;
    }
    return n;
  } else {
    return 0;
  }
}

/**
 * Sample a single ancestor for a log-weight vector. If the sum of
 * weights is zero, returns zero.
 */
function ancestor(w:Real[_]) -> Integer {
  let N <- length(w);
  let W <- cumulative_weights(w);
  if W[N] > 0.0 {
    return cumulative_ancestor(W);
  } else {
    return 0;
  }
}

/**
 * Systematic resampling.
 */
function systematic_cumulative_offspring(W:Real[_]) -> Integer[_] {
  let N <- length(W);
  O:Integer[N];
  let u <- simulate_uniform(0.0, 1.0);
  for n in 1..N {
    let r <- N*W[n]/W[N];
    O[n] <- min(N, scalar<Integer>(floor(r + u)));
  }
  return O;
}

/**
 * Convert an offspring vector into an ancestry vector.
 */
function offspring_to_ancestors(o:Integer[_]) -> Integer[_] {
  let N <- length(o);
  let i <- 1;
  a:Integer[N];
  for n in 1..N {
    for j in 1..o[n] {
      a[i] <- n;
      i <- i + 1;
    }
  }
  assert i == N + 1;
  assert is_sorted(a);
  return a;
}

/**
 * Convert a cumulative offspring vector into an ancestry vector.
 */
function cumulative_offspring_to_ancestors(O:Integer[_]) -> Integer[_] {
  let N <- length(O);
  a:Integer[N];
  for n in 1..N {
    let start <- 0;
    if n > 1 {
      start <- O[n - 1];
    }
    let o <- O[n] - start;
    for j in 1..o {
      a[start + j] <- n;
    }
  }
  assert is_sorted(a);
  return a;
}

/**
 * Convert a cumulative offspring vector into an offspring vector.
 */
function cumulative_offspring_to_offspring(O:Integer[_]) -> Integer[_] {
  return adjacent_difference(O, \(x:Integer, y:Integer) -> Integer {
        return x - y;
      });
}

/**
 * Permute an ancestry vector to ensure that, when a particle survives, at
 * least one of its instances remains in the same place.
 */
function permute_ancestors(a:Integer[_]) -> Integer[_] {
  let N <- length(a);
  let b <- a;
  let n <- 1;
  while n <= N {
    let c <- b[n];
    if c != n && b[c] != c {
      b[n] <- b[c];
      b[c] <- c;
    } else {
      n <- n + 1;
    }
  }
  return b;
}

/**
 * Compute the cumulative weight vector from the log-weight vector.
 */
function cumulative_weights(w:Real[_]) -> Real[_] {
  let N <- length(w);
  W:Real[N];
  if N > 0 {
    let mx <- max(w);
    W[1] <- nan_exp(w[1] - mx);
    for n in 2..N {
      W[n] <- W[n - 1] + nan_exp(w[n] - mx);
    }
  }
  return W;
}

/**
 * Compute the effective sample size (ESS) and logarithm of the average
 * weight, given a log-weight vector.
 *
 * Returns: A pair, the first element of which gives the ESS, the second
 * element of which gives the logarithm of the sum of weights.
 */
function resample_reduce(w:Real[_]) -> (Real, Real) {
  if length(w) == 0 {
    return (0.0, 0.0);
  } else {
    let (mw, r, rsq) <- transform_reduce(w, (-inf, 0.0, 0.0),
        \(x:(Real, Real, Real), y:(Real, Real, Real)) -> {
          let (xa, xb, xc) <- x;
          let (ya, yb, yc) <- y;
          v:Real;
          if xa > ya {
            v <- nan_exp(ya - xa);
            return (xa, xb + (yb + 1.0)*v, xc + (yc + 1.0)*v*v);
          } else {
            v <- nan_exp(xa - ya);
            return (ya, yb + (xb + 1.0)*v, yc + (xc + 1.0)*v*v);
          }
        },
        \(x:Real) -> {
          return (x, 0.0, 0.0);
        });
    let rp1 <- r + 1.0;
    let ess <- rp1*rp1/(rsq + 1.0);
    let log_sum_weights <- mw + log1p(r);
    return (ess, log_sum_weights);
  }
}
