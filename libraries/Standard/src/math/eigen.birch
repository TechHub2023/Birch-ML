/*
 * Birch uses the Eigen library <https://eigen.tuxfamily.org> for linear
 * algebra support. Eigen is tightly integrated with support from libbirch,
 * in order to preserve the lazy evaluation of Eigen that is a critical
 * feature of its performance. This file contains only declarations,
 * implementations are in libbirch/EigenOperators.hpp and
 * libbirch/EigenFunctions.hpp.
 */

operator<Type> (x:Type*y:Type[_]) -> Type[_] {
  cpp{{
  return y.toEigen().operator*(x);
  }}
}

operator<Type> (x:Type[_]*y:Type) -> Type[_] {
  cpp{{
  return x.toEigen().operator*(y);
  }}
}

operator<Type> (x:Type*Y:Type[_,_]) -> Type[_,_] {
  cpp{{
  return Y.toEigen().operator*(x);
  }}
}

operator<Type> (X:Type[_,_]*y:Type) -> Type[_,_] {
  cpp{{
  return X.toEigen().operator*(y);
  }}
}

operator<Type> (x:Type[_]/y:Type) -> Type[_] {
  cpp{{
  return x.toEigen().operator/(y);
  }}
}

operator<Type> (X:Type[_,_]/y:Type) -> Type[_,_] {
  cpp{{
  return X.toEigen().operator/(y);
  }}
}

operator<Type> (x:Type[_] == y:Type[_]) -> Boolean {
  cpp{{
  return x.toEigen().operator==(y.toEigen());
  }}
}

operator<Type> (x:Type[_] != y:Type[_]) -> Boolean {
  cpp{{
  return x.toEigen().operator!=(y.toEigen());
  }}
}

operator<Type> (X:Type[_,_] == Y:Type[_,_]) -> Boolean {
  cpp{{
  return X.toEigen().operator==(Y.toEigen());
  }}
}

operator<Type> (X:Type[_,_] != Y:Type[_,_]) -> Boolean {
  cpp{{
  return X.toEigen().operator!=(Y.toEigen());
  }}
}

operator<Type> (-x:Type[_]) -> Type[_] {
  cpp{{
  return x.toEigen().operator-();
  }}
}

operator<Type> (+x:Type[_]) -> Type[_] {
  return x;
}

operator<Type> (-X:Type[_,_]) -> Type[_,_] {
  cpp{{
  return X.toEigen().operator-();
  }}
}

operator<Type> (+X:Type[_,_]) -> Type[_,_] {
  return X;
}

operator<Type> (x:Type[_] + y:Type[_]) -> Type[_] {
  cpp{{
  return x.toEigen().operator+(y.toEigen());
  }}
}

operator<Type> (x:Type[_] - y:Type[_]) -> Type[_] {
  cpp{{
  return x.toEigen().operator-(y.toEigen());
  }}
}

operator<Type> (X:Type[_,_] + Y:Type[_,_]) -> Type[_,_] {
  cpp{{
  return X.toEigen().operator+(Y.toEigen());
  }}
}

operator (X:LLT + Y:LLT) -> LLT {  // for gradient accumulation in Random
  cpp{{
  return X.reconstructedMatrix().operator+(Y.reconstructedMatrix()).llt();
  }}
}

operator<Type> (X:Type[_,_] - Y:Type[_,_]) -> Type[_,_] {
  cpp{{
  return X.toEigen().operator-(Y.toEigen());
  }}
}

operator<Type> (X:Type[_,_]*y:Type[_]) -> Type[_] {
  cpp{{
  return X.toEigen().operator*(y.toEigen());
  }}
}

operator<Type> (X:Type[_]*y:Type[_,_]) -> Type[_,_] {
  cpp{{
  return X.toEigen().operator*(y.toEigen());
  }}
}

operator<Type> (X:Type[_,_]*Y:Type[_,_]) -> Type[_,_] {
  cpp{{
  return X.toEigen().operator*(Y.toEigen());
  }}
}

operator (X:LLT == Y:LLT) -> Boolean {
  cpp{{
  return X.reconstructedMatrix().operator==(Y.reconstructedMatrix());
  }}
}

operator (X:LLT != Y:LLT) -> Boolean {
  cpp{{
  return X.reconstructedMatrix().operator!=(Y.reconstructedMatrix());
  }}
}

/**
 * Dot product of vector with itself.
 */
function dot<Type>(x:Type[_]) -> Type {
  cpp{{
  return x.toEigen().squaredNorm();
  }}
}

/**
 * Dot product of vector with another.
 */
function dot<Type>(x:Type[_], y:Type[_]) -> Type {
  cpp{{
  return x.toEigen().dot(y.toEigen());
  }}
}

/**
 * Dot product of vector with columns of a matrix. The expression `dot(x, Y)`
 * is equivalent to `transpose(Y)*x`.
 */
function dot<Type>(x:Type[_], Y:Type[_,_]) -> Type[_] {
  cpp{{
  return Y.toEigen().transpose().operator*(x.toEigen());
  }}
}

/**
 * Outer product of a vector with itself.
 */
function outer<Type>(x:Type[_]) -> Type[_,_] {
  cpp{{
  auto y = x.toEigen();
  return y.operator*(y.transpose());
  }}
}

/**
 * Outer product of a vector with another.
 */
function outer<Type>(x:Type[_], y:Type[_]) -> Type[_,_] {
  cpp{{
  return x.toEigen().operator*(y.toEigen().transpose());
  }}
}

/**
 * Outer product of a matrix with itself.
 */
function outer<Type>(X:Type[_,_]) -> Type[_,_] {
  cpp{{
  auto Y = X.toEigen();
  return Y.operator*(Y.transpose());
  }}
}

/**
 * Outer product of a matrix with another.
 */
function outer<Type>(X:Type[_,_], Y:Type[_,_]) -> Type[_,_] {
  cpp{{
  return X.toEigen().operator*(Y.toEigen().transpose());
  }}
}

/**
 * Norm of a vector.
 */
function norm<Type>(x:Type[_]) -> Type {
  cpp{{
  return x.toEigen().norm();
  }}
}

/**
 * Element-wise square root of a vector.
 */
function sqrt<Type>(x:Type[_]) -> Type[_] {
  cpp{{
  return x.toEigen().array().sqrt().matrix();
  }}
}

/**
 * Transpose of a matrix.
 */
function transpose<Type>(X:Type[_,_]) -> Type[_,_] {
  cpp{{
  return X.toEigen().transpose();
  }}
}

/**
 * Transpose of a symmetric positive definite matrix.
 */
function transpose(S:LLT) -> LLT {
  return S;
}

/**
 * Transpose of a column vector into a row vector.
 */
function transpose<Type>(x:Type[_]) -> Type[_,_] {
  cpp{{
  return x.toEigen().transpose();
  }}
}

/**
 * Diagonal matrix from vector.
 */
function diagonal<Type>(x:Type[_]) -> Type[_,_] {
  cpp{{
  return x.toEigen().asDiagonal();
  }}
}

/**
 * Diagonal of a matrix, as a vector.
 */
function diagonal<Type>(X:Type[_,_]) -> Type[_] {
  cpp{{
  return X.toEigen().diagonal();
  }}
}

/**
 * Trace of a matrix.
 */
function trace<Type>(X:Type[_,_]) -> Type {
  cpp{{
  return X.toEigen().trace();
  }}
}

/**
 * Trace of a symmetric positive-definite matrix.
 */
function trace(S:LLT) -> Real {
  cpp{{
  return S.reconstructedMatrix().trace();
  }}
}

/**
 * Determinant of a matrix.
 */
function det<Type>(X:Type[_,_]) -> Type {
  cpp{{
  return X.toEigen().determinant();
  }}
}

/**
 * Log-determinant of a matrix.
 */
function ldet<Type>(X:Type[_,_]) -> Type {
  cpp{{
  return X.toEigen().householderQr().logAbsDeterminant();
  }}
}

/**
 * Determinant of a symmetric positive-definite matrix.
 */
function det(S:LLT) -> Real {
  cpp{{
  auto d = S.matrixL().determinant();
  return d*d;
  }}
}

/**
 * Log-determinant of a symmetric positive-definite matrix.
 */
function ldet(S:LLT) -> Real {
  cpp{{
  return 2.0*S.matrixL().nestedExpression().diagonal().array().log().sum();
  }}
}

/**
 * Inverse of a matrix.
 */
function inv<Type>(X:Type[_,_]) -> Type[_,_] {
  cpp{{
  return X.toEigen().inverse();
  }}
}

/**
 * Inverse of a symmetric positive definite matrix.
 */
function inv(S:LLT) -> LLT {
  cpp{{
  return S.solve(libbirch::EigenMatrix<birch::type::Real>::Identity(
      S.rows(), S.cols())).llt();
  }}
}

/**
 * Solve a system of equations.
 */
function solve<Type>(X:Type[_,_], y:Type[_]) -> Type[_] {
  cpp{{
  return X.toEigen().householderQr().solve(y.toEigen()).eval();
  }}
}

/**
 * Solve a system of equations with a symmetric positive definite matrix.
 */
function solve(S:LLT, y:Real[_]) -> Real[_] {
  cpp{{
  return S.solve(y.toEigen()).eval();
  }}
}

/**
 * Solve a system of equations.
 */
function solve<Type>(X:Type[_,_], Y:Type[_,_]) -> Type[_,_] {
  cpp{{
  return X.toEigen().householderQr().solve(Y.toEigen()).eval();
  }}
}

/**
 * Solve a system of equations with a symmetric positive definite matrix.
 */
function solve(S:LLT, Y:Real[_,_]) -> Real[_,_] {
  cpp{{
  return S.solve(Y.toEigen()).eval();
  }}
}

/**
 * Cholesky factor of a symmetric positive definite matrix, $S = LL^{\top}$.
 *
 * Returns: the lower-triangular factor $L$.
 */
function cholesky(S:LLT) -> Real[_,_] {
  cpp{{
  return S.matrixL();
  }}
}

/**
 * Hadamard (element-wise) vector product.
 */
function hadamard<Type>(x:Type[_], y:Type[_]) -> Type[_] {
  cpp{{
  return x.toEigen().cwiseProduct(y.toEigen());
  }}
}

/**
 * Hadamard (element-wise) matrix product.
 */
function hadamard<Type>(X:Type[_,_], Y:Type[_,_]) -> Type[_,_] {
  cpp{{
  return X.toEigen().cwiseProduct(Y.toEigen());
  }}
}
