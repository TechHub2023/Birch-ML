/*
 * Birch uses the Eigen library <https://eigen.tuxfamily.org> for linear
 * algebra support. Eigen is tightly integrated with support from libbirch,
 * in order to preserve the lazy evaluation of Eigen that is a critical
 * feature of its performance. This file contains only declarations,
 * implementations are in libbirch/EigenOperators.hpp and
 * libbirch/EigenFunctions.hpp.
 */

operator<Type> (x:Type[_] == y:Type[_]) -> Boolean {
  cpp{{
  return x.toEigen().operator==(y.toEigen());
  }}
}

operator<Type> (x:Type[_] != y:Type[_]) -> Boolean {
  cpp{{
  return x.toEigen().operator!=(y.toEigen());
  }}
}

operator<Type> (X:Type[_,_] == Y:Type[_,_]) -> Boolean {
  cpp{{
  return X.toEigen().operator==(Y.toEigen());
  }}
}

operator<Type> (X:Type[_,_] != Y:Type[_,_]) -> Boolean {
  cpp{{
  return X.toEigen().operator!=(Y.toEigen());
  }}
}

operator<Type> (+x:Type[_]) -> Type[_] {
  return x;
}

operator<Type> (+X:Type[_,_]) -> Type[_,_] {
  return X;
}

/**
 * Cholesky factor of a symmetric positive definite matrix, $S = LL^{\top}$.
 *
 * Returns: the lower-triangular factor $L$.
 */
function cholesky(S:Real[_,_]) -> Real[_,_] {
  cpp{{
  return S.toEigen().llt().matrixL();
  }}
}

/**
 * Hadamard (element-wise) vector product.
 */
function hadamard<Type>(x:Type[_], y:Type[_]) -> Type[_] {
  cpp{{
  return x.toEigen().cwiseProduct(y.toEigen());
  }}
}

/**
 * Hadamard (element-wise) matrix product.
 */
function hadamard<Type>(X:Type[_,_], Y:Type[_,_]) -> Type[_,_] {
  cpp{{
  return X.toEigen().cwiseProduct(Y.toEigen());
  }}
}
