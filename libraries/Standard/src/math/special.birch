cpp{{
#include <boost/math/special_functions.hpp>
}}

/**
 * The gamma function.
 */
function gamma(x:Real64) -> Real64 {
  cpp {{
  return ::tgamma(x);
  }}
}

/**
 * The gamma function.
 */
function gamma(x:Real32) -> Real32 {
  cpp {{
  return ::tgammaf(x);
  }}
}

/**
 * Logarithm of the gamma function.
 */
function lgamma(x:Real64) -> Real64 {
  cpp {{
  return ::lgamma(x);
  }}
}

/**
 * Logarithm of the gamma function.
 */
function lgamma(x:Real32) -> Real32 {
  cpp {{
  return ::lgammaf(x);
  }}
}

/**
 * The multivariate gamma function.
 */
function gamma(x:Real64, p:Integer) -> Real64 {
  assert p > 0;
  let y <- 0.25*(p*(p - 1))*log(π);
  for i in 1..p {
    y <- y*gamma(x + 0.5*(1 - i));
  }
  return y;
}


function expm1(x:Real64) -> Real64 {
  cpp {{
    return ::expm1(x);
    }}
}

function expm1(x:Real32) -> Real32 {
  cpp {{
    return ::expm1f(x);
    }}
}


/**
 * The multivariate gamma function.
 */
function gamma(x:Real32, p:Integer) -> Real32 {
  assert p > 0;
  let y <- Real32(0.25)*Real32(p*(p - 1))*log(Real32(π));
  for i in 1..p {
    y <- y*gamma(x + Real32(0.5)*Real32(1 - i));
  }
  return y;
}

/**
 * Logarithm of the multivariate gamma function.
 */
function lgamma(x:Real64, p:Integer) -> Real64 {
  assert p > 0;
  let y <- 0.25*(p*(p - 1))*log(π);
  for i in 1..p {
    y <- y + lgamma(x + 0.5*(1 - i));
  }
  return y;
}

/**
 * Logarithm of the multivariate gamma function.
 */
function lgamma(x:Real32, p:Integer) -> Real32 {
  assert p > 0;
  let y <- Real32(0.25)*Real32(p*(p - 1))*log(Real32(π));
  for i in 1..p {
    y <- y + lgamma(x + Real32(0.5)*Real32(1 - i));
  }
  return y;
}

/**
 * The beta function.
 */
function beta(x:Real64, y:Real64) -> Real64 {
  return (gamma(x) * gamma(y)) / (gamma(x + y));
}

/**
 * The beta function.
 */
function beta(x:Real32, y:Real32) -> Real32 {
  return (gamma(x) * gamma(y)) / (gamma(x + y));
}



/**
 * The incomplete beta function.
 */
function ibeta(a:Real64, b:Real64, x:Real64) -> Real64 {
  if (x < 0.0 || x > 1.0) {
    return inf;
  }
  // whenever x < (a + 1) / (a + b + 2) -- CF converges
  if (x > ((a + 1.0)/(a + b + 2.0))) {
    return 1.0 - ibeta(b, a, 1.0 - x);
  }

  // stop represents the value when Lentz's algorithm has converged
  auto STOP <- 1.0e-8;

  // TINY is to represent a very small floating point number
  auto TINY <- 1.0e-30;

  auto lbeta_ab <- lgamma(a) + lgamma(b) - lgamma(a + b);
  auto front <- exp(log(x)*a + log(1.0 - x)*b - lbeta_ab) / a;

  // setup for Lentz's algorithm
  auto f <- 1.0;
  auto c <- 1.0;
  auto d <- 0.0;
  auto numerator <- 0.0;

  for i in 0..200 {
    auto m <- i/2;

    if (i == 0) {
      numerator <- 1.0;
    } else if (mod(i, 2) == 0) {
      numerator <- (m * (b - m)*x) / ((a + 2.0*m - 1.0) * (a + 2.0*m));
    } else {
      numerator <- -((a + m) * (a + b + m) * x)/((a + 2.0*m)*(a + 2.0*m + 1.0));
    }

    d <- 1.0 + numerator * d;
    if abs(d) < TINY {
      d <- TINY;
    }
    d <- 1.0 / d;

    c <- 1.0 + numerator / c;

    if abs(c) < TINY {
      c <- TINY;
    }

    auto cd <- c*d;

    // NOTE: Does *= work?
    f <- f * cd;

    if abs(1.0 - cd) < STOP {
      return front * (f - 1.0);
    }
  }

  return inf; // did not converge
}

/*
function ibeta<Value>(a:Value, b:Value, x:Value) -> Value {

}
*/

/**
 * The incomplete beta function.
 */
function ibeta(a:Real32, b:Real32, x:Real32) -> Real32 {
  // TODO: There's got to be a way to not rewrite the whole thing using upcasting or downcasting.
  // TODO(pranavs): Remember to cast literals to 32 bit.
  if x < Real32(0.0) || x > 1.0 {
    return Real32(inf); // inf has type Real64 so we can't return it
  }
  // whenever x < (a + 1) / (a + b + 2) -- CF converges
  if x > (a + 1.0)/(a + b + 2.0) {
    return Real32(1.0 - ibeta(b, a, 1.0 - x));
  }

  // stop represents the value when Lentz's algorithm has converged
  auto STOP <- 1.0e-8;

  // TINY is to represent a very small floating point number
  auto TINY <- 1.0e-30;

  auto lbeta_ab <- lgamma(a) + lgamma(b) - lgamma(a + b);
  auto front <- exp(log(x)*a + log(1.0 - x)*b - lbeta_ab) / a;

  // setup for Lentz's algorithm
  auto f <- 1.0;
  auto c <- 1.0;
  auto d <- 0.0;

  for i in 0..200 {
    auto m <- i/2;

    auto numerator <- 1.0;

    if i == 0 {
      numerator <- 1.0;
    } else if mod(i, 2) == 0{
      numerator <- (m * (b - m)*x) / ((a + 2.0*m - 1.0) * (a + 2.0*m));
    } else {
      numerator <- -((a + m) * (a + b + m) * x)/((a + 2.0*m)*(a + 2.0*m + 1.0));
    }

    d <- 1.0 + numerator * d;
    if abs(d) < TINY {
      d <- TINY;
    }
    d <- 1.0 / d;

    c <- 1.0 + numerator / d;

    if abs(c) < TINY {
      c <- TINY;
    }

    auto cd <- c*d;

    // NOTE: Does *= work?
    f <- f * cd;

    if abs(1.0 - cd) < STOP {
      return Real32(front * (f - 1.0));
    }
  }

  return Real32(inf); // did not converge

}

/**
 * Logarithm of the beta function.
 */
function lbeta(x:Real64, y:Real64) -> Real64 {
  return lgamma(x) + lgamma(y) - lgamma(x + y);
}

/**
 * Logarithm of the beta function.
 */
function lbeta(x:Real32, y:Real32) -> Real32 {
  return lgamma(x) + lgamma(y) - lgamma(x + y);
}

/**
 * The digamma function (derivative of `lgamma`).
 */
function digamma(x:Real64) -> Real64 {
  cpp {{
  return boost::math::digamma(x);
  }}
}

/**
 * The digamma function (derivative of `lgamma`).
 */
function digamma(x:Real32) -> Real32 {
  cpp {{
  return boost::math::digamma(x);
  }}
}

/**
 * The binomial coefficient.
 */
function choose(x:Integer, y:Integer) -> Real64 {
  assert 0 <= x;
  assert 0 <= y;
  assert x >= y;

  if (y == 0) {
    return 1.0;
  } else {
    // see Boost binomial_coefficient function for this implementation
    return 1.0/(Real(y)*beta(Real(y), Real(x - y + 1)));
  }
}

/**
 * The binomial coefficient.
 */
function choose(x:Real64, y:Real64) -> Real64 {
  assert 0.0 <= x;
  assert 0.0 <= y;
  assert x >= y;

  if (y == 0.0) {
    return 1.0;
  } else {
    // see Boost binomial_coefficient function for this implementation
    return 1.0/(y*beta(y, x - y + 1.0));
  }
}

/**
 * The binomial coefficient.
 */
function choose(x:Real32, y:Real32) -> Real32 {
  assert Real32(0.0) <= x;
  assert Real32(0.0) <= y;
  assert x >= y;

  if (y == Real32(0.0)) {
    return Real32(1.0);
  } else {
    // see Boost binomial_coefficient function for this implementation
    return Real32(1.0)/(y*beta(y, x - y + Real32(1.0)));
  }
}

/**
 * Logarithm of the binomial coefficient.
 */
function lchoose(x:Integer, y:Integer) -> Real64 {
  assert 0 <= x;
  assert 0 <= y;
  assert x >= y;

  if (y == 0) {
    return 0.0;
  } else {
    // see Boost binomial_coefficient function for this implementation
    return -log(Real(y)) - lbeta(Real(y), Real(x - y + 1));
  }
}

/**
 * Logarithm of the binomial coefficient.
 */
function lchoose(x:Real64, y:Real64) -> Real64 {
  assert 0.0 <= x;
  assert 0.0 <= y;
  assert x >= y;

  if (y == 0.0) {
    return 0.0;
  } else {
    // see Boost binomial_coefficient function for this implementation
    return -log(y) - lbeta(y, x - y + 1.0);
  }
}

/**
 * Logarithm of the binomial coefficient.
 */
function lchoose(x:Real32, y:Real32) -> Real32 {
  assert Real32(0.0) <= x;
  assert Real32(0.0) <= y;
  assert x >= y;

  if (y == Real32(0.0)) {
    return log(Real32(1.0));
  } else {
    // see Boost binomial_coefficient function for this implementation
    return -log(y) - lbeta(y, x - y + Real32(1.0));
  }
}


function lower_inc_gamma(a:Real64, x:Real64) -> Real64 {

  // this implementation is taken from https://github.com/scipy/scipy/blob/3af8448114dd4a2755d513edb5a2272a338dc483/scipy/special/cephes/igam.c

  assert x >= Real64(0.0);
  assert a >= Real64(0.0);

  absxma_a:Real64;

  if (a == 0.0) {
    return Real64(1.0);
    if (x > 0.0) {
      return 1.0;
    } else {
      return nan;
    }
  } else if (x == 0.0) {
    return Real64(0.0);
  } else if (isinf(a)) {
    if (isinf(x)) {
      return nan;
    }
    return 0.0;
  } else if (isinf(x)) {
    return 1.0;
  }

  absxma_a <- abs(x - a) / a;
  if ((a > SMALL) && (a < LARGE) && (absxma_a < SMALLRATIO)) {
    return asymptotic_series(a, x, 1);
  } else if ((a > LARGE) && (absxma_a < LARGERATIO / sqrt(a))) {
    return asymptotic_series(a, x, 1);
  }

  if ((x > Real64(1.0)) && (x > a)) {
    // stderr.print("Breaks upper_inc_gamma\n");
    return (Real64(1.0) - upper_inc_gamma(a, x));
  }

  return igam_series(a, x);
}


function upper_inc_gamma(a:Real64, x:Real64) -> Real64 {

  assert x >= Real64(0.0);
  assert a >= Real64(0.0);

  absxma_a:Real64;

  if (a == 0.0) {
    if (x > 0.0) {
      return 0.0;
    } else {
      return nan;
    }

  } else if (x == 0.0) {
    return 1.0;
    // is this the correct way to check Nan?
  } else if (isinf(a)) {
    if (isinf(x)) {
      return nan;
    }
    return 1.0;
  } else if (isinf(x)) {
    return 0.0;
  }

    /* Asymptotic regime where a ~ x; Maddock et. al., "Incomplete Gamma Functions", https://www.boost.org/doc/libs/1_61_0/libs/math/doc/html/math_toolkit/sf_gamma/igamma.html */



  absxma_a <- abs(x - a) / a;

  if ((a > SMALL) && (a < LARGE) && (absxma_a < SMALLRATIO)) {
    // the last parameter is a boolean term whether it's LINVGAM or UPPINVGAM
    return asymptotic_series(a, x, 0);
  } else if ((a > LARGE) && (absxma_a < LARGERATIO / sqrt(a))) {
    return asymptotic_series(a, x, 0);
  }

  if (x > 1.1) {
    if (x < a) {
      return 1.0 - igam_series(a, x);
    } else {
      return igamc_continued_fraction(a, x);
    }

  } else if (x <= 0.5) {
    if (-0.4 / log(x) < a) {
      return 1.0 - igam_series(a, x);
    } else {
      return igamc_series(a, x);
    }
  } else {
    if (x * 1.1 < a) {
      return 1.0 - igam_series(a, x);
    } else {
      return igamc_series(a, x);
    }
  }
}


function igam_fac(a:Real64, x:Real64) -> Real64 {
  if (abs(a - x) > 0.4 * abs(a)) {
    auto ax <- a * log(x) - x - lgamma(a);
    if (ax < -MAXLOG) {
      return 0.0;
    }
    return exp(ax);
  }

  auto fac <- a + LANCZOS_G - 0.5;
  auto res <- sqrt(fac / exp(1.0)) / lanczos_sum_expg_scaled(a);

  if ((a < 200.0) && (x < 200.0)) {
    res <- res * exp(a - x) * pow(x / fac, a);
  } else {
    auto num <- x - a - LANCZOS_G + 0.5;
    // changed log1pmx to this
    res <- res * exp(a * (log1p(num / fac) - x) + x * (0.5 - LANCZOS_G) / fac);
  }
  return res;
}


function igamc_continued_fraction(a:Real64, x:Real64) -> Real64 {

  auto ax <- igam_fac(a, x);
  if (ax == 0.0) {
    return 0.0;
  }

  /* continued fraction */
  auto y <- 1.0 - a;
  auto z <- x + y + 1.0;
  auto c <- 0.0;
  auto pkm2 <- 1.0;
  auto qkm2 <- x;
  auto pkm1 <- x + 1.0;
  auto qkm1 <- z * x;
  auto ans <- pkm1 / qkm1;

  auto flag <- true;
  auto i <- 0;
  auto t <- 0;
  while(i <= 2000 && flag) {
    c <- c + 1.0;
    y <- y + 1.0;
    z <- z + 2.0;
    auto yc <- y * c;
    auto pk <- pkm1 * z - pkm2 * yc;
    auto qk <- qkm1 * z - qkm2 * yc;
    if (qk != 0) {
      auto r <- pk / qk;
      t <- abs((ans - r) / r);
      ans <- r;
    } else {
      t <- 1.0;
    }

    pkm2 <- pkm1;
    pkm1 <- pk;
    qkm2 <- qkm1;
    qkm1 <- qk;
    if (abs(pk) > big) {
      pkm2 <- pkm2 * biginv;
      pkm1 <- pkm1 * biginv;
      qkm2 <- qkm2 * biginv;
      qkm1 <- qkm1 * biginv;
    }
    if (t <= MACHEP) {
      flag <- false;
    }
    ++i;
  }

  return (ans * ax);
}


function igam_series(a:Real64, x:Real64) -> Real64 {

  auto ax <- igam_fac(a, x);
  if (ax == 0.0) {
    return 0.0;
  }

  /* power series */
  auto r <- a;
  auto c <- 1.0;
  auto ans <- 1.0;
  auto flag <- true;
  auto i <- 0;
  while (i <= 2000 && flag) {
    r <-  r + 1.0;
    c <- c * (x / r);
    ans <- ans + c;
    if (c <= MACHEP * ans) {
      flag <- false;
    }
    ++i;
  }
  return (ans * ax / a);
}

function igamc_series(a:Real64, x:Real64) -> Real64 {
  auto fac <- 1.0;
  auto sum <- 0.0;
  term:Real64;
  logx:Real64;

  auto n <- 1;
  auto flag <- true;
  while (n <= 2000 && flag) {
    fac <- fac * (-x / n);
    term <- fac / (a + n);
    sum <- sum + term;
    if (abs(term) <= MACHEP * abs(sum)) {
      flag <- false;
    }
    ++n;
  }

  logx <- log(x);
  term <- -expm1(a * logx - lgamma(a + 1.0));
  return term - exp(a * logx - lgamma(a)) * sum;
}


function asymptotic_series(a:Real64, x:Real64, func:Integer) -> Real64 {
    auto K <- 25; // from igam.h
    auto N <- 25;
    auto sgn <- 0;
    auto maxpow <- 0;
    auto λ <- x / a;
    auto σ <- (x - a) / a;
    η:Real64;
    res:Real64;
    ck:Real64;
    ckterm:Real64;
    term:Real64;
    absterm:Real64;
    auto absoldterm <- inf;
    etapow:Real64[N];
    etapow[0] <- 1;
    auto tot <- 0.0;
    auto afac <- 1.0;
    stderr.print("Asymptotic Series Called\n");

  if (func == 1) {
    sgn <- -1;
  } else {
    sgn <- 1;
  }

  if (λ > 1.0) {
    η <- sqrt(-2.0 * (log1p(σ) - σ));
  } else if (λ < 1) {
    η <- -sqrt(-2.0 * (log1p(σ) - σ));
  } else {
    η <- 0.0;
  }
  res <- 0.5 * erfc(sgn * η * sqrt(a / 2.0));
  auto flag1 <- true;
  auto k <- 0;
  while (k <= K && flag1) {
    ck <- asymptotic_series_d[k,0];
    auto flag2 <- true;
    auto n <- 1;
    while (n <= N && flag2) {
      if (n > maxpow) {
        etapow[n] <- η * etapow[n-1];
        maxpow <- maxpow + 1;
      }
      ckterm <- asymptotic_series_d[k, n] * etapow[n];
      ck <- ck + ckterm;
      if (abs(ckterm) < MACHEP * abs(ck)) {
        flag2 <- false;
      }
      ++n;
    }
    term <- ck * afac;
    absterm <- abs(term);
    if (absterm > absoldterm) {
      flag1 <- false;
    }
    tot <- tot + term;
    if (absterm < (MACHEP * abs(tot))) {
      flag1 <- false;
    }
    absoldterm <- absterm;
    afac <- afac / a;
    ++k;
  }
  res <- res + sgn * exp(-0.5 * a * η * η) * tot / sqrt(2 * π * a);

  return res;
}


function lanczos_sum_expg_scaled(x:Real64) -> Real64 {
  return ratevl(x, lanczos_sum_expg_scaled_num, length(lanczos_sum_expg_scaled_num) - 1, lanczos_sum_expg_scaled_denom, length(lanczos_sum_expg_scaled_denom) - 1);
}


function ratevl(x:Real64, num:Real64[_], M:Integer, denom:Real64[_], N:Integer) -> Real64 {
  // TODO(pranavs): This function needs fixing
  dir:Integer;

  y:Real64;
  auto absx <- abs(x);
  auto pind <- 1;
  auto pval <- 0.0;

  if (absx > 1.0) {

    /* Evaluate as a polynomial in 1/x. */
    dir <- -1;
    // point at the last element
    pind <- M + 1;
    y <- 1.0 / x;
  } else {

    // point at the first element
    dir <- 1;
    pind <- 1;
    y <- x;
  }

   /* Evaluate the numerator */
   // breaks in the loop below

  // get the value of the first/last element depending on the abs(x)
  auto num_ans <- num[pind];
  pind <- pind + dir;
  for i in 2..(M+1) {
    num_ans <- (num_ans * y) + num[pind];
    pind <- pind + dir;
  }

  /* Evaluate the denominator */
  if (absx > 1.0) {
    pind <- N + 1;
  } else {
    pind <- 1;
  }

  auto denom_ans <- denom[pind];
  pind <- pind + dir;
  for i in 2..(N+1) {
    denom_ans <- denom_ans * y + denom[pind];
    pind <- pind + dir;
  }

  if (absx > 1.0) {
    auto i <- N - M;
    return pow(x, Real64(i)) * num_ans / denom_ans;
  } else {
    return num_ans / denom_ans;
  }
}

function libeta(α:Real64, β:Real64, x:Real64) -> Real64 {
  assert 0.0 < α;
  assert 0.0 < β;
  assert 0.0 < x && x <= 1.0;
  return (α - 1.0)*log(x) + (β - 1.0)*log1p(-x);
}

