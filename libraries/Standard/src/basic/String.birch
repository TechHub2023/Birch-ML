/**
 * Character string.
 */
type String;

/**
 * Convert to string.
 */
function String(x:Boolean) -> String {
  if x {
    return "true";
  } else {
    return "false";
  }
}

/**
 * Convert double-precision floating point number to string.
 */
function String(x:Real64) -> String {
  cpp{{
  std::stringstream buf;
  if (isfinite(x) && x == floor(x)) {
    buf << (int64_t)x << ".0";
  } else {
    buf << std::scientific << std::setprecision(14) << x;
  }
  return buf.str();
  }}
}

/**
 * Convert single-precision floating point number to string.
 */
function String(x:Real32) -> String {
  cpp{{
  std::stringstream buf;
  if (isfinite(x) && x == floor(x)) {
    buf << (int64_t)x << ".0";
  } else {
    buf << std::scientific << std::setprecision(6) << x;
  }
  return buf.str();
  }}
}

/**
 * Convert to string.
 */
function String(x:Integer64) -> String {
  cpp{{
  return std::to_string(x);
  }}
}

/**
 * Convert to string.
 */
function String(x:Integer32) -> String {
  cpp{{
  return std::to_string(x);
  }}
}

/**
 * Convert to string.
 */
function String(x:Integer16) -> String {
  cpp{{
  return std::to_string(x);
  }}
}

/**
 * Convert to string.
 */
function String(x:Integer8) -> String {
  cpp{{
  return std::to_string(x);
  }}
}

/**
 * Convert to string.
 */
function String(x:String) -> String {
  return x;
}

/**
 * Convert to string.
 */
function String(x:Boolean?) -> String? {
  if x? {
    return String(x!);
  } else {
    return nil;
  }
}

/**
 * Convert to string.
 */
function String(x:Real64?) -> String? {
  if x? {
    return String(x!);
  } else {
    return nil;
  }
}

/**
 * Convert to string.
 */
function String(x:Real32?) -> String? {
  if x? {
    return String(x!);
  } else {
    return nil;
  }
}

/**
 * Convert to string.
 */
function String(x:Integer64?) -> String? {
  if x? {
    return String(x!);
  } else {
    return nil;
  }
}

/**
 * Convert to string.
 */
function String(x:Integer32?) -> String? {
  if x? {
    return String(x!);
  } else {
    return nil;
  }
}

/**
 * Convert to string.
 */
function String(x:Integer16?) -> String? {
  if x? {
    return String(x!);
  } else {
    return nil;
  }
}

/**
 * Convert to string.
 */
function String(x:Integer8?) -> String? {
  if x? {
    return String(x!);
  } else {
    return nil;
  }
}

/**
 * Convert to string.
 */
function String(x:String?) -> String? {
  return x;
}

/**
 * Convert vector to String.
 */
function String(x:Real[_]) -> String {
  result:String;
  cpp{{
  std::stringstream buf;
  }}
  for i in 1..length(x) {
    let value <- x[i];
    cpp{{
    if (i > 1) {
      buf << ' ';
    }
    if (value == floor(value)) {
      buf << (int64_t)value << ".0";
    } else {
      buf << std::scientific << std::setprecision(6) << value;
    }
    }}
  }
  cpp{{
  result = buf.str();
  }}
  return result;
}

/**
 * Convert vector to String.
 */
function String(x:Integer[_]) -> String {
  result:String;
  cpp{{
  std::stringstream buf;
  }}
  for i in 1..length(x) {
    let value <- x[i];
    cpp{{
    if (i > 1) {
      buf << ' ';
    }
    buf << value;
    }}
  }
  cpp{{
  result = buf.str();
  }}
  return result;
}

/**
 * Convert vector to String.
 */
function String(x:Boolean[_]) -> String {
  result:String;
  cpp{{
  std::stringstream buf;
  }}
  for i in 1..length(x) {
    let value <- x[i];
    cpp{{
    if (i > 1) {
      buf << ' ';
    }
    if (value) {
      buf << "true";
    } else {
      buf << "false";
    }
    }}
  }
  cpp{{
  result = buf.str();
  }}
  return result;
}

/**
 * Convert matrix to String.
 */
function String(X:Real[_,_]) -> String {
  result:String;
  cpp{{
  std::stringstream buf;
  }}
  for i in 1..rows(X) {
    cpp{{
    if (i > 1) {
      buf << '\n';
    }
    }}
    for j in 1..columns(X) {
      let value <- X[i,j];
      cpp{{
      if (j > 1) {
        buf << ' ';
      }
      if (value == floor(value)) {
        buf << (int64_t)value << ".0";
      } else {
        buf << std::scientific << std::setprecision(14) << value;
      }
      }}
    }
  }
  cpp{{
  result = buf.str();
  }}
  return result;
}

/**
 * Convert matrix to String.
 */
function String(X:Integer[_,_]) -> String {
  result:String;
  cpp{{
  std::stringstream buf;
  }}
  for i in 1..rows(X) {
    cpp{{
    if (i > 1) {
      buf << '\n';
    }
    }}
    for j in 1..columns(X) {
      let value <- X[i,j];
      cpp{{
      if (j > 1) {
        buf << ' ';
      }
      buf << value;
      }}
    }
  }
  cpp{{
  result = buf.str();
  }}
  return result;
}

/**
 * Convert matrix to String.
 */
function String(X:Boolean[_,_]) -> String {
  result:String;
  cpp{{
  std::stringstream buf;
  }}
  for i in 1..rows(X) {
    cpp{{
    if (i > 1) {
      buf << '\n';
    }
    }}
    for j in 1..columns(X) {
      let value <- X[i,j];
      cpp{{
      if (j > 1) {
        buf << ' ';
      }
      if (value) {
        buf << "true";
      } else {
        buf << "false";
      }
      }}
    }
  }
  cpp{{
  result = buf.str();
  }}
  return result;
}

/**
 * Convert matrix to String.
 */
function String(X:LLT) -> String {
  return String(canonical(X));
}

/**
 * Lexical comparison.
 */
operator (x:String > y:String) -> Boolean {
  cpp{{
  return x.compare(y) > 0;
  }}
}

/**
 * Lexical comparison.
 */
operator (x:String < y:String) -> Boolean {
  cpp{{
  return x.compare(y) < 0;
  }}
}

/**
 * Lexical comparison.
 */
operator (x:String >= y:String) -> Boolean {
  cpp{{
  return x.compare(y) >= 0;
  }}
}

/**
 * Lexical comparison.
 */
operator (x:String <= y:String) -> Boolean {
  cpp{{
  return x.compare(y) <= 0;
  }}
}

/**
 * Equality comparison.
 */
operator (x:String == y:String) -> Boolean {
  cpp{{
  return x.compare(y) == 0;
  }}
}

/**
 * Equality comparison.
 */
operator (x:String != y:String) -> Boolean {
  cpp{{
  return x.compare(y) != 0;
  }}
}

/**
 * String concatenation.
 */
operator (x:String + y:String) -> String;

/**
 * String concatenation.
 */
operator (x:String + y:Boolean) -> String {
  return x + String(y);
}

/**
 * String concatenation.
 */
operator (x:String + y:Real) -> String {
  return x + String(y);
}

/**
 * String concatenation.
 */
operator (x:String + y:Integer) -> String {
  return x + String(y);
}

/**
 * String concatenation.
 */
operator (x:String + y:Boolean[_]) -> String {
  return x + String(y);
}

/**
 * String concatenation.
 */
operator (x:String + y:Real[_]) -> String {
  return x + String(y);
}

/**
 * String concatenation.
 */
operator (x:String + y:Integer[_]) -> String {
  return x + String(y);
}

/**
 * String concatenation.
 */
operator (x:String + y:Boolean[_,_]) -> String {
  return x + String(y);
}

/**
 * String concatenation.
 */
operator (x:String + y:Real[_,_]) -> String {
  return x + String(y);
}

/**
 * String concatenation.
 */
operator (x:String + y:Integer[_,_]) -> String {
  return x + String(y);
}

/**
 * String concatenation.
 */
operator (x:Boolean + y:String) -> String {
  return String(x) + y;
}

/**
 * String concatenation.
 */
operator (x:Real + y:String) -> String {
  return String(x) + y;
}

/**
 * String concatenation.
 */
operator (x:Integer + y:String) -> String {
  return String(x) + y;
}

/**
 * String concatenation.
 */
operator (x:Boolean[_] + y:String) -> String {
  return String(x) + y;
}

/**
 * String concatenation.
 */
operator (x:Real[_] + y:String) -> String {
  return String(x) + y;
}

/**
 * String concatenation.
 */
operator (x:Integer[_] + y:String) -> String {
  return String(x) + y;
}

/**
 * String concatenation.
 */
operator (x:Boolean[_,_] + y:String) -> String {
  return String(x) + y;
}

/**
 * String concatenation.
 */
operator (x:Real[_,_] + y:String) -> String {
  return String(x) + y;
}

/**
 * String concatenation.
 */
operator (x:Integer[_,_] + y:String) -> String {
  return String(x) + y;
}

/**
 * Length of a string.
 */
function length(x:String) -> Integer {
  cpp{{
  return x.length();
  }}
}

/**
 * Length of an array of strings.
 */
function length(x:String[_]) -> Integer {
  cpp{{
  return x.rows();
  }}
}