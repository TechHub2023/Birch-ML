/**
 * Cholesky factorization of a symmetric positive definite matrix, $S = LL^T$.
 */
type LLT;

/**
 * Cholesky factorization of the symmetric positive definite matrix $S$.
 *
 * - S: The symmetric positive definite matrix $S$.
 *
 * Returns: an object representing the symmetric positive definite matrix $S$
 * in its decomposed form.
 *
 * This differs from `chol` in that `chol` returns the lower-triangular
 * Cholesky factor, while this returns the original matrix, but factorized.
 *
 * The object acts as the matrix $S$, defines conversion to and assignment
 * from `Real[_,_]`, and is intended as more or less a drop-in replacement
 * for that type, albeit sharing, as usual for objects (i.e. copy-by-reference
 * rather than copy-by-value semantics). That sharing permits, for example,
 * multiple multivariate Gaussian distributions to share the same covariance
 * or precision matrix with common posterior updates performed only once.
 *
 * Various functions, such as `solve`, have overloads that make use of `LLT`
 * objects for more efficient computation.
 *
 * !!! attention
 *     To emphasize, the matrix represented is $S$, not $L$, which is to say,
 *     code such as the following:
 *
 *         let A <- llt(S);
 *         y <- solve(A, x);
 *
 *     computes the matrix-vector product $y = S^{^-1}x$, not $y = L^{-1}x$,
 *     however the Cholesky decomposition will be used to solve this more
 *     efficiently than a general matrix solve. The point of an `LLT` object
 *     is to maintain the original matrix in a decomposed form for more
 *     efficient computation. 
 */
function llt(S:Real[_,_]) -> LLT {
  A:LLT;
  cpp{{
  A.compute(S.toEigen());
  }}
  return A;
}

/**
 * Cholesky decomposition of the symmetric positive definite matrix $S$
 * (identity function).
 */
function llt(S:LLT) -> LLT {
  return S;
}

/**
 * Rank one update of a Cholesky decomposition.
 *
 * - S: Existing Cholesky decomposition of the symmetric positive definite
 *      matrix $S$.
 * - x: Vector $x$.
 *
 * Returns: A new Cholesky decomposition of the symmetric positive definite
 * matrix $S + xx^\top$.
 */
function rank_update(S:LLT, x:Real[_]) -> LLT {
  assert rows(S) == length(x);
  cpp{{
  auto A = S;
  A.rankUpdate(x.toEigen(), 1.0);
  return A;
  }}
}

/**
 * Rank $k$ update of a Cholesky decomposition.
 *
 * - S: Existing Cholesky decomposition of the symmetric positive definite
 *      matrix $S$.
 * - X: Matrix $X$.
 *
 * Returns: A new Cholesky decomposition of the symmetric positive definite
 * matrix $S + XX^\top$.
 *
 * The computation is performed as $k$ separate rank-1 updates using the
 * columns of `X
 */
function rank_update(S:LLT, X:Real[_,_]) -> LLT {
  assert rows(S) == rows(X);
  A:LLT;
  cpp{{
  A = S;
  }}
  let R <- rows(X);
  let C <- columns(X);
  for j in 1..C {
    let x <- X[1..R,j];
    cpp{{
    A.rankUpdate(x.toEigen(), 1.0);
    }}
  }
  return A;
}

/**
 * Rank one downdate of a Cholesky decomposition.
 *
 * - S: Existing Cholesky decomposition of the symmetric positive definite
 *      matrix $S$.
 * - x: Vector $x$.
 *
 * Returns: A new Cholesky decomposition of the symmetric positive definite
 * matrix $S - xx^\top$.
 */
function rank_downdate(S:LLT, x:Real[_]) -> LLT {
  assert rows(S) == length(x);
  cpp{{
  auto A = S;
  A.rankUpdate(x.toEigen(), -1.0);
  return A;
  }}
}

/**
 * Rank $k$ downdate of a Cholesky decomposition.
 *
 * - S: Existing Cholesky decomposition of the symmetric positive definite
 *      matrix $S$.
 * - X: Matrix $X$.
 *
 * Returns: A new Cholesky decomposition of the symmetric positive definite
 * matrix $S - XX^\top$.
 *
 * The computation is performed as $k$ separate rank-1 downdates using the
 * columns of `X
 */
function rank_downdate(S:LLT, X:Real[_,_]) -> LLT {
  assert rows(S) == rows(X);
  A:LLT;
  cpp{{
  A = S;
  }}
  let R <- rows(X);
  let C <- columns(X);
  for j in 1..C {
    let x <- X[1..R,j];
    cpp{{
    A.rankUpdate(x.toEigen(), -1.0);
    }}
  }
  return A;
}

function canonical(x:LLT) -> Real[_,_] {
  cpp{{
  return x.reconstructedMatrix();
  }}
}

function length(x:LLT) -> Integer {
  return rows(x);
}

function size(x:LLT) -> Integer {
  return rows(x)*columns(x);
}

function rows(x:LLT) -> Integer {
  cpp{{
  return x.rows();
  }}
}

function columns(x:LLT) -> Integer {
  cpp{{
  return x.cols();
  }}
}

function depth(x:LLT) -> Integer {
  return 0;
}

function value(x:LLT) -> LLT {
  return x;
}

function eval(x:LLT) -> LLT {
  return x;
}

function eval(x:LLT, gen:Integer) -> LLT {
  return x;
}

function count_eval(x:LLT, gen:Integer) -> LLT {
  return x;
}

function reval(x:LLT) -> LLT {
  return x;
}

function reval(x:LLT, gen:Integer) -> LLT {
  return x;
}

function count_reval(x:LLT, gen:Integer) -> LLT {
  return x;
}

function grad<Gradient>(x:LLT, d:Gradient) {
  //
}

function grad<Gradient>(x:LLT, gen:Integer, d:Gradient) {
  //
}

function count_grad<Gradient>(x:LLT, gen:Integer, d:Gradient) {
  //
}

function count_grad(x:LLT, gen:Integer, d:Real, i:Integer) {
  //
}

function count_grad(x:LLT, gen:Integer, d:Real, i:Integer, j:Integer) {
  //
}

function graft_beta(x:LLT) -> Beta? {
  return nil;
}

function graft_dirichlet(x:LLT) -> Dirichlet? {
  return nil;
}

function graft_restaurant(x:LLT) -> Restaurant? {
  return nil;
}

function graft_gamma(x:LLT) -> Gamma? {
  return nil;
}

function graft_scaled_gamma(x:LLT) ->  TransformLinear<Gamma>? {
  return nil;
}

function graft_inverse_gamma(x:LLT) -> InverseGamma? {
  return nil;
}

function graft_inverse_wishart(x:LLT) -> InverseWishart? {
  return nil;
}

function graft_gaussian(x:LLT) -> Gaussian? {
  return nil;
}

function graft_linear_gaussian(x:LLT) -> TransformLinear<Gaussian>? {
  return nil;
}

function graft_normal_inverse_gamma(x:LLT, compare:Distribution<Real>) ->
    NormalInverseGamma? {
  return nil;
}

function graft_linear_normal_inverse_gamma(x:LLT, compare:Distribution<Real>) ->
    TransformLinear<NormalInverseGamma>? {
  return nil;
}

function graft_multivariate_gaussian(x:LLT) -> MultivariateGaussian? {
  return nil;
}

function graft_linear_multivariate_gaussian(x:LLT) ->
    TransformLinearMultivariate<MultivariateGaussian>? {
  return nil;
}

function graft_dot_multivariate_gaussian(x:LLT) ->
    TransformDot<MultivariateGaussian>? {
  return nil;
}

function graft_multivariate_normal_inverse_gamma(x:LLT, compare:Distribution<Real>) ->
    MultivariateNormalInverseGamma? {
  return nil;
}

function graft_linear_multivariate_normal_inverse_gamma(x:LLT, compare:Distribution<Real>) ->
    TransformLinearMultivariate<MultivariateNormalInverseGamma>? {
  return nil;
}

function graft_dot_multivariate_normal_inverse_gamma(x:LLT, compare:Distribution<Real>) ->
    TransformDot<MultivariateNormalInverseGamma>? {
  return nil;
}

function graft_matrix_gaussian(x:LLT) -> MatrixGaussian? {
  return nil;
}

function graft_linear_matrix_gaussian(x:LLT) ->
    TransformLinearMatrix<MatrixGaussian>? {
  return nil;
}

function graft_dot_matrix_gaussian(x:LLT) ->
    TransformDotMultivariate<MatrixGaussian>? {
  return nil;
}

function graft_matrix_normal_inverse_wishart(x:LLT, compare:Distribution<LLT>) ->
    MatrixNormalInverseWishart? {
  return nil;
}

function graft_linear_matrix_normal_inverse_wishart(x:LLT, compare:Distribution<LLT>) ->
    TransformLinearMatrix<MatrixNormalInverseWishart>? {
  return nil;
}

function graft_dot_matrix_normal_inverse_wishart(x:LLT, compare:Distribution<LLT>) ->
    TransformDotMultivariate<MatrixNormalInverseWishart>? {
  return nil;
}

function graft_discrete(x:LLT) -> Discrete? {
  return nil;
}

function graft_bounded_discrete(x:LLT) -> BoundedDiscrete? {
  return nil;
}
