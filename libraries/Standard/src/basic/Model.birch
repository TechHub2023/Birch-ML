/**
 * Model.
 */
abstract class Model {
  /**
   * Distribution and Random objects for move, by step.
   */
  Ξ:Array<Array<Delay>>;

  /**
   * Factors for move, by step.
   */
  Φ:Array<Array<Expression<Real>>>;

  /**
   * Start execution.
   */
  function simulate() {
    //
  }

  /**
   * Step execution.
   *
   * @param t The step number, beginning at 1.
   */
  function simulate(t:Integer) {
    //
  }

  final function hasHoist() -> Boolean {
    return Ξ.size() + Φ.size() > 0;
  }

  final function hoist() -> Expression<Real> {
    π:Expression<Real>? <- nil;
    for i in 1..Ξ.size() {
      for j in 1..Ξ[i].size() {
        if !Ξ[i][j].isSubordinate() {
          let ξ <- Ξ[i][j].hoist();
          if π? {
            π <- box(π! + ξ);
          } else {
            π <- ξ;
          }
        }
      }
    }
    for i in 1..Φ.size() {
      for j in 1..Φ[i].size() {
        let φ <- Φ[i][j];
        if π? {
          π <- box(π! + φ);
        } else {
          π <- φ;
        }
      }
    }
    assert π?;
    π!.trace();
    return π!;
  }

  final function fix(nlags:Integer) {
    while Ξ.size() >= nlags {
      for j in 1..Ξ.front().size() {
        /* we will ignore this factor henceforth when performing moves, so
         * must render constant both the random variate and parameters of the
         * associated distribution to avoid further moves on them in the
         * absence of this factor (which would not be invariant to the
         * posterior) */
        Ξ.front()[j].fix();
      }
      Ξ.popFront();
    }
    while Φ.size() >= nlags {
      for j in 1..Φ.front().size() {
        Φ.front()[j].constant();
      }
      Φ.popFront();
    }
  }
}
