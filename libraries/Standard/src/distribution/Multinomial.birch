/**
 * Multinomial distribution.
 */
final class Multinomial(n:Expression<Integer>, ρ:Expression<Real[_]>) <
    Distribution<Integer[_]> {
  /**
   * Number of trials.
   */
  n:Expression<Integer> <- n;

  /**
   * Category probabilities.
   */
  ρ:Expression<Real[_]> <- ρ;

  function rows() -> Integer {
    return ρ.rows();
  }

  function supportsLazy() -> Boolean {
    return false;
  }

  function simulate() -> Integer[_] {
    return simulate_multinomial(n.value(), ρ.value());
  }

//  function simulateLazy() -> Integer[_]? {
//    return simulate_multinomial(n.eval(), ρ.eval());
//  }
  
  function logpdf(x:Integer[_]) -> Real {
    return logpdf_multinomial(x, n.value(), ρ.value());
  }

//  function logpdfLazy(x:Expression<Integer[_]>) -> Expression<Real>? {
//    return logpdf_lazy_multinomial(x, n, ρ);
//  }

  function write(buffer:Buffer) {
    prune();
    buffer.set("class", "Multinomial");
    buffer.set("n", n);
    buffer.set("ρ", ρ);
  }
}

/**
 * Create multinomial distribution.
 */
function Multinomial<Left,Right>(n:Left, ρ:Right) -> {
  return construct<Multinomial>(box(n), box(ρ));
}

/**
 * Create multinomial distribution.
 */
function Multinomial<Left>(n:Left, ρ:Random<Real[_]>) ->
    Distribution<Integer[_]> {
  m:Dirichlet?;
  if (m <- ρ.graftDirichlet())? {
    return DirichletMultinomial(n, m!);
  } else {
    return construct<Multinomial>(box(n), ρ);
  }
}

/*
 * Simulate a multinomial distribution.
 *
 * - n: Number of trials.
 * - ρ: Category probabilities. These should sum to one.
 *
 * This uses an $\mathcal{O}(N)$ implementation based on:
 *
 * Bentley, J. L. and J. B. Saxe (1979). Generating sorted lists of random
 * numbers. Technical Report 2450, Carnegie Mellon University, Computer
 * Science Department.
 */
function simulate_multinomial(n:Integer, ρ:Real[_]) -> Integer[_] {
  return simulate_multinomial(n, ρ, 1.0);
}

/*
 * Simulate a multinomial distribution.
 *
 * - n: Number of trials.
 * - ρ: Unnormalized category probabilities.
 * - Z: Sum of the unnormalized category probabilities.
 *
 * This uses an $\mathcal{O}(N)$ implementation based on:
 *
 * Bentley, J. L. and J. B. Saxe (1979). Generating sorted lists of random
 * numbers. Technical Report 2450, Carnegie Mellon University, Computer
 * Science Department.
 */
function simulate_multinomial(n:Integer, ρ:Real[_], Z:Real) -> Integer[_] {
  assert length(ρ) > 0;
  assert abs(sum(ρ) - Z) < 1.0e-6;

  D:Integer <- length(ρ);
  R:Real <- ρ[D];
  lnMax:Real <- 0.0;
  j:Integer <- D;
  i:Integer <- n;
  u:Real;
  x:Integer[_] <- vector(0, D);
    
  while i > 0 {
    u <- simulate_uniform(0.0, 1.0);
    lnMax <- lnMax + log(u)/i;
    u <- Z*exp(lnMax);
    while u < Z - R {
      j <- j - 1;
      R <- R + ρ[j];
    }
    x[j] <- x[j] + 1;
    i <- i - 1;
  }
  while j > 1 {
    j <- j - 1;
    x[j] <- 0;
  }
  return x;
}

/*
 * Observe a multinomial variate.
 *
 * - x: The variate.
 * - n: Number of trials.
 * - ρ: Category probabilities.
 *
 * Returns: the log probability mass.
 */
function logpdf_multinomial(x:Integer[_], n:Integer, ρ:Real[_]) -> Real {
  assert length(x) == length(ρ);

  m:Integer <- 0;
  w:Real <- lgamma(n + 1.0);
  for i in 1..length(x) {
    assert x[i] >= 0;
    assert ρ[i] >= 0.0;
    m <- m + x[i];
    w <- w + x[i]*log(ρ[i]) - lgamma(x[i] + 1.0);
  }
  if (m == n) {
    return w;
  } else {
    return -inf;
  }
}
