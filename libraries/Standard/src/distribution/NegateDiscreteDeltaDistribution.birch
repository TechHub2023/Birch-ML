/**
 * Delta distribution convolved with a bounded discrete distribution, with
 * negation.
 */
final class NegateDiscreteDeltaDistribution<Arg1>(p:Arg1, l:Integer!) <
    Distribution<Integer> {
  /**
   * Probability vector of random variable (before negation).
   */
  p:Arg1 <- p;

  /**
   * Inclusive lower bound of random variable (before negation).
   */
  l:Integer! <- l;

  override function simulate() -> Integer! {
    return 1 - l - simulate_categorical(value(p));
  }

  override function simulateLazy() -> Integer!? {
    return 1 - l - simulate_categorical(eval(p));
  }

  override function logpdf(x:Integer!) -> Real! {
    return logpdf_categorical(1 - l - x, value(p));
  }

  override function logpdfLazy(x:Integer!) -> Real!? {
    return logpdf_categorical(1 - l - x, eval(p));
  }

  override function update(x:Integer!) -> Delay? {
    return wrap_delta(-x);
  }

  override function updateLazy(x:Expression<Integer>) -> Delay? {
    return wrap_delta(-x);
  }

  override function hoist() -> Expression<Real>? {
    return box(logpdf_categorical(1 - l - this.random(), p));
  }

  override function lower() -> Integer!? {
    return 1 - l - length(p);
  }
  
  override function upper() -> Integer!? {
    return -l;
  }

  override function constant() {
    super.constant();
    global.constant(p);
    global.constant(l);
  }

  override function isBoundedDiscrete() -> Boolean {
    return !x?;
  }

  override function getBoundedDiscrete() -> (Expression<Real[_]>, Integer!)? {
    assert isBoundedDiscrete();
    let n <- length(p);
    return (box(gather(p, n - iota(0, n))), 1 - l - n);
  }
}

function NegateDiscreteDelta<Arg1>(p:Arg1, l:Integer!) ->
    Distribution<Integer> {
  return wrap_negate_discrete_delta(p, l);
}
function wrap_negate_discrete_delta<Arg1>(p:Arg1, l:Integer!) -> {
  return make_negate_discrete_delta(wrap(p), l);
}
function make_negate_discrete_delta<Arg1>(p:Arg1, l:Integer!) -> {
  return construct<NegateDiscreteDeltaDistribution<Arg1>>(p, l);
}

/**
 * Create delta distribution.
 */
function Delta(μ:Neg<Random<Integer>>) -> Distribution<Integer> {
  let m <- μ.m;
	if m.isBoundedDiscrete() {
  	let p_m <- m.graft();
    let (p, l) <- p_m.getBoundedDiscrete()!;
    let q <- wrap_negate_discrete_delta(p, l);
    p_m.setMarginalized(q);
    return q;
	} else {
		return wrap_delta(μ);
	}
}

/**
 * Create delta distribution.
 */
function Delta<Arg>(μ:Neg<Arg>) -> Distribution<Integer> {
  let m ~ Delta(μ.m);
  return Delta(-m);
}
