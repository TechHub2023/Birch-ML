/**
 * Conway-Maxwell-Poisson distribution.
 *
 * - λ: Rate.
 * - ν: Dispersion.
 * - n: Truncation point.
 *
 * The distribution is always truncated on $[0,n]$ because of an intractable
 * normalizing constant that can only be expressed as an infinite series on
 * the support of the non-truncated distribution, $[0,\infty)$. The larger
 * $n$, the closer the approximation to the non-truncated distribution---if
 * that is desired---but the more expensive operations: most are $O(n)$.
 */
class ConwayMaxwellPoisson(λ:Expression<Real>, ν:Expression<Real>,
    n:Expression<Integer>) < BoundedDiscrete {
  /**
   * Rate.
   */
  λ:Expression<Real> <- λ;

  /**
   * Dispersion.
   */
  ν:Expression<Real> <- ν;

  /**
   * Truncation point.
   */
  n:Expression<Integer> <- n;

  function supportsLazy() -> Boolean {
    return true;
  }

  function simulate() -> Integer {
    return simulate_conway_maxwell_poisson(λ.value(), ν.value(), n.value());
  }

  function simulateLazy() -> Integer? {
    return simulate_conway_maxwell_poisson(λ.peak(), ν.peak(), n.peak());
  }

  function logpdf(x:Integer) -> Real {
    return logpdf_conway_maxwell_poisson(x, λ.value(), ν.value(), n.value());
  }

  function logpdfLazy(x:Expression<Integer>) -> Expression<Real>? {
    return logpdf_lazy_conway_maxwell_poisson(x, λ, ν, n);
  }

  function cdf(x:Integer) -> Real? {
    return cdf_conway_maxwell_poisson(x, λ.value(), ν.value(), n.value());
  }

  function quantile(P:Real) -> Integer? {
    return quantile_conway_maxwell_poisson(P, λ.value(), ν.value(), n.value());
  }

  function lower() -> Integer? {
    return 0;
  }

  function upper() -> Integer? {
    return n.value();
  }

  function write(buffer:Buffer) {
    prune();
    buffer.set("class", "ConwayMaxwellPoisson");
    buffer.set("λ", λ);
    buffer.set("ν", ν);
    buffer.set("n", n);
  }
}

/**
 * Create Conway-Maxwell-Poisson distribution.
 */
function ConwayMaxwellPoisson<Left,Middle,Right>(λ:Left, ν:Middle, n:Right) -> {
  return construct<ConwayMaxwellPoisson>(box(λ), box(ν), box(n));
}

/*
 * Simulate a Conway-Maxwell-Poisson distribution.
 *
 * - λ: Rate.
 * - ν: Dispersion.
 * - n: Truncation point.
 */
function simulate_conway_maxwell_poisson(λ:Real, ν:Real, n:Integer) ->
    Integer {
  return quantile_conway_maxwell_poisson(simulate_uniform(0.0, 1.0), λ, ν, n);
}

/*
 * Observe a Conway-Maxwell-Poisson variate.
 *
 * - x: The variate.
 * - λ: Rate.
 * - ν: Dispersion.
 * - n: Truncation point.
 *
 * Returns: the log probability mass.
 */
function logpdf_conway_maxwell_poisson(x:Integer, λ:Real, ν:Real,
    n:Integer) -> Real {
  assert 0.0 <= λ;
  assert 0.0 <= ν;
  assert 0 <= n;
  return x*log(λ) - ν*lgamma(x + 1.0) -
      log(normalize_conway_maxwell_poisson(λ, ν, n));
}

/*
 * Observe a Conway-Maxwell-Poisson variate.
 *
 * - x: The variate.
 * - λ: Rate.
 * - ν: Dispersion.
 * - n: Truncation point.
 *
 * Returns: the log probability mass.
 */
function logpdf_lazy_conway_maxwell_poisson(x:Expression<Integer>,
    λ:Expression<Real>, ν:Expression<Real>, n:Expression<Integer>) ->
    Expression<Real> {
  return box(x*log(λ) - ν*lgamma(x + 1.0) -
      log(normalize_conway_maxwell_poisson(λ, ν, n)));
}

/*
 * CDF of a Conway-Maxwell-Poisson variate.
 *
 * - x: The variate.
 * - λ: Rate.
 * - ν: Dispersion.
 * - n: Truncation point.
 *
 * Return: the cumulative probability.
 */
function cdf_conway_maxwell_poisson(x:Integer, λ:Real, ν:Real, n:Integer) ->
    Real {
  assert 0.0 <= λ;
  assert 0.0 <= ν;
  assert 0 <= n;

  if x < 0 {
    return 0.0;
  } else if x >= n {
    return 1.0;
  } else {
    let z <- 1.0;
    let Z <- z;
    for i in 1..x {
      z <- z*λ/pow(scalar<Real>(i), ν);
      Z <- Z + z;
    }
    let z' <- z;
    let Z' <- Z;
    for i in (x + 1)..n {
      z' <- z'*λ/pow(scalar<Real>(i), ν);
      Z' <- Z' + z';
    }
    return Z/Z';
  }
}

/*
 * Quantile of a Conway-Maxwell-Poisson distribution.
 *
 * - P: The cumulative probability.
 * - λ: Rate.
 * - ν: Dispersion.
 * - n: Truncation point.
 *
 * Return: the quantile.
 */
function quantile_conway_maxwell_poisson(P:Real, λ:Real, ν:Real,
    n:Integer) -> Integer {
  assert 0.0 <= λ;
  assert 0.0 <= ν;
  assert 0 <= n;

  let Q <- P*normalize_conway_maxwell_poisson(λ, ν, n);
  let x <- 0;
  let z <- 1.0;
  let Z <- z;
  while Z <= Q && x < n {
    x <- x + 1;
    z <- z*λ/pow(x, ν);
    Z <- Z + z;
  }
  return x;
}
