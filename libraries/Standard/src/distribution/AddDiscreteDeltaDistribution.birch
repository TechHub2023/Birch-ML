/**
 * Delta distribution on sum of two bounded discrete random variables.
 */
final class AddDiscreteDeltaDistribution<Arg1,Arg2>(p:Arg1, q:Arg2,
    a:Integer!, b:Integer!) < Distribution<Integer> {
  /**
   * Probability vector of first random variable.
   */
  p:Arg1 <- p;

  /**
   * Probability vector of second random variable.
   */
  q:Arg2 <- q;

  /**
   * Inclusive lower bound on support of first random variable.
   */
  a:Integer! <- a;

  /**
   * Inclusive lower bound on support of second random variable.
   */
  b:Integer! <- b;

  override function simulate() -> Integer! {
    return simulate_add_discrete_delta(global.value(p), global.value(q), global.value(a),
        global.value(b));
  }

  override function simulateLazy() -> Integer! {
    return simulate_add_discrete_delta(global.eval(p), global.eval(q), global.eval(a), global.eval(b));
  }

  override function logpdf(x:Integer!) -> Real! {
    return log(pdf_add_discrete_delta(x, global.value(p), global.value(q), global.value(a),
        global.value(b)));
  }

  override function logpdfLazy(x:Integer!) -> Real! {
    return log(pdf_add_discrete_delta(x, global.eval(p), global.eval(q), global.eval(a), global.eval(b)));
  }

  override function update(x:Integer!) -> Delay? {
    return update_add_discrete_delta(x, global.value(p), global.value(q), global.value(a),
        global.value(b));
  }

  override function updateLazy(x:Random<Integer>) -> Delay? {
    return update_add_discrete_delta(x, global.eval(p), global.eval(q), global.eval(a), global.eval(b));
  }

  override function hoist() -> Expression<Real> {
    return box(log(pdf_add_discrete_delta(random(), p, q, a, b)));
  }

  override function lower() -> Integer!? {
    return global.value(a) + global.value(b);
  }

  override function upper() -> Integer!? {
    return global.value(a) + global.value(b) + (global.length(p) + global.length(q) - 2);
  }

  override function fix() {
    super.fix();
    global.constant(p);
    global.constant(q);
    global.constant(a);
    global.constant(b);
  }

  override function isBoundedDiscrete() -> Boolean {
    return !x?;
  }

  override function getBoundedDiscrete() -> (Expression<Real[_]>, Integer!)? {
    assert isBoundedDiscrete();
    let r <- convolve(p, q);
    return (box(r/sum(r)), a + b);
    // ^ numerical errors can accumulate, so renormalize
  }
}

function AddDiscreteDelta<Arg1,Arg2>(p:Arg1, q:Arg2, a:Integer!,
    b:Integer!) -> Distribution<Integer> {
  return make_add_discrete_delta(p, q, a, b);
}
function make_add_discrete_delta<Arg1,Arg2>(p:Arg1, q:Arg2, a:Integer!,
    b:Integer!) -> {
  return construct<AddDiscreteDeltaDistribution<Arg1,Arg2>>(p, q, a, b);
}

/**
 * Create delta distribution.
 */
function Delta(μ:Add<Random<Integer>,Random<Integer>>) ->
    Distribution<Integer> {
  let l <- μ.l;
  let r <- μ.r;
  if l.isBoundedDiscrete() && r.isBoundedDiscrete() {
    let p_l <- l.graft();
    let p_r <- r.graft();
    let (p, a) <- p_l.getBoundedDiscrete()!;
    let (q, b) <- p_r.getBoundedDiscrete()!;
    let r <- make_add_discrete_delta(p, q, a, b);
    p_r.setSecondOrder(true);
    p_r.setMarginalized(p_l);
    p_l.setMarginalized(r);
    return r;
  } else if l.isBoundedDiscrete() {
    let x ~ Delta(r);
    return Delta(l + x);
  } else if r.isBoundedDiscrete() {
    let x ~ Delta(l);
    return Delta(x + r);
  } else {
    return make_delta(μ);
  }
}

/**
 * Create delta distribution.
 */
function Delta<Arg>(μ:Add<Random<Integer>,Arg>) -> Distribution<Integer> {
  let r ~ Delta(μ.r);
  return Delta(μ.l + r);
}

/**
 * Create delta distribution.
 */
function Delta<Arg>(μ:Add<Arg,Random<Integer>>) -> Distribution<Integer> {
  let l ~ Delta(μ.l);
  return Delta(l + μ.r);
}

/**
 * Create delta distribution.
 */
function Delta<Arg1,Arg2>(μ:Add<Arg1,Arg2>) -> Distribution<Integer> {
  let l ~ Delta(μ.l);
  let r ~ Delta(μ.r);
  return Delta(l + r);
}

/**
 * Create delta distribution.
 */
function Delta(μ:Sub<Random<Integer>,Random<Integer>>) ->
    Distribution<Integer> {
  let r ~ Delta(-μ.r);
  return Delta(μ.l + r);
}

/**
 * Create delta distribution.
 */
function Delta<Arg>(μ:Sub<Random<Integer>,Arg>) -> Distribution<Integer> {
  let r ~ Delta(-μ.r);
  return Delta(μ.l + r);
}

/**
 * Create delta distribution.
 */
function Delta<Arg>(μ:Sub<Arg,Random<Integer>>) -> Distribution<Integer> {
  let l ~ Delta(μ.l);
  let r ~ Delta(-μ.r);
  return Delta(l + r);
}

/**
 * Create delta distribution.
 */
function Delta<Arg1,Arg2>(μ:Sub<Arg1,Arg2>) -> Distribution<Integer> {
  let l ~ Delta(μ.l);
  let r ~ Delta(-μ.r);
  return Delta(l + r);
}

/*
 * Simulate the sum of discrete random variables.
 *
 * @param p Probability vector of first random variable.
 * @param q Probability vector of second random variable.
 * @param a Inclusive lower bound of first random variable.
 * @param b Inclusive lower bound of second random variable.
 *
 * @return the sum.
 */
function simulate_add_discrete_delta<Arg1,Arg2>(p:Arg1, q:Arg2, a:Integer!,
    b:Integer!) -> {
  return simulate_categorical(p) + simulate_categorical(q) + a + b - 2;
}

/*
 * Observe the sum of discrete random variables.
 *
 * @param x The sum.
 * @param p Probability vector of first random variable.
 * @param q Probability vector of second random variable.
 * @param a Inclusive lower bound of first random variable.
 * @param b Inclusive lower bound of second random variable.
 *
 * @return the probability mass.
 */
function pdf_add_discrete_delta<Arg1,Arg2,Arg3>(x:Arg1, p:Arg2, q:Arg3,
    a:Integer!, b:Integer!) -> {
  assert global.length(p) > 0;
  assert global.length(q) > 0;

  let m <- global.length(p);
  let n <- global.length(q);
  let z <- wait(global.eval(x) - a - b);  // offset to base zero

  /* start of range for first random variable; the second contributes at
   * most n - 1, so the first must contribute at least... */
  let i <- max(0, z - (n - 1));

  /* end of range for the first random variable; the second contributes at
   * least zero, so the first must contribute at most... */
  let j <- min(m - 1, z);

  /* start of range for second random variable; the first contributes at
   * most j, so the second must contribute at least... */
  let k <- max(0, z - j);

  /* end of range for the second random variable; the first contributes at
   * least i, so the first must contribute at most... */
  let l <- min(n - 1, z - i);

  assert j - i + 1 == l - k + 1;  // lengths of ranges should be equal
  let s <- iota(i + 1, max(j - i + 1, 0));  // first range, ascending order
  let t <- l + 1 - iota(0, max(l - k + 1, 0));  // second range, descending order

  return dot(gather(p, s), gather(q, t));
}

/*
 * Update the parameters of discrete random variables given their sum.
 *
 * @param x The sum.
 * @param p Probability vector of first random variable.
 * @param q Probability vector of second random variable.
 * @param a Inclusive lower bound of first random variable.
 * @param b Inclusive lower bound of second random variable.
 *
 * @return the updated distribution.
 */
function update_add_discrete_delta<Arg1,Arg2,Arg3>(x:Arg1, p:Arg2, q:Arg3,
    a:Integer!, b:Integer!) -> {
  assert global.length(p) > 0;
  assert global.length(q) > 0;

  let m <- global.length(p);
  let n <- global.length(q);
  let z <- wait(global.eval(x) - a - b);  // offset to base zero

  /* start of range for first random variable; the second contributes at
   * most n - 1, so the first must contribute at least... */
  let i <- max(0, z - (n - 1));

  /* end of range for the first random variable; the second contributes at
   * least zero, so the first must contribute at most... */
  let j <- min(m - 1, z);

  /* start of range for second random variable; the first contributes at
   * most j, so the second must contribute at least... */
  let k <- max(0, z - j);

  /* end of range for the second random variable; the first contributes at
   * least i, so the first must contribute at most... */
  let l <- min(n - 1, z - i);

  assert j - i + 1 == l - k + 1;  // lengths of ranges should be equal
  let s <- iota(i + 1, max(j - i + 1, 0));  // first range, ascending order
  let t <- l + 1 - iota(0, max(l - k + 1, 0));  // second range, descending order

  let r <- hadamard(gather(p, s), gather(q, t));
  return make_add_discrete_first(r/sum(r), a + i, b + k);
}
