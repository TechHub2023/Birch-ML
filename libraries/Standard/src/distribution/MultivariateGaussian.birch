/**
 * Multivariate Gaussian distribution.
 *
 * !!! note
 *     See Gaussian for associated factory functions for the creation of
 *     MultivariateGaussian objects.
 */
class MultivariateGaussian(μ:Expression<Real[_]>, Σ:Expression<Real[_,_]>) <
    Distribution<Real[_]> {
  /**
   * Mean.
   */
  μ:Expression<Real[_]> <- μ;
  
  /**
   * Covariance.
   */
  Σ:Expression<Real[_,_]> <- Σ;

  function rows() -> Integer {
    return μ.rows();
  }

  function supportsLazy() -> Boolean {
    return true;
  }

  function simulate() -> Real[_] {
    return simulate_multivariate_gaussian(μ.value(), Σ.value());
  }

  function simulateLazy() -> Real[_]? {
    return simulate_multivariate_gaussian(μ.eval(), Σ.eval());
  }
  
  function logpdf(x:Real[_]) -> Real {
    return logpdf_multivariate_gaussian(x, μ.value(), Σ.value());
  }

  function logpdfLazy(x:Expression<Real[_]>) -> Expression<Real>? {
    return logpdf_lazy_multivariate_gaussian(x, μ, Σ);
  }

  function graftMultivariateGaussian() -> MultivariateGaussian? {
    prune();
    return this;
  }

  function write(buffer:Buffer) {
    prune();
    buffer.set("class", "MultivariateGaussian");
    buffer.set("μ", μ);
    buffer.set("Σ", Σ);
  }
}

/**
 * Create multivariate Gaussian distribution.
 */
function MultivariateGaussian<Left,Right>(μ:Left, Σ:Right) -> {
  return construct<MultivariateGaussian>(box(μ), box(Σ));
}

/**
 * Create multivariate Gaussian distribution.
 */
function MultivariateGaussian<Left,Middle,Right>(μ:Random<Real[_]>, Σ:Right) -> Distribution<Real[_]> {
  let p <- μ.graftMultivariateGaussian();
  if p? {
    return MultivariateGaussianMultivariateGaussian(p!, Σ);
  } else {
    return construct<MultivariateGaussian>(μ, box(Σ));
  }
}

/**
 * Create multivariate Gaussian distribution.
 */
function MultivariateGaussian<Left,Middle,Right>(μ:MultiplyAdd<Left,Random<Real[_]>,Middle>, Σ:Right) -> Distribution<Real[_]> {
  let p <- μ.m!.graftMultivariateGaussian();
  if p? {
    return LinearMultivariateGaussianMultivariateGaussian(μ.l!, p!, μ.r!, Σ);
  } else {
    return construct<MultivariateGaussian>(box(μ), box(Σ));
  }
}

/**
 * Create multivariate Gaussian distribution.
 */
function MultivariateGaussian<Left,Middle,Right>(μ:DotAdd<Left,Random<Real[_]>,Middle>, σ2:Right) -> Distribution<Real> {
  let p <- μ.m!.graftMultivariateGaussian();
  if p? {
    return LinearMultivariateGaussianGaussian(μ.l!, p!, μ.r!, σ2);
  } else {
    return construct<Gaussian>(box(μ), box(σ2));
  }
}

/**
 * Create multivariate Gaussian distribution.
 */
function MultivariateGaussian<Left,Right>(μ:Left, Σ:Multiply<Right,Random<Real>>) -> Distribution<Real[_]> {
  s2:InverseGamma?;
  if (s2 <- Σ.r!.graftInverseGamma())? {
    return MultivariateNormalInverseGamma(μ, Σ.l!, s2!);
  } else {
    return construct<MultivariateGaussian>(box(μ), box(Σ));
  }
}

/**
 * Create multivariate Gaussian distribution.
 */
function MultivariateGaussian<Left,Right>(μ:Left, Σ:Multiply<Random<Real>,Right>) -> Distribution<Real[_]> {
  s2:InverseGamma?;
  if (s2 <- Σ.l!.graftInverseGamma())? {
    return MultivariateNormalInverseGamma(μ, Σ.r!, s2!);
  } else {
    return construct<MultivariateGaussian>(box(μ), box(Σ));
  }
}

/**
 * Create multivariate Gaussian distribution.
 */
function MultivariateGaussian<Right>(μ:Random<Real[_]>, Σ:Multiply<Right,Random<Real>>) -> Distribution<Real[_]> {
  let p <- Σ.r!.graftInverseGamma();
  if p? {
    let q <- μ.graftMultivariateNormalInverseGamma(p!);
    if q? {
      return MultivariateNormalInverseGammaMultivariateGaussian(q!);
    } else {
      return MultivariateNormalInverseGamma(μ, Σ.l!, p!);
    }
  } else {
    return construct<MultivariateGaussian>(box(μ), box(Σ));
  }
}

/**
 * Create multivariate Gaussian distribution.
 */
function MultivariateGaussian<Right>(μ:Random<Real[_]>, Σ:Multiply<Random<Real>,Right>) -> Distribution<Real[_]> {
  let p <- Σ.r!.graftInverseGamma();
  if p? {
    let q <- μ.graftMultivariateNormalInverseGamma(p!);
    if q? {
      return MultivariateNormalInverseGammaMultivariateGaussian(q!);
    } else {
      return MultivariateNormalInverseGamma(μ, Σ.r!, p!);
    }
  } else {
    return construct<MultivariateGaussian>(box(μ), box(Σ));
  }
}

/**
 * Create multivariate Gaussian distribution.
 */
function MultivariateGaussian<Left,Middle,Right>(μ:MultiplyAdd<Left,Random<Real[_]>,Middle>, Σ:Multiply<Right,Random<Real>>) -> Distribution<Real[_]> {
  let p <- Σ.r!.graftInverseGamma();
  if p? {
    let q <- μ.m!.graftMultivariateNormalInverseGamma(p!);
    if q? {
      return LinearMultivariateNormalInverseGammaMultivariateGaussian(μ.l!, q!, μ.r!);
    } else {
      return MultivariateNormalInverseGamma(μ, Σ.l!, p!);
    }
  } else {
    return construct<MultivariateGaussian>(box(μ), box(Σ));
  }
}

/**
 * Create multivariate Gaussian distribution.
 */
function MultivariateGaussian<Left,Middle,Right>(μ:MultiplyAdd<Left,Random<Real[_]>,Middle>, Σ:Multiply<Random<Real>,Right>) -> Distribution<Real[_]> {
  let p <- Σ.l!.graftInverseGamma();
  if p? {
    let q <- μ.m!.graftMultivariateNormalInverseGamma(p!);
    if q? {
      return LinearMultivariateNormalInverseGammaMultivariateGaussian(μ.l!, q!, μ.r!);
    } else {
      return MultivariateNormalInverseGamma(μ, Σ.r!, p!);
    }
  } else {
    return construct<MultivariateGaussian>(box(μ), box(Σ));
  }
}

/**
 * Create multivariate Gaussian distribution.
 */
function MultivariateGaussian<Left,Middle>(μ:DotAdd<Left,Random<Real[_,_]>,Middle>, Σ:Random<Real[_,_]>) -> Distribution<Real[_]> {
  let p <- Σ.graftInverseWishart();
  if p? {
    let q <- μ.m!.graftMatrixNormalInverseWishart(p!);
    if q? {
      return LinearMatrixNormalInverseWishartMultivariateGaussian(μ.l!, q!, μ.r!);
    }
  }
  return construct<MultivariateGaussian>(box(μ), Σ);
}
