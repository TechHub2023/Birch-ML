/**
 * Inverse-gamma-gamma distribution.
 */
final class InverseGammaGamma(k:Expression<Real>, θ:InverseGamma) <
    Distribution<Real> {
  /**
   * Shape.
   */
  k:Expression<Real> <- k;

  /**
   * Scale.
   */
  θ:InverseGamma <- θ;

  function supportsLazy() -> Boolean {
    return true;
  }

  function simulate() -> Real {
    return simulate_inverse_gamma_gamma(k.value(), θ.α.value(), θ.β.value());
  }

  function simulateLazy() -> Real? {
    return simulate_inverse_gamma_gamma(k.peak(), θ.α.peak(), θ.β.peak());
  }

  function logpdf(x:Real) -> Real {
    return logpdf_inverse_gamma_gamma(x, k.value(), θ.α.value(), θ.β.value());
  }

  function logpdfLazy(x:Expression<Real>) -> Expression<Real>? {
    return logpdf_lazy_inverse_gamma_gamma(x, k, θ.α, θ.β);
  }

  function update(x:Real) {
    (θ.α, θ.β) <- box(update_inverse_gamma_gamma(x, k.value(), θ.α.value(), θ.β.value()));
  }

  function updateLazy(x:Expression<Real>) {
    (θ.α, θ.β) <- update_lazy_inverse_gamma_gamma(x, k, θ.α, θ.β);
  }

  function cdf(x:Real) -> Real? {
    return cdf_inverse_gamma_gamma(x, k.value(), θ.α.value(), θ.β.value());
  }

  function lower() -> Real? {
    return 0.0;
  }

  function link() {
    θ.setChild(this);
  }
  
  function unlink() {
    θ.releaseChild(this);
  }
}

function InverseGammaGamma<Left>(k:Left, θ:InverseGamma) -> {
  m:InverseGammaGamma(box(k), θ);
  m.link();
  return m;
}

/**
 * Create gamma distribution.
 */
function Gamma<Left>(k:Left, θ:Random<Real>) -> Distribution<Real> {
  θ1:InverseGamma?;
  if (θ1 <- θ.graftInverseGamma())? {
    return InverseGammaGamma(k, θ1!);
  } else {
    return construct<Gamma>(box(k), θ);
  }
}

/*
 * Simulate a compound-gamma distribution.
 *
 * - k: Shape.
 * - α: Shape.
 * - β: Scale.
 *
 */
function simulate_inverse_gamma_gamma(k:Real, α:Real, β:Real) -> Real {
  return simulate_gamma(k, simulate_inverse_gamma(α, β));
}

/*
 * Observe a compound-gamma variate.
 *
 * - x: The variate.
 * - k: Shape.
 * - α: Prior shape.
 * - β: Prior scale.
 *
 * Return: the log probability density.
 */
function logpdf_inverse_gamma_gamma(x:Real, k:Real, α:Real, β:Real) -> Real {
  assert 0.0 < k;
  assert 0.0 < α;
  assert 0.0 < β;
  return if_then_else(x < 0.0, -inf, (k - 1)*log(x) + α*log(β) -
      (α + k)*log(β + x) - lbeta(α, k));
}

/*
 * Observe a compound-gamma variate.
 *
 * - x: The variate.
 * - k: Shape.
 * - α: Prior shape.
 * - β: Prior scale.
 *
 * Return: the log probability density.
 */
function logpdf_lazy_inverse_gamma_gamma(x:Expression<Real>, k:Expression<Real>, α:Expression<Real>, β:Expression<Real>) -> Expression<Real> {
  return box((k - 1)*log(x) + α*log(β) - (α + k)*log(β + x) - lbeta(α, k));
}

/*
 * Update the parameters of an inverse-gamma distribution with a
 * gamma likelihood.
 *
 * - x: The variate.
 * - k: Shape of the gamma.
 * - α: Prior shape of the inverse-gamma.
 * - β: Prior scale of the inverse-gamma.
 *
 * Returns: the posterior hyperparameters `α'` and `β'`.
 */
function update_inverse_gamma_gamma(x:Real, k:Real, α:Real, β:Real) ->
    (Real, Real) {
  return (α + k, β + x);
}

/*
 * Update the parameters of an inverse-gamma distribution with a
 * gamma likelihood.
 *
 * - x: The variate.
 * - k: Shape of the gamma.
 * - α: Prior shape of the inverse-gamma.
 * - β: Prior scale of the inverse-gamma.
 *
 * Returns: the posterior hyperparameters `α'` and `β'`.
 */
function update_lazy_inverse_gamma_gamma(x:Expression<Real>,
    k:Expression<Real>, α:Expression<Real>, β:Expression<Real>) ->
    (Expression<Real>, Expression<Real>) {
  return (box(α + k), box(β + x));
}

/*
 * CDF of a compound-gamma variate.
 *
 * - x: The variate.
 * - k: The shape.
 * - α: The prior shape.
 * - β: The prior scale.
 *
 * Return: the cumulative probability.
 */
function cdf_inverse_gamma_gamma(x:Real, k:Real, α:Real, β:Real) -> Real {
  if x <= 0.0 {
    return 0.0;
  } else {
    return ibeta(k, α, x/(β + x));
  }
}
