/**
 * Distribution with delayed-sampling support.
 *
 * - Value: Value type.
 */
abstract class Distribution<Value> < Delay {
  /**
   * Are lazy operations supported?
   */
  function supportsLazy() -> Boolean {
    return false;
  }
  
  /**
   * Simulate a value.
   *
   * Return: the value.
   */
  abstract function simulate() -> Value!;

  /**
   * Simulate a value for a lazy expression.
   *
   * Return: the value, if supported.
   */
  function simulateLazy() -> Value!? {
    return nil;
  }

  /**
   * Evaluate the log probability density (or mass) function.
   *
   * - x: The value.
   *
   * Return: the log probability density (or mass).
   */
  abstract function logpdf(x:Value!) -> Real!;

  /**
   * Evaluate the log probability density (or mass) function for a lazy
     expression.
   *
   * - x: The value.
   *
   * Return: the log probability density (or mass), if supported.
   */
  function logpdfLazy(x:Value!) -> Real!? {
    return nil;
  }

  /**
   * Construct a lazy expression for the log probability density (or mass).
   *
   * - x: The value.
   *
   * Return: expression giving the log probability density (or mass), if
   * supported.
   */
  function hitch(x:Expression<Value>) -> Expression<Real>? {
    return nil;
  }

  /**
   * Update the parent node on the $M$-path given the value of this node.
   *
   * - x: The value.
   */
  function update(x:Value!) -> Delay? {
    return nil;
  }

  /**
   * Update the parent node on the $M$-path given the value of this node.
   *
   * - x: The value.
   */
  function updateLazy(x:Expression<Value>) -> Delay? {
    return nil;
  }

  /**
   * Evaluate the probability density (or mass) function.
   *
   * - x: The value.
   *
   * Return: the probability density (or mass).
   */
  function pdf(x:Value!) -> Real! {
    return exp(logpdf(x));
  }

  /**
   * Evaluate the cumulative distribution function at a value.
   *
   * - x: The value.
   *
   * Return: the cumulative probability, if supported.
   */
  function cdf(x:Value!) -> Real!? {
    return nil;
  }

  /**
   * Evaluate the quantile function at a cumulative probability.
   *
   * - P: The cumulative probability.
   *
   * Return: the quantile, if supported.
   */
  function quantile(P:Real!) -> Value!? {
    return nil;
  }
  
  /**
   * Finite lower bound of the support of this node, if any.
   */
  function lower() -> Value!? {
    return nil;
  }
  
  /**
   * Finite upper bound of the support of this node, if any.
   */
  function upper() -> Value!? {
    return nil;
  }

  override function prune() -> Delay {
    if this.hasNext() {
      let x <- Expression<Value>?(this.getNext().prune());
      assert x?;
      return handle_prune(this, x!);
    } else {
      return this;
    }
  }

  override function hoist() -> Expression<Real>? {
    let x <- Expression<Value>?(this.getNext());
    assert x?;
    return hitch(x!);
  }

  function isGaussian() -> Boolean {
    return false;
  }

  function getGaussian() -> (Expression<Real>, Expression<Real>)? {
    return nil;
  }

  function isBeta() -> Boolean {
    return false;
  }

  function getBeta() -> (Expression<Real>, Expression<Real>)? {
    return nil;
  }

  function isGamma() -> Boolean {
    return false;
  }

  function getGamma() -> (Expression<Real>, Expression<Real>)? {
    return nil;
  }

  function isInverseGamma() -> Boolean {
    return false;
  } 

  function getInverseGamma() -> (Expression<Real>, Expression<Real>)? {
    return nil;
  }

  function isInverseWishart() -> Boolean {
    return false;
  } 

  function getInverseWishart() -> (Expression<Real[_,_]>, Expression<Real>)? {
    return nil;
  } 

  function isNormalInverseGamma() -> Boolean {
    return false;
  }

  function getNormalInverseGamma() -> (Expression<Real>, Expression<Real>,
      Expression<Real>, Expression<Real>)? {
    return nil;
  }

  function isDirichlet() -> Boolean {
    return false;
  }

  function getDirichlet() -> Expression<Real[_]>? {
    return nil;
  }

  function isRestaurant() -> Boolean {
    return false;
  }

  function getRestaurant() -> (Expression<Real>, Expression<Real>,
      Expression<Integer[_]>)? {
    return nil;
  }

  function isMultivariateGaussian() -> Boolean {
    return false;
  }

  function getMultivariateGaussian() -> (Expression<Real[_]>,
      Expression<Real[_,_]>)? {
    return nil;
  }

  function isMultivariateNormalInverseGamma() -> Boolean {
    return false;
  }

  function getMultivariateNormalInverseGamma() -> (Expression<Real[_]>,
      Expression<Real[_,_]>, Expression<Real>, Expression<Real>)? {
    return nil;
  }

  function isMultivariateNormalInverseWishart() -> Boolean {
    return false;
  }

  function getMultivariateNormalInverseWishart() -> (Expression<Real[_]>,
      Expression<Real>, Expression<Real[_,_]>, Expression<Real>)? {
    return nil;
  }

  function isMatrixGaussian() -> Boolean {
    return false;
  }

  function getMatrixGaussian() -> (Expression<Real[_,_]>,
      Expression<Real[_,_]>, Expression<Real[_,_]>)? {
    return nil;
  }

  function isMatrixNormalInverseWishart() -> Boolean {
    return false;
  }

  function getMatrixNormalInverseWishart() -> (Expression<Real[_,_]>,
      Expression<Real[_,_]>, Expression<Real[_,_]>, Expression<Real>)? {
    return nil;
  }

  function isDiscrete() -> Boolean {
    return false;
  }

  function getDiscrete() -> DiscreteDistribution? {
    return nil;
  }

  function isBoundedDiscrete() -> Boolean {
    return false;
  }

  function getBoundedDiscrete() -> BoundedDiscreteDistribution? {
    return nil;
  }
}
