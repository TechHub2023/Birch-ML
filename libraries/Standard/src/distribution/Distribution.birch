/**
 * Distribution with delayed-sampling support.
 *
 * - Value: Value type.
 */
abstract class Distribution<Value> < Delay {
  /**
   * Is this a subordinate in a joint distribution?
   */
  subordinate:Boolean <- false;

  /**
   * Are lazy operations supported?
   */
  function supportsLazy() -> Boolean {
    return false;
  }

  /**
   * Are join operations supported?
   */
  function supportsJoin() -> Boolean {
    return false;
  }
  
  /**
   * Simulate a value.
   *
   * Return: the value.
   */
  abstract function simulate() -> Value!;

  /**
   * Simulate a value for a lazy expression.
   *
   * Return: the value, if supported.
   */
  function simulateLazy() -> Value!? {
    return nil;
  }

  /**
   * Evaluate the log probability density (or mass) function.
   *
   * - x: The value.
   *
   * Return: the log probability density (or mass).
   */
  abstract function logpdf(x:Value!) -> Real!;

  /**
   * Evaluate the log probability density (or mass) function using lazy
   * expressions.
   *
   * - x: The value.
   *
   * Return: the log probability density (or mass), if supported.
   */
  function logpdfLazy(x:Value!) -> Real!? {
    return nil;
  }

  /**
   * Evaluate the log probability density (or mass) function using lazy
   * expressions, for the joint distribution of this and any distributions
   * joined with it.
   *
   * - x: The value.
   *
   * Return: expression giving the log probability density (or mass), if
   * supported.
   */
  function logpdfJoin(x:Expression<Value>) -> Expression<Real>? {
    return nil;
  }

  /**
   * Update the parent node on the $M$-path given the value of this node.
   *
   * - x: The value.
   */
  function update(x:Value!) -> Delay? {
    return nil;
  }

  /**
   * Update the parent node on the $M$-path given the value of this node,
   * using lazy expressions.
   *
   * - x: The value.
   */
  function updateLazy(x:Expression<Value>) -> Delay? {
    return nil;
  }

  /**
   * Update the parent node on the $M$-path given the value of this node,
   * using lazy expressions, while propagating any other distributions joined
   * with this.
   *
   * - x: The value.
   */
  function updateJoin(x:Expression<Value>) -> Delay? {
    return nil;
  }

  /**
   * Evaluate the probability density (or mass) function.
   *
   * - x: The value.
   *
   * Return: the probability density (or mass).
   */
  function pdf(x:Value!) -> Real! {
    return exp(logpdf(x));
  }

  /**
   * Evaluate the cumulative distribution function at a value.
   *
   * - x: The value.
   *
   * Return: the cumulative probability, if supported.
   */
  function cdf(x:Value!) -> Real!? {
    return nil;
  }

  /**
   * Evaluate the quantile function at a cumulative probability.
   *
   * - P: The cumulative probability.
   *
   * Return: the quantile, if supported.
   */
  function quantile(P:Real!) -> Value!? {
    return nil;
  }
  
  /**
   * Finite lower bound of the support of this node, if any.
   */
  function lower() -> Value!? {
    return nil;
  }
  
  /**
   * Finite upper bound of the support of this node, if any.
   */
  function upper() -> Value!? {
    return nil;
  }

  override function constant() {
    if this.hasSide() {
      this.getSide().constant();
      this.setSide(nil);
    }
  }

  final override function prune() -> Delay {
    if this.hasNext() {
      let x <- Expression<Value>?(this.getNext().prune());
      assert x?;
      return handle_prune(this, x!);
    } else {
      return this;
    }
  }

  final override function hoist() -> Expression<Real>? {
    let x <- Expression<Value>?(this.getNext());
    assert x?;
    return logpdfJoin(x!);
  }

  final override function isDistribution() -> Boolean {
    return true;
  }

  final override function isSubordinate() -> Boolean {
    return subordinate;
  }

  final override function setSubordinate() {
    subordinate <- true;
  }
}
