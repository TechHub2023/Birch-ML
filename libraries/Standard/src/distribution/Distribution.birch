/**
 * Distribution with delayed-sampling support.
 *
 * @param Value Value type.
 */
abstract class Distribution<Value> < Delay {
  /**
   * Variate.
   */
  x:Value!?;

  /**
   * Are lazy operations supported?
   */
  function supportsLazy() -> Boolean {
    return false;
  }

  /**
   * Are join operations supported?
   */
  function supportsJoin() -> Boolean {
    return false;
  }
  
  /**
   * Simulate a value.
   *
   * @return the value.
   */
  abstract function simulate() -> Value!;

  /**
   * Simulate a value using lazy expressions.
   *
   * @return the value, if supported.
   */
  function simulateLazy() -> Value!? {
    return nil;
  }

  /**
   * Evaluate the log probability density (or mass) function.
   *
   * @param x The value.
   *
   * @return the log probability density (or mass).
   */
  abstract function logpdf(x:Value!) -> Real!;

  /**
   * Evaluate the log probability density (or mass) function using lazy
   * expressions.
   *
   * @param x The value.
   *
   * @return the log probability density (or mass), if supported.
   */
  function logpdfLazy(x:Value!) -> Real!? {
    return nil;
  }

  /**
   * Evaluate an update for the parent node on the $M$-path given the value
   * of this node.
   */
  final function update() -> Delay? {
    assert x?;
    return update(x!);
  }

  /**
   * Evaluate an update for the parent node on the $M$-path given a value.
   *
   * @param x The value.
   */
  function update(x:Value!) -> Delay? {
    return nil;
  }

  /**
   * Evaluate an update for the parent node on the $M$-path given the value
   * of this node, using lazy expressions.
   */
  final function updateLazy() -> Delay? {
    assert x?;
    return updateLazy(wrap_dist(this));
  }

  /**
   * Evaluate an update for the parent node on the $M$-path given a value,
   * using lazy expressions.
   *
   * @param x The value.
   */
  function updateLazy(x:Expression<Value>) -> Delay? {
    return nil;
  }

  /**
   * Evaluate an update for the parent node on the $M$-path given the value of
   * this node, using lazy expressions and joins.
   */
  final function updateJoin() -> Delay? {
    return updateJoin(wrap_dist(this));
  }

  /**
   * Evaluate an update for the parent node on the $M$-path given a value,
   * using lazy expressions and joins.
   *
   * @param x The value.
   */
  function updateJoin(x:Expression<Value>) -> Delay? {
    return nil;
  }

  /**
   * Evaluate the probability density (or mass) function.
   *
   * @param x The value.
   *
   * @return the probability density (or mass).
   */
  function pdf(x:Value!) -> Real! {
    return exp(logpdf(x));
  }

  /**
   * Evaluate the cumulative distribution function at a value.
   *
   * @param x The value.
   *
   * @return the cumulative probability, if supported.
   */
  function cdf(x:Value!) -> Real!? {
    return nil;
  }

  /**
   * Evaluate the quantile function at a cumulative probability.
   *
   * @param P The cumulative probability.
   *
   * @return the quantile, if supported.
   */
  function quantile(P:Real!) -> Value!? {
    return nil;
  }
  
  /**
   * Finite lower bound of the support of this node, if any.
   */
  function lower() -> Value!? {
    return nil;
  }
  
  /**
   * Finite upper bound of the support of this node, if any.
   */
  function upper() -> Value!? {
    return nil;
  }

  function realize() {
    this.x <- get_handler().simulate(this);
    if side? {
      side!.subordinate <- true;
    }
  }

  function assign(x:Value!) {
    this.x <- x;
    get_handler().observe(this, x);
    if side? {
      side!.subordinate <- true;
    }
  }

  function prune() -> Delay {
    let q <- this;
    if q.updated? {
      q <- Distribution<Value>?(q.updated!)!;
    }
    if q.next? {
      q <- Distribution<Value>?(q.next!.prune())!;
    }
    this.x <- get_handler().simulate(q);
    return get_handler().update(this);
    // @todo condition q rather than this when joint update required
  }

  function graft() -> Delay {
    let q <- this;
    if q.updated? {
      q <- Distribution<Value>?(q.updated!)!;
    }
    if q.next? {
      q <- Distribution<Value>?(q.next!.prune())!;
    }
    if q != this {
      updated <- q;
    }
    return q;
  }

  /**
   * Construct a lazy expression for the log-pdf of this node.
   */
  function hoist() -> Expression<Real>? {
    return nil;
  }

  function isGaussian() -> Boolean {
    return false;
  }

  function getGaussian() -> (Expression<Real>, Expression<Real>)? {
    return nil;
  }

  function isBeta() -> Boolean {
    return false;
  }

  function getBeta() -> (Expression<Real>, Expression<Real>)? {
    return nil;
  }

  function isGamma() -> Boolean {
    return false;
  }

  function getGamma() -> (Expression<Real>, Expression<Real>)? {
    return nil;
  }

  function isInverseGamma() -> Boolean {
    return false;
  } 

  function getInverseGamma() -> (Expression<Real>, Expression<Real>)? {
    return nil;
  }

  function isInverseWishart() -> Boolean {
    return false;
  } 

  function getInverseWishart() -> (Expression<Real[_,_]>, Expression<Real>)? {
    return nil;
  } 

  function isNormalInverseGamma() -> Boolean {
    return false;
  }

  function getNormalInverseGamma() -> (Expression<Real>, Expression<Real>,
      Expression<Real>, Expression<Real>)? {
    return nil;
  }

  function isDirichlet() -> Boolean {
    return false;
  }

  function getDirichlet() -> Expression<Real[_]>? {
    return nil;
  }

  function isRestaurant() -> Boolean {
    return false;
  }

  function getRestaurant() -> (Expression<Real>, Expression<Real>,
      Expression<Integer[_]>)? {
    return nil;
  }

  function isMultivariateGaussian() -> Boolean {
    return false;
  }

  function getMultivariateGaussian() -> (Expression<Real[_]>,
      Expression<Real[_,_]>)? {
    return nil;
  }

  function isMultivariateNormalInverseGamma() -> Boolean {
    return false;
  }

  function getMultivariateNormalInverseGamma() -> (Expression<Real[_]>,
      Expression<Real[_,_]>, Expression<Real>, Expression<Real>)? {
    return nil;
  }

  function isMultivariateNormalInverseWishart() -> Boolean {
    return false;
  }

  function getMultivariateNormalInverseWishart() -> (Expression<Real[_]>,
      Expression<Real>, Expression<Real[_,_]>, Expression<Real>)? {
    return nil;
  }

  function isMatrixGaussian() -> Boolean {
    return false;
  }

  function getMatrixGaussian() -> (Expression<Real[_,_]>,
      Expression<Real[_,_]>, Expression<Real[_,_]>)? {
    return nil;
  }

  function isMatrixNormalInverseWishart() -> Boolean {
    return false;
  }

  function getMatrixNormalInverseWishart() -> (Expression<Real[_,_]>,
      Expression<Real[_,_]>, Expression<Real[_,_]>, Expression<Real>)? {
    return nil;
  }

  function isDiscrete() -> Boolean {
    return false;
  }

  function getDiscrete() -> DiscreteDistribution? {
    return nil;
  }

  function isBoundedDiscrete() -> Boolean {
    return false;
  }

  function getBoundedDiscrete() -> BoundedDiscreteDistribution? {
    return nil;
  }

  function getMultivariateNormalInverseGammaGaussian() ->
      (Expression<Real[_]>, Expression<Real[_]>, Expression<Real[_,_]>,
      Expression<Real>, Expression<Real>, Expression<Real>,
      Expression<Real>)? {
    return nil;
  }

  function joinMultivariateNormalInverseGammaGaussian() ->
      (Expression<Real[_]>, Expression<Real[_,_]>, Expression<Real[_]>,
      Expression<Real[_,_]>, Expression<Real>, Expression<Real>,
      Expression<Real[_]>, Expression<Real[_]>)? {
    return nil;
  }

  function getMatrixNormalInverseWishartMultivariateGaussian(
      x:Expression<Real[_]>) -> (Expression<Real[_]>, Expression<Real[_]>,
      Expression<Real[_,_]>, Expression<Real[_,_]>, Expression<Real[_,_]>,
      Expression<Real>, Expression<Real>)? {
    return nil;
  }

  function joinMatrixNormalInverseWishartMultivariateGaussian() ->
      (Expression<Real[_,_]>, Expression<Real[_,_]>, Expression<Real[_,_]>,
      Expression<Real[_,_]>, Expression<Real[_,_]>, Expression<Real>,
      Expression<Real[_,_]>)? {
    return nil;
  }
}

/**
 * Create a Random from a Distribution.
 */
function wrap_dist<T>(p:T) -> Random<T.Value> {
  o:Random<T.Value>;
  o ~ p;
  return o;
}
