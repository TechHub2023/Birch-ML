/**
 * Distribution with delayed-sampling support.
 *
 * - Value: Value type.
 */
abstract class Distribution<Value> < Delay {
  /**
   * Are lazy operations supported?
   */
  function supportsLazy() -> Boolean {
    return false;
  }
  
  /**
   * Simulate a value.
   *
   * Return: the value.
   */
  abstract function simulate() -> Value!;

  /**
   * Simulate a value for a lazy expression.
   *
   * Return: the value, if supported.
   */
  function simulateLazy() -> Value!? {
    return nil;
  }

  /**
   * Evaluate the log probability density (or mass) function.
   *
   * - x: The value.
   *
   * Return: the log probability density (or mass).
   */
  abstract function logpdf(x:Value!) -> Real!;

  /**
   * Evaluate the log probability density (or mass) function for a lazy
     expression.
   *
   * - x: The value.
   *
   * Return: the log probability density (or mass), if supported.
   */
  function logpdfLazy(x:Value!) -> Real!? {
    return nil;
  }

  /**
   * Construct a lazy expression for the log probability density (or mass).
   *
   * - x: The value.
   *
   * Return: expression giving the log probability density (or mass), if
   * supported.
   */
  function hitch(x:Expression<Value>) -> Expression<Real>? {
    return nil;
  }

  /**
   * Update the parent node on the $M$-path given the value of this node.
   *
   * - x: The value.
   */
  function update(x:Value!) -> Delay? {
    return nil;
  }

  /**
   * Update the parent node on the $M$-path given the value of this node.
   *
   * - x: The value.
   */
  function updateLazy(x:Expression<Value>) -> Delay? {
    return nil;
  }

  /**
   * Evaluate the probability density (or mass) function.
   *
   * - x: The value.
   *
   * Return: the probability density (or mass).
   */
  function pdf(x:Value!) -> Real! {
    return exp(logpdf(x));
  }

  /**
   * Evaluate the cumulative distribution function at a value.
   *
   * - x: The value.
   *
   * Return: the cumulative probability, if supported.
   */
  function cdf(x:Value!) -> Real!? {
    return nil;
  }

  /**
   * Evaluate the quantile function at a cumulative probability.
   *
   * - P: The cumulative probability.
   *
   * Return: the quantile, if supported.
   */
  function quantile(P:Real!) -> Value!? {
    return nil;
  }
  
  /**
   * Finite lower bound of the support of this node, if any.
   */
  function lower() -> Value!? {
    return nil;
  }
  
  /**
   * Finite upper bound of the support of this node, if any.
   */
  function upper() -> Value!? {
    return nil;
  }

  final override function prune() -> Delay {
    if this.hasNext() {
      let x <- Expression<Value>?(this.getNext().prune());
      assert x?;
      return handle_prune(this, x!);
    } else {
      return this;
    }
  }

  final override function hoist() -> Expression<Real>? {
    let x <- Expression<Value>?(this.getNext());
    assert x?;
    return hitch(x!);
  }

  final override function isDistribution() -> Boolean {
    return true;
  }
}
