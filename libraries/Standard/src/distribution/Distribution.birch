/**
 * Distribution with delayed-sampling support.
 *
 * @param Value Value type.
 */
abstract class Distribution<Value> < Delay {
  /**
   * Variate
   */
  x:Value!?;

  /**
   * Offset into vectorized arguments.
   */
  offset:Integer <- -1;

  /**
   * Is the variate constant?
   */
  flagConstant:Boolean <- false;

  /**
   * Simulate a variate.
   *
   * @return the variate.
   */
  abstract function simulate() -> Value!;

  /**
   * Simulate a variate using lazy expressions.
   *
   * @return the variate, if supported.
   */
  abstract function simulateLazy() -> Value!;

  /**
   * Evaluate the log probability density (or mass) function at a given
   * position.
   *
   * @param x The position.
   *
   * @return the log probability density (or mass).
   */
  abstract function logpdf(x:Value!) -> Real!;

  /**
   * Evaluate the log probability density (or mass) function at a given
   * position, using lazy expressions.
   *
   * @param x The variate.
   *
   * @return the log probability density (or mass), if supported.
   */
  abstract function logpdfLazy(x:Value!) -> Real!;

  /**
   * For a compound distribution, evaluate the conditional distribution given
   * an observation.
   *
   * @param x The observation.
   */
  function update(x:Value!) -> Delay? {
    assert false;
    return nil;
  }

  /**
   * For a compound distribution, evaluate the conditional distribution given
   * an observation, using lazy expressions.
   *
   * @param x The observation.
   */
  function updateLazy(x:Random<Value>) -> Delay? {
    assert false;
    return nil;
  }

  /**
   * Evaluate the probability density (or mass) function at a given position.
   *
   * @param x The position.
   *
   * @return the probability density (or mass).
   */
  function pdf(x:Value!) -> Real! {
    return exp(logpdf(x));
  }

  /**
   * Evaluate the cumulative distribution function at a given position.
   *
   * @param x The position.
   *
   * @return the cumulative probability, if supported.
   */
  function cdf(x:Value!) -> Real!? {
    return nil;
  }

  /**
   * Evaluate the quantile function at a cumulative probability.
   *
   * @param P The cumulative probability.
   *
   * @return the quantile, if supported.
   */
  function quantile(P:Real!) -> Value!? {
    return nil;
  }
  
  /**
   * Finite lower bound of the support, if any.
   */
  function lower() -> Value!? {
    return nil;
  }
  
  /**
   * Finite upper bound of the support, if any.
   */
  function upper() -> Value!? {
    return nil;
  }

  final function random() -> Random<Value> {
    o:Random<Value>;
    o.setDistribution(this);
    return o;
  }

  final override function graft() -> Delay? {
    let p <- this;
    let p' <- this.getUpdated();
    if p'.hasMarginalized() {
      let q <- p'.getMarginalized();
      let q' <- q.graft()!;
      p'.setMarginalized(nil);
      q'.realize();

      let h <- get_handler();
      if h.autojoin && q.supportsJoin() {
        /* in this case, preserve the current updated distribution for this,
         * but join the marginalized distribution to it */
        p'.setJoined(q');
      } else {
        if p'.isSecondOrder() {
          /* in this case, q' is a joint distribution over the random variable
           * associated with this distribution and the parent distribution,
           * condition it to update the parent distribution */
          p' <- q'.condition()!;
        } else {
          /* in this case, q' is just over the random variable associated with
           * this distribution, condition the original distribution to update
           * the parent distribution */
          p' <- q.condition()!;
        }
        p.setUpdated(p');
      }
    }
    assert !p'.hasMarginalized();
    return p';
  }

  final function getUpdatedDistribution() -> Distribution<Value> {
    return Distribution<Value>?(super.getUpdated())!;
  }

  final override function condition() -> Delay? {
    let h <- get_handler();
    let p <- this.getUpdatedDistribution();
    if h.autodiff {
      return updateLazy(p.random());
    } else {
      return update(p.value());
    }
  }

  final override function realize() {
    if this.hasUpdated() {
      this.getUpdated().realize();
    } else if !this.x? {
      let h <- get_handler();
      if h.autodiff {
        h.Ξ.pushBack(this);
        this.x <- simulateLazy();
      } else {
        this.x <- simulate();
      }
      if this.hasJoined() {
        this.getJoined().setSubordinate(true);
      }
    }
  }

  final function assign(x:Value!) {
    if this.hasUpdated() {
      this.getUpdatedDistribution().assign(x);
    } else {
      assert !this.x?;
      let h <- get_handler();
      if h.autodiff {
        h.Ξ.pushBack(this);
        h.w <- h.w + logpdfLazy(x);
      } else {
        h.w <- h.w + logpdf(x);
      }
      if this.hasJoined() {
        this.getJoined().setSubordinate(true);
      }
      this.x <- x;
      constant();
    }
  }

  final function value() -> Value! {
    this.graft()!.realize();
    if this.hasUpdated() {
      return this.getUpdatedDistribution().value();
    } else {
      this.constant();
      return x!;
    }
  }

  final function eval() -> Value! {
    this.graft()!.realize();
    if this.hasUpdated() {
      return this.getUpdatedDistribution().eval();
    } else {
      return x!;
    }
  }

  final function peek() -> Value! {
    this.graft()!.realize();
    if this.hasUpdated() {
      return this.getUpdatedDistribution().peek();
    } else {
      return x!;
    }
  }

  final function move(visitor:MoveVisitor) -> Value! {
    if this.hasUpdated() {
      return this.getUpdatedDistribution().move(visitor);
    } else {
      visitor.visit(this);
      return x!;
    }
  }

  final function args(visitor:ArgsVisitor) {
    if this.hasUpdated() {
      this.getUpdatedDistribution().args(visitor);
    } else if offset >= 0 {
      visitor.visit(x!, offset);
    }
  }

  final function grad<Gradient>(g:Gradient, visitor:GradVisitor) {
    if this.hasUpdated() {
      this.getUpdatedDistribution().grad(g, visitor);
    } else if offset >= 0 {
      visitor.visit(g, offset);
    }
  }

  final function reset() {
    if this.hasUpdated() {
      this.getUpdatedDistribution().reset();
    } else {
      offset <- -1;
    }
  }

  final function relink(visitor:RelinkVisitor) {
    if this.hasUpdated() {
      this.getUpdatedDistribution().relink(visitor);
    } else {
      visitor.visit(this);
    }
  }

  final function constant() {
    if this.hasUpdated() {
      this.getUpdatedDistribution().constant();
    } else {
      flagConstant <- true;
    }
  }

  function fix() {
    flagConstant <- true;
  }

  final function isConstant() -> Boolean {
    if this.hasUpdated() {
      return this.getUpdatedDistribution().isConstant();
    } else {
      return flagConstant;
    }
  }

  final function hasValue() -> Boolean {
    if this.hasUpdated() {
      return this.getUpdatedDistribution().hasValue();
    } else {
      return x?;
    }
  }
}
