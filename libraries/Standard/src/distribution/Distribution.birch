/**
 * Distribution with delayed-sampling support.
 *
 * @param Value Value type.
 */
abstract class Distribution<Value> < Delay {
  /**
   * Stateful variate.
   */
  x:Value!?;

  /**
   * Simulate a variate.
   *
   * @return the variate.
   */
  abstract function simulate() -> Value!;

  /**
   * Simulate a variate using lazy expressions.
   *
   * @return the variate, if supported.
   */
  function simulateLazy() -> Value!? {
    return nil;
  }

  /**
   * Evaluate the log probability density (or mass) function at a given
   * position.
   *
   * @param x The position.
   *
   * @return the log probability density (or mass).
   */
  abstract function logpdf(x:Value!) -> Real!;

  /**
   * Evaluate the log probability density (or mass) function at a given
   * position, using lazy expressions.
   *
   * @param x The variate.
   *
   * @return the log probability density (or mass), if supported.
   */
  function logpdfLazy(x:Value!) -> Real!? {
    return nil;
  }

  /**
   * For a compound distribution, evaluate the conditional distribution given
   * an observation.
   *
   * @param x The observation.
   */
  function update(x:Value!) -> Delay? {
    return nil;
  }

  /**
   * For a compound distribution, evaluate the conditional distribution given
   * an observation, using lazy expressions.
   *
   * @param x The observation.
   */
  function updateLazy(x:Expression<Value>) -> Delay? {
    return nil;
  }

  /**
   * Evaluate the probability density (or mass) function at a given position.
   *
   * @param x The position.
   *
   * @return the probability density (or mass).
   */
  function pdf(x:Value!) -> Real! {
    return exp(logpdf(x));
  }

  /**
   * Evaluate the cumulative distribution function at a given position.
   *
   * @param x The position.
   *
   * @return the cumulative probability, if supported.
   */
  function cdf(x:Value!) -> Real!? {
    return nil;
  }

  /**
   * Evaluate the quantile function at a cumulative probability.
   *
   * @param P The cumulative probability.
   *
   * @return the quantile, if supported.
   */
  function quantile(P:Real!) -> Value!? {
    return nil;
  }
  
  /**
   * Finite lower bound of the support, if any.
   */
  function lower() -> Value!? {
    return nil;
  }
  
  /**
   * Finite upper bound of the support, if any.
   */
  function upper() -> Value!? {
    return nil;
  }

  /**
   * Does this have a stateful variate assigned?
   */
  final function hasVariate() -> Boolean {
    let p <- Distribution<Value>?(graft())!;
    return p.x?;
  }

  /**
   * Get the stateful variate.
   */
  final function variate() -> Value! {
    let p <- Distribution<Value>?(graft())!;
    p.realize();
    p.constant();
    return p.x!;
  }

  /**
   * Get the stateful variate, with lazy evaluation.
   */
  final function variateLazy() -> Value! {
    let p <- Distribution<Value>?(graft())!;
    p.realize();
    return p.x!;
  }

  /**
   * Get the stateful variate, boxed as a Random.
   */
  final function random() -> Random<Value> {
    let p <- Distribution<Value>?(graft())!;
    o:Random<Value>;
    o.setDistribution(p);
    return o;
  }

  /**
   * Assign the stateful variate.
   */
  final function assign(x:Value!) {
    let p <- Distribution<Value>?(graft())!;
    let h <- get_handler();
    if h.autodiff && p.supportsLazy() {
      h.Ξ.pushBack(p);
      h.w <- h.w + p.logpdfLazy(x)!;
    } else {
      h.w <- h.w + p.logpdf(x);
    }
    if p.hasJoined() {
      p.getJoined().setSubordinate(true);
    }
    p.x <- x;
  }

  final override function realize() {
    let p <- Distribution<Value>?(graft())!;
    if !p.x? {
      let h <- get_handler();
      if h.autodiff && p.supportsLazy() {
        h.Ξ.pushBack(p);
        p.x <- p.simulateLazy()!;
      } else {
        p.x <- p.simulate();
      }
      if p.hasJoined() {
        p.getJoined().setSubordinate(true);
      }
    }
  }

  final override function condition() -> Delay? {
    let h <- get_handler();
    if h.autodiff && supportsLazy() {
      return updateLazy(random());
    } else {
      return update(variate());
    }
  }

  override function constant() {
    if hasUpdated() {
      getUpdated().constant();
    }
  }

  override function hoist() -> Expression<Real>? {
    return nil;
  }

  override function supportsLazy() -> Boolean {
    return false;
  }

  override function supportsJoin() -> Boolean {
    return false;
  }

  override function isSecondOrder() -> Boolean {
    return false;
  }

  function isGaussian() -> Boolean {
    return false;
  }

  function getGaussian() -> (Expression<Real>, Expression<Real>)? {
    return nil;
  }

  function isBeta() -> Boolean {
    return false;
  }

  function getBeta() -> (Expression<Real>, Expression<Real>)? {
    return nil;
  }

  function isGamma() -> Boolean {
    return false;
  }

  function getGamma() -> (Expression<Real>, Expression<Real>)? {
    return nil;
  }

  function isInverseGamma() -> Boolean {
    return false;
  } 

  function getInverseGamma() -> (Expression<Real>, Expression<Real>)? {
    return nil;
  }

  function isInverseWishart() -> Boolean {
    return false;
  } 

  function getInverseWishart() -> (Expression<Real[_,_]>, Expression<Real>)? {
    return nil;
  } 

  function isNormalInverseGamma() -> Boolean {
    return false;
  }

  function getNormalInverseGamma() -> (Expression<Real>, Expression<Real>,
      Expression<Real>, Expression<Real>)? {
    return nil;
  }

  function isDirichlet() -> Boolean {
    return false;
  }

  function getDirichlet() -> Expression<Real[_]>? {
    return nil;
  }

  function isRestaurant() -> Boolean {
    return false;
  }

  function getRestaurant() -> (Expression<Real>, Expression<Real>,
      Expression<Integer[_]>)? {
    return nil;
  }

  function isMultivariateGaussian() -> Boolean {
    return false;
  }

  function getMultivariateGaussian() -> (Expression<Real[_]>,
      Expression<Real[_,_]>)? {
    return nil;
  }

  function isMultivariateNormalInverseGamma() -> Boolean {
    return false;
  }

  function getMultivariateNormalInverseGamma() -> (Expression<Real[_]>,
      Expression<Real[_,_]>, Expression<Real>, Expression<Real>)? {
    return nil;
  }

  function isMultivariateNormalInverseWishart() -> Boolean {
    return false;
  }

  function getMultivariateNormalInverseWishart() -> (Expression<Real[_]>,
      Expression<Real>, Expression<Real[_,_]>, Expression<Real>)? {
    return nil;
  }

  function isMatrixGaussian() -> Boolean {
    return false;
  }

  function getMatrixGaussian() -> (Expression<Real[_,_]>,
      Expression<Real[_,_]>, Expression<Real[_,_]>)? {
    return nil;
  }

  function isMatrixNormalInverseWishart() -> Boolean {
    return false;
  }

  function getMatrixNormalInverseWishart() -> (Expression<Real[_,_]>,
      Expression<Real[_,_]>, Expression<Real[_,_]>, Expression<Real>)? {
    return nil;
  }

  function isDiscrete() -> Boolean {
    return false;
  }

  function getDiscrete() -> DiscreteDistribution? {
    return nil;
  }

  function isBoundedDiscrete() -> Boolean {
    return false;
  }

  function getBoundedDiscrete() -> BoundedDiscreteDistribution? {
    return nil;
  }

  function getMultivariateNormalInverseGammaGaussian() ->
      (Expression<Real[_]>, Expression<Real[_]>, Expression<Real[_,_]>,
      Expression<Real>, Expression<Real>, Expression<Real>,
      Expression<Real>)? {
    return nil;
  }

  function joinMultivariateNormalInverseGammaGaussian() ->
      (Expression<Real[_]>, Expression<Real[_,_]>, Expression<Real[_]>,
      Expression<Real[_,_]>, Expression<Real>, Expression<Real>,
      Expression<Real[_]>, Expression<Real[_]>)? {
    return nil;
  }

  function getMatrixNormalInverseWishartMultivariateGaussian(
      x:Expression<Real[_]>) -> (Expression<Real[_]>, Expression<Real[_]>,
      Expression<Real[_,_]>, Expression<Real[_,_]>, Expression<Real[_,_]>,
      Expression<Real>, Expression<Real>)? {
    return nil;
  }

  function joinMatrixNormalInverseWishartMultivariateGaussian() ->
      (Expression<Real[_,_]>, Expression<Real[_,_]>, Expression<Real[_,_]>,
      Expression<Real[_,_]>, Expression<Real[_,_]>, Expression<Real>,
      Expression<Real[_,_]>)? {
    return nil;
  }
}
