/**
 * Distribution with delayed-sampling support.
 *
 * @param Value Value type.
 */
abstract class Distribution<Value> < Expression<Value>(nil, false) {
  /**
   * Offset into vectorized arguments.
   */
  offset:Integer <- 0;

  /**
   * Simulate a variate.
   *
   * @return the variate.
   */
  abstract function simulate() -> Value!;

  /**
   * Simulate a variate using lazy expressions.
   *
   * @return the variate, if supported.
   */
  abstract function simulateLazy() -> Value!;

  /**
   * Evaluate the log probability density (or mass) function at a given
   * position.
   *
   * @param x The position.
   *
   * @return the log probability density (or mass).
   */
  abstract function logpdf(x:Value!) -> Real!;

  /**
   * Evaluate the log probability density (or mass) function at a given
   * position, using lazy expressions.
   *
   * @param x The variate.
   *
   * @return the log probability density (or mass), if supported.
   */
  abstract function logpdfLazy(x:Value!) -> Real!;

  /**
   * For a compound distribution, evaluate the conditional distribution given
   * an observation.
   *
   * @param x The observation.
   */
  function update(x:Value!) -> Delay? {
    return nil;
  }

  /**
   * For a compound distribution, evaluate the conditional distribution given
   * an observation, using lazy expressions.
   *
   * @param x The observation.
   */
  function updateLazy(x:Expression<Value>) -> Delay? {
    return nil;
  }

  /**
   * Evaluate the probability density (or mass) function at a given position.
   *
   * @param x The position.
   *
   * @return the probability density (or mass).
   */
  function pdf(x:Value!) -> Real! {
    return exp(logpdf(x));
  }

  /**
   * Evaluate the cumulative distribution function at a given position.
   *
   * @param x The position.
   *
   * @return the cumulative probability, if supported.
   */
  function cdf(x:Value!) -> Real!? {
    return nil;
  }

  /**
   * Evaluate the quantile function at a cumulative probability.
   *
   * @param P The cumulative probability.
   *
   * @return the quantile, if supported.
   */
  function quantile(P:Real!) -> Value!? {
    return nil;
  }
  
  /**
   * Finite lower bound of the support, if any.
   */
  function lower() -> Value!? {
    return nil;
  }
  
  /**
   * Finite upper bound of the support, if any.
   */
  function upper() -> Value!? {
    return nil;
  }

  /**
   * Does this have a stateful variate assigned?
   */
  final function hasVariate() -> Boolean {
    let p <- Distribution<Value>?(this.graft())!;
    return p.x?;
  }

  /**
   * Get the stateful variate.
   */
  final function variate() -> Value! {
    let p <- Distribution<Value>?(this.graft())!;
    p.realize();
    p.constant();
    return p.x!;
  }

  /**
   * Get the stateful variate, with lazy evaluation.
   */
  final function variateLazy() -> Value! {
    let p <- Distribution<Value>?(this.graft())!;
    p.realize();
    return p.x!;
  }

  /**
   * Get the stateful variate, boxed as a Random.
   */
  final function random() -> Random<Value> {
    let p <- Distribution<Value>?(this.graft())!;
    o:Random<Value>;
    o.setDistribution(p);
    return o;
  }

  /**
   * Get this distribution.
   */
  final function self() -> Distribution<Value> {
    return Distribution<Value>?(this.graft())!;
  }

  /**
   * Assign the stateful variate.
   */
  final function assign(x:Value!) {
    let p <- Distribution<Value>?(this.graft())!;
    let h <- get_handler();
    if h.autodiff {
      h.Ξ.pushBack(p);
      h.w <- h.w + p.logpdfLazy(x);
    } else {
      h.w <- h.w + p.logpdf(x);
    }
    if p.hasJoined() {
      p.getJoined().setSubordinate(true);
    }
    p.x <- x;
  }

  final override function realize() {
    let p <- Distribution<Value>?(this.graft())!;
    if !p.x? {
      let h <- get_handler();
      if h.autodiff {
        h.Ξ.pushBack(p);
        p.x <- p.simulateLazy();
      } else {
        p.x <- p.simulate();
      }
      if p.hasJoined() {
        p.getJoined().setSubordinate(true);
      }
    }
    this.x <- p.x;   ///@todo possible that this == p
  }

  final override function condition() -> Delay? {
    let h <- get_handler();
    if h.autodiff {
      return updateLazy(random());
    } else {
      return update(variate());
    }
  }

  override function doEval() {
    realize();
  }

  override function doMove(visitor:MoveVisitor) {
    let p <- Distribution<Value>?(this.graft())!;
    visitor.visit(p);
    this.x <- p.x;   ///@todo possible that this == p
  }

  override function doArgs(visitor:ArgsVisitor) {
    let p <- Distribution<Value>?(this.graft())!;
    visitor.visit(p);
  }

  override function doShallowGrad(visitor:GradVisitor) {
    let p <- Distribution<Value>?(this.graft())!;
    visitor.visit(p);
  }

  override function doDeepGrad(visitor:GradVisitor) {
    //
  }

  override function doReset() {
    let p <- Distribution<Value>?(this.graft())!;
    p.offset <- 0;
  }

  override function doRelink(visitor:RelinkVisitor) {
    let p <- Distribution<Value>?(this.graft())!;
    visitor.visit(p);
  }

  override function doConstant() {
    //
  }
}
