/**
 * Distribution with delayed-sampling support.
 *
 * @param Value Value type.
 */
abstract class Distribution<Value> < Expression<Value>(nil, false) {
  /**
   * Offset into vectorized arguments.
   */
  offset:Integer <- 0;

  /**
   * Simulate a variate.
   *
   * @return the variate.
   */
  abstract function simulate() -> Value!;

  /**
   * Simulate a variate using lazy expressions.
   *
   * @return the variate, if supported.
   */
  abstract function simulateLazy() -> Value!;

  /**
   * Evaluate the log probability density (or mass) function at a given
   * position.
   *
   * @param x The position.
   *
   * @return the log probability density (or mass).
   */
  abstract function logpdf(x:Value!) -> Real!;

  /**
   * Evaluate the log probability density (or mass) function at a given
   * position, using lazy expressions.
   *
   * @param x The variate.
   *
   * @return the log probability density (or mass), if supported.
   */
  abstract function logpdfLazy(x:Value!) -> Real!;

  /**
   * For a compound distribution, evaluate the conditional distribution given
   * an observation.
   *
   * @param x The observation.
   */
  function update(x:Value!) -> Delay? {
    return nil;
  }

  /**
   * For a compound distribution, evaluate the conditional distribution given
   * an observation, using lazy expressions.
   *
   * @param x The observation.
   */
  function updateLazy(x:Random<Value>) -> Delay? {
    return nil;
  }

  /**
   * Evaluate the probability density (or mass) function at a given position.
   *
   * @param x The position.
   *
   * @return the probability density (or mass).
   */
  function pdf(x:Value!) -> Real! {
    return exp(logpdf(x));
  }

  /**
   * Evaluate the cumulative distribution function at a given position.
   *
   * @param x The position.
   *
   * @return the cumulative probability, if supported.
   */
  function cdf(x:Value!) -> Real!? {
    return nil;
  }

  /**
   * Evaluate the quantile function at a cumulative probability.
   *
   * @param P The cumulative probability.
   *
   * @return the quantile, if supported.
   */
  function quantile(P:Real!) -> Value!? {
    return nil;
  }
  
  /**
   * Finite lower bound of the support, if any.
   */
  function lower() -> Value!? {
    return nil;
  }
  
  /**
   * Finite upper bound of the support, if any.
   */
  function upper() -> Value!? {
    return nil;
  }

  /**
   * Does this have a stateful variate assigned?
   */
  final function hasVariate() -> Boolean {
    return this.x?;
  }

  /**
   * Get the stateful variate.
   */
  final function variate() -> Value! {
    realize();
    this.constant();
    return this.x!;
  }

  /**
   * Get the stateful variate, with lazy evaluation.
   */
  final function variateLazy() -> Value! {
    realize();
    return this.x!;
  }

  /**
   * Get the stateful variate, boxed as a Random.
   */
  final function random() -> Random<Value> {
    o:Random<Value>;
    o.setDistribution(this);
    return o;
  }

  /**
   * Assign the stateful variate.
   */
  final function assign(x:Value!) {
    let h <- get_handler();
    assert !this.x?;
    if h.autodiff {
      h.Ξ.pushBack(this);
      h.w <- h.w + logpdfLazy(x);
    } else {
      h.w <- h.w + logpdf(x);
    }
    if this.hasJoined() {
      this.getJoined().setSubordinate(true);
    }
    this.x <- x;
  }

  final override function realize() {
    if !this.x? {
      let h <- get_handler();
      if h.autodiff {
        h.Ξ.pushBack(this);
        this.x <- simulateLazy();
      } else {
        this.x <- simulate();
      }
      if this.hasJoined() {
        this.getJoined().setSubordinate(true);
      }
    }
  }

  final override function condition() -> Delay? {
    let h <- get_handler();
    let p <- Distribution<Value>?(this.getUpdated())!;
    if h.autodiff {
      return updateLazy(p.random());
    } else {
      return update(p.variate());
    }
  }

  override function doEval() {
    this.realize();
  }

  override function doMove(visitor:MoveVisitor) {
    visitor.visit(this);
  }

  override function doArgs(visitor:ArgsVisitor) {
    visitor.visit(this);
  }

  override function doShallowGrad(visitor:GradVisitor) {
    visitor.visit(this);
  }

  override function doDeepGrad(visitor:GradVisitor) {
    //
  }

  override function doReset() {
    offset <- 0;
  }

  override function doRelink(visitor:RelinkVisitor) {
    visitor.visit(this);
  }

  override function doConstant() {
    //
  }
}
