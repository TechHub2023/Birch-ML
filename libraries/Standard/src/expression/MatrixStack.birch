/**
 * Lazy matrix stack.
 */
final class MatrixStack(l:Expression<Real[_,_]>, r:Expression<Real[_,_]>) <
    MatrixBinaryExpression<Expression<Real[_,_]>,Expression<Real[_,_]>,
    Real[_,_]>(l, r) {  
  override function doRows() -> Integer {
    return l!.rows() + r!.rows();
  }
  
  override function doColumns() -> Integer {
    assert l!.columns() == r!.columns();
    return l!.columns();
  }

  override function doCompute() {
    x <- stack(l!.eval(), r!.eval());
  }

  override function doGrad(gen:Integer) {
    let r1 <- global.rows(l!.eval());
    let r2 <- global.rows(r!.eval());
    let c1 <- global.columns(l!.eval());
    l!.countGrad(gen, d![1..r1, 1..c1]);
    r!.countGrad(gen, d![(r1 + 1)..(r1 + r2), 1..c1]);
  }
}

/**
 * Lazy matrix stack.
 */
function stack(l:Expression<Real[_,_]>, r:Expression<Real[_,_]>) ->
    MatrixStack {
  assert l.columns() == r.columns();
  return construct<MatrixStack>(l, r);
}

/**
 * Lazy matrix stack.
 */
function stack(l:Real[_,_], r:Expression<Real[_,_]>) -> MatrixStack {
  return stack(box(l), r);
}

/**
 * Lazy matrix stack.
 */
function stack(l:Expression<Real[_,_]>, r:Real[_,_]) -> MatrixStack {
  return stack(l, box(r));
}
