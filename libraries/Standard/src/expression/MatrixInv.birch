/**
 * Lazy `inv`.
 */
final class MatrixInv<Argument,Value>(m:Argument) <
    MatrixUnaryExpression<Argument,Value>(m) {
  override function doRows() -> Integer {
    return global.rows(m!);
  }
  
  override function doColumns() -> Integer {
    return global.columns(m!);
  }

  override function doCompute() {
    x <- inv(global.eval(m!));
  }

  override function doGrad(gen:Integer) {
    let m1 <- canonical(transpose(global.eval(m!)));
    count_grad(m!, gen, -m1*d!*m1);
  }
}

/**
 * Lazy `inv`.
 */
function inv(m:Expression<Real[_,_]>) ->
    MatrixInv<Expression<Real[_,_]>,Real[_,_]> {
  return construct<MatrixInv<Expression<Real[_,_]>,Real[_,_]>>(m);
}

/**
 * Lazy `inv`.
 */
function inv(x:Expression<LLT>) -> MatrixInv<Expression<LLT>,LLT> {
  return construct<MatrixInv<Expression<LLT>,LLT>>(x);
}
