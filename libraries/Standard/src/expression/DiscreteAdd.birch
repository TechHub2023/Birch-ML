/**
 * Lazy add.
 */
final class DiscreteAdd(l:Expression<Integer>, r:Expression<Integer>) <
    ScalarBinaryExpression<Expression<Integer>,Expression<Integer>,Integer>(l, r) {  
  override function doCompute() {
    x <- l!.eval() + r!.eval();
  }

  override function doGrad(gen:Integer) {
    l!.countGrad(gen, d!);
    r!.countGrad(gen, d!);
  }

  override function graftDiscrete() -> Discrete? {
    t:Discrete?;
    if !hasValue() {
      t <- graftBoundedDiscrete();
      if !t? {
        x1:Discrete?;
        if (x1 <- l!.graftDiscrete())? {
          t <- LinearDiscrete(box(1), x1!, r!);
        } else if (x1 <- r!.graftDiscrete())? {
          t <- LinearDiscrete(box(1), x1!, l!);
        }
      }
    }
    return t;
  }

  override function graftBoundedDiscrete() -> BoundedDiscrete? {
    t:BoundedDiscrete?;
    if !hasValue() {
      let l1 <- l!.graftBoundedDiscrete();
      let r1 <- r!.graftBoundedDiscrete();
      if l1? && r1? {
        t <- AddBoundedDiscrete(l1!, r1!);
      } else if l1? {
        t <- LinearBoundedDiscrete(box(1), l1!, r!);
      } else if r1? {
        t <- LinearBoundedDiscrete(box(1), r1!, l!);
      }
    }
    return t;
  }
}

/**
 * Lazy add.
 */
operator (l:Expression<Integer> + r:Expression<Integer>) -> DiscreteAdd {
  return construct<DiscreteAdd>(l, r);
}

/**
 * Lazy add.
 */
operator (l:Integer + r:Expression<Integer>) -> DiscreteAdd {
  return box(l) + r;
}

/**
 * Lazy add.
 */
operator (l:Expression<Integer> + r:Integer) -> DiscreteAdd {
  return l + box(r);
}
