/**
 * Collect gradients from a delayed expression.
 *
 * @param size Number of arguments.
 */
final class GradVisitor(size:Integer) {
  /**
   * Vectorized gradients.
   */
  g:Real[size];

  function visit(p:Distribution<Real>) {
    assert p.offset >= 0;
    cpp{{
    this->g.slice(p->offset + 1) = p->g.value();
    }}
  }

  function visit(p:Distribution<Real[_]>) {
    assert p.offset >= 0;
    let m <- p.offset + 1;
    let n <- m + size(p.g!) - 1;
    this.g[m..n] <- p.g!;
  }

  function visit(p:Distribution<Real[_,_]>) {
    assert p.offset >= 0;
    let m <- p.offset + 1;
    let n <- m + size(p.g!) - 1;
    this.g[m..n] <- vec(p.g!);
  }

  function visit<Value>(p:Distribution<Value>) {
    // ignore
  }
}
