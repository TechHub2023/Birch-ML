/**
 * Collect gradients from a delayed expression.
 *
 * @param size Number of arguments.
 */
class GradVisitor(size:Integer) {
  /**
   * Vectorized gradients.
   */
  g:Real[size];

  function visit(p:Distribution<Real>) {
    let h <- p.g!;
    cpp{{
    g.slice(p->offset + 1) = h;
    }}
  }

  function visit(p:Distribution<Integer>) {
    //
  }

  function visit(p:Distribution<Boolean>) {
    //
  }

  function visit(p:Distribution<Real[_]>) {
    let m <- p.offset + 1;
    let n <- m + size(p.g!) - 1;
    g[m..n] <- p.g!;
  }

  function visit(p:Distribution<Integer[_]>) {
    //
  }

  function visit(p:Distribution<Real[_,_]>) {
    let m <- p.offset + 1;
    let n <- m + size(p.g!) - 1;
    g[m..n] <- vec(p.g!);
  }
}
