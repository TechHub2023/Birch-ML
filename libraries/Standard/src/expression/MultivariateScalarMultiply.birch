/**
 * Lazy multivariate multiply.
 */
final class MultivariateScalarMultiply(l:Expression<Real>,
    r:Expression<Real[_]>) < MultivariateBinaryExpression<Expression<Real>,
    Expression<Real[_]>,Real[_]>(l, r) {  
  override function doRows() -> Integer {
    return r!.rows();
  }

  override function doCompute() {
    x <- l!.eval()*r!.eval();
  }

  override function doGrad(gen:Integer) {
    l!.countGrad(gen, dot(d!, r!.eval()));
    r!.countGrad(gen, l!.eval()*d!);
  }

  override function graftLinearMultivariateGaussian() ->
      TransformLinearMultivariate<MultivariateGaussian>? {
    t:TransformLinearMultivariate<MultivariateGaussian>?;
    if !hasValue() {
      x1:MultivariateGaussian?;
    
      if (t <- r!.graftLinearMultivariateGaussian())? {
        t!.multiply(l!);
      } else if (x1 <- r!.graftMultivariateGaussian())? {
        t <- TransformLinearMultivariate<MultivariateGaussian>(diagonal(l!, r!.rows()), x1!);
      }
    }
    return t;
  }
  
  override function graftLinearMultivariateNormalInverseGamma(compare:Distribution<Real>) ->
      TransformLinearMultivariate<MultivariateNormalInverseGamma>? {
    t:TransformLinearMultivariate<MultivariateNormalInverseGamma>?;
    if !hasValue() {
      x1:MultivariateNormalInverseGamma?;

      if (t <- r!.graftLinearMultivariateNormalInverseGamma(compare))? {
        t!.multiply(l!);
      } else if (x1 <- r!.graftMultivariateNormalInverseGamma(compare))? {
        t <- TransformLinearMultivariate<MultivariateNormalInverseGamma>(diagonal(l!, r!.rows()), x1!);
      }
    }
    return t;
  }
}

/**
 * Lazy multivariate multiply.
 */
operator (l:Expression<Real>*r:Expression<Real[_]>) ->
    MultivariateScalarMultiply {
  return construct<MultivariateScalarMultiply>(l, r);
}

/**
 * Lazy multivariate multiply.
 */
operator (l:Real*r:Expression<Real[_]>) -> MultivariateScalarMultiply {
  return box(l)*r;
}

/**
 * Lazy multivariate multiply.
 */
operator (l:Expression<Real>*r:Real[_]) -> MultivariateScalarMultiply {
  return l*box(r);
}

/**
 * Lazy multivariate multiply.
 */
operator (l:Expression<Real[_]>*r:Expression<Real>) ->
    MultivariateScalarMultiply {
  return r*l;
}

/**
 * Lazy multivariate multiply.
 */
operator (l:Real[_]*r:Expression<Real>) -> MultivariateScalarMultiply {
  return r*l;
}

/**
 * Lazy multivariate multiply.
 */
operator (l:Expression<Real[_]>*r:Real) -> MultivariateScalarMultiply {
  return r*l;
}
