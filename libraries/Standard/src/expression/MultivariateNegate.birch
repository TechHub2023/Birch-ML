/**
 * Lazy negation.
 */
final class MultivariateNegate(m:Expression<Real[_]>) <
    MultivariateUnaryExpression<Expression<Real[_]>,Real[_]>(m) {
  override function doRows() -> Integer {
    return m!.rows();
  }
    
  override function doCompute() {
    x <- -m!.eval();
  }

  override function doGrad(gen:Integer) {
    m!.countGrad(gen, -d!);
  }

  override function graftLinearMultivariateGaussian() ->
      TransformLinearMultivariate<MultivariateGaussian>? {
    t:TransformLinearMultivariate<MultivariateGaussian>?;
    if !hasValue() {
      x1:MultivariateGaussian?;

      if (t <- m!.graftLinearMultivariateGaussian())? {
        t!.negate();
      } else if (x1 <- m!.graftMultivariateGaussian())? {
        let R <- x1!.rows();
        t <- TransformLinearMultivariate<MultivariateGaussian>(
            box(diagonal(-1.0, R)), x1!, box(vector(0.0, R)));
      }
    }
    return t;
  }
  
  override function graftLinearMultivariateNormalInverseGamma(compare:Distribution<Real>) ->
      TransformLinearMultivariate<MultivariateNormalInverseGamma>? {
    t:TransformLinearMultivariate<MultivariateNormalInverseGamma>?;
    if !hasValue() {
      x1:MultivariateNormalInverseGamma?;

      if (t <- m!.graftLinearMultivariateNormalInverseGamma(compare))? {
        t!.negate();
      } else if (x1 <- m!.graftMultivariateNormalInverseGamma(compare))? {
        let R <- x1!.rows();
        t <- TransformLinearMultivariate<MultivariateNormalInverseGamma>(
            box(diagonal(-1.0, R)), x1!, box(vector(0.0, R)));
      }
    }
    return t;
  }
}

/**
 * Lazy negation.
 */
operator (-m:Expression<Real[_]>) -> MultivariateNegate {
  return construct<MultivariateNegate>(m);
}
