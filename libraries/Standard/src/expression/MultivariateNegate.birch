/**
 * Lazy negation.
 */
final class MultivariateNegate(m:Expression<Real[_]>) <
    MultivariateUnaryExpression<Expression<Real[_]>,Real[_]>(m) {
  override function doRows() -> Integer {
    return global.rows(m!);
  }
    
  override function doCompute() {
    x <- -global.eval(m!);
  }

  override function doGrad(gen:Integer) {
    count_grad(m!, gen, -d!);
  }

  override function graftLinearMultivariateGaussian() ->
      TransformLinearMultivariate<MultivariateGaussian>? {
    t:TransformLinearMultivariate<MultivariateGaussian>?;
    if !hasValue() {
      x1:MultivariateGaussian?;

      if (t <- graft_linear_multivariate_gaussian(m!))? {
        t!.negate();
      } else if (x1 <- graft_multivariate_gaussian(m!))? {
        let R <- global.rows(x1!);
        t <- TransformLinearMultivariate<MultivariateGaussian>(
            box(diagonal(-1.0, R)), x1!, box(vector(0.0, R)));
      }
    }
    return t;
  }
  
  override function graftLinearMultivariateNormalInverseGamma(compare:Distribution<Real>) ->
      TransformLinearMultivariate<MultivariateNormalInverseGamma>? {
    t:TransformLinearMultivariate<MultivariateNormalInverseGamma>?;
    if !hasValue() {
      x1:MultivariateNormalInverseGamma?;

      if (t <- graft_linear_multivariate_normal_inverse_gamma(m!, compare))? {
        t!.negate();
      } else if (x1 <- graft_multivariate_normal_inverse_gamma(m!, compare))? {
        let R <- global.rows(x1!);
        t <- TransformLinearMultivariate<MultivariateNormalInverseGamma>(
            box(diagonal(-1.0, R)), x1!, box(vector(0.0, R)));
      }
    }
    return t;
  }
}

/**
 * Lazy negation.
 */
operator (-m:Expression<Real[_]>) -> MultivariateNegate {
  return construct<MultivariateNegate>(m);
}
