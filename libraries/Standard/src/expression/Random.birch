/**
 * Random variate.
 *
 * @param Value Value type.
 *
 * Random objects, like all [Expression](../../classes/Expression/) objects,
 * are stateful. Random objects in the pilot state are considered
 * *variables*, meaning that a call to `grad()` will compute gradients with
 * respect to them, and a further call to `move()` will apply a Markov kernel
 * to update their value. Random objects in the value state are considered
 * *constants*.
 */
class Random<Value> < Expression<Value>(nil, false) {
  /**
   * Distribution associated with the random variate.
   */
  p:Distribution<Value>?;

  /**
   * Value assignment.
   */
  operator <- x:Value! {
    this.set(x);
    if this.hasDistribution() {
      this.p!.assign(x);
    }
    this.constant();
  }

  /**
   * Value assignment.
   */
  function set(x:Value!) {
    assert !this.hasValue();
    this.x <- x;
    this.g <- nil;
  }

  /**
   * Does this have a distribution?
   */
  function hasDistribution() -> Boolean {
    return p?;
  }

  /**
   * Get the distribution.
   */
  function getDistribution() -> Distribution<Value> {
    assert p?;
    return Distribution<Value>?(p!.getUpdated())!;
  }

  /**
   * Set the distribution.
   */
  function setDistribution(p:Distribution<Value>) {
    assert !this.p?;
    this.p <- p;
  }

  /**
   * Does this have a marginalized distribution?
   */
  function hasMarginalized() -> Boolean {
    return hasDistribution() && p!.getUpdated().hasMarginalized();
  }

  /**
   * Get the marginalized distribution.
   */
  function getMarginalized() -> Delay {
    return p!.getUpdated().getMarginalized().getUpdated();
  }

  /**
   * Graft.
   */
  function graft() -> Delay {
    assert p?;
    return p!.graft();
  }

  function isGaussian() -> Boolean {
    return hasDistribution() && getDistribution().isGaussian();
  }

  function isBeta() -> Boolean {
    return hasDistribution() && getDistribution().isBeta();
  }

  function isGamma() -> Boolean {
    return hasDistribution() && getDistribution().isGamma();
  }

  function isInverseGamma() -> Boolean {
    return hasDistribution() && getDistribution().isInverseGamma();
  } 

  function isInverseWishart() -> Boolean {
    return hasDistribution() && getDistribution().isInverseWishart();
  } 

  function isNormalInverseGamma() -> Boolean {
    return hasDistribution() && getDistribution().isNormalInverseGamma();
  }

  function isDirichlet() -> Boolean {
    return hasDistribution() && getDistribution().isDirichlet();
  }

  function isRestaurant() -> Boolean {
    return hasDistribution() && getDistribution().isRestaurant();
  }

  function isMultivariateGaussian() -> Boolean {
    return hasDistribution() && getDistribution().isMultivariateGaussian();
  }

  function isMultivariateNormalInverseGamma() -> Boolean {
    return hasDistribution() && getDistribution().isMultivariateNormalInverseGamma();
  }

  function isMultivariateNormalInverseWishart() -> Boolean {
    return hasDistribution() && getDistribution().isMultivariateNormalInverseWishart();
  }

  function isMatrixGaussian() -> Boolean {
    return hasDistribution() && getDistribution().isMatrixGaussian();
  }

  function isMatrixNormalInverseWishart() -> Boolean {
    return hasDistribution() && getDistribution().isMatrixNormalInverseWishart();
  }

  function isDiscrete() -> Boolean {
    return hasDistribution() && getDistribution().isDiscrete();
  }

  function isBoundedDiscrete() -> Boolean {
    return hasDistribution() && getDistribution().isBoundedDiscrete();
  }

  override function doEval() {
    assert !this.x?;
    assert this.p?;
    this.p!.realize();
    this.x <- this.p!.x!;
    assert this.x?;
  }

  override function doMove(visitor:MoveVisitor) {
    assert this.x?;
    visitor.visit(this);
  }

  override function doArgs(visitor:ArgsVisitor) {
    visitor.visit(this);
  }

  override function read(buffer:Buffer) {
    this <-? buffer.get<Value>();
  }

  override function write(buffer:Buffer) {
    if this.hasValue() || this.hasDistribution() {
      buffer.set(this.value()!);
    } else {
      buffer.setNil();
    }
  }
}

/**
 * Create a Random.
 */
function make_random<Value>() -> Random<Value> {
  o:Random<Value>;
  return o;
}

/**
 * Box a value in a Random.
 *
 * @param x Value to assign.
 */
function make_random<Value>(x:Value) -> Random<Value> {
  o:Random<Value>;
  o <- x;
  return o;
}

/**
 * Box a value in a Random.
 *
 * @param x Value to assign.
 */
function make_random<Value>(x:Value?) -> Random<Value> {
  o:Random<Value>;
  o <-? x;
  return o;
}

/**
 * Box a value in a Random.
 *
 * @param x Value to assign.
 */
function make_random<Value>(x:Value!) -> Random<Value> {
  o:Random<Value>;
  o <- x;
  return o;
}

/**
 * Box a value in a Random.
 *
 * @param x Optional value to assign.
 */
function make_random<Value>(x:Value!?) -> Random<Value> {
  o:Random<Value>;
  if x? {
    o <- x!;
  }
  return o;
}

/**
 * Box a value in a Random (identity operation).
 *
 * @param x Existing object.
 */
function make_random<Value>(x:Random<Value>) -> Random<Value> {
  return x;
}
