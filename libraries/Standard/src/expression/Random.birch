/**
 * Random variate.
 *
 * - Value: Value type.
 *
 * Random objects, like all [Expression](../../classes/Expression/) objects,
 * are stateful. Random objects in the pilot state are considered
 * *variables*, meaning that a call to `grad()` will compute gradients with
 * respect to them, and a further call to `move()` will apply a Markov kernel
 * to update their value. Random objects in the value state are considered
 * *constants*.
 */
final class Random<Value> < Expression<Value> {  
  /**
   * Variate value, once realized.
   */
  x:Value?;

  /**
   * Associated distribution.
   */
  p:Distribution<Value>?;

  /**
   * Accumulated upstream gradient.
   */
  d:Value?;

  /**
   * Is this a constant?
   */
  flagConstant:Boolean <- false;

  /**
   * Value assignment.
   */
  operator <- x:Value {
    assert !this.p?;
    assert !this.x?;
    this.x <- x;
    constant();
  }

  override function isRandom() -> Boolean {
    return true;
  }

  override function isConstant() -> Boolean {
    return flagConstant;
  }

  /**
   * Does this have a value?
   */
  function hasValue() -> Boolean {
    return x?;
  }

  /**
   * Does this have a distribution?
   */
  function hasDistribution() -> Boolean {
    return p?;
  }

  /**
   * Get the distribution.
   */
  function getDistribution() -> Distribution<Value> {
    return p!;
  }

  /**
   * Does this have a gradient?
   */
  function hasGradient() -> Boolean {
    return d?;
  }

  /**
   * Get the gradient of an evaluated function with respect to this random
   * variable at its current value.
   */
  function getGradient() -> Value {
    return d!;
  }

  /**
   * Set the value, during a move step.
   */
  function move(x:Value) {
    this.x <- x;
  }

  /**
   * Assume the distribution for the random variate. When a value for the
   * random variate is required, it will be simulated from this distribution
   * and trigger an *update* on the delayed sampling graph.
   *
   * - p: The distribution.
   */
  function assume(p:Distribution<Value>) {
    assert !this.p?;
    assert !this.x?;
    p.assume(this);
    this.p <- p;
  }
  
  override function rows() -> Integer {
    assert this.x? || this.p?;
    if x? {
      return global.rows(x!);
    } else if p? {
      return p!.rows();
    } else {
      return 0;
    }
  }

  override function columns() -> Integer {
    assert this.x? || this.p?;
    if x? {
      return global.columns(x!);
    } else if p? {
      return p!.columns();
    } else {
      return 0;
    }
  }

  override function value() -> Value {
    eval();
    constant();
    return x!;
  }

  override function peak() -> Value {
    return eval();
  }

  override function eval() -> Value {
    if !x? {
      handle_realize(p!);
    }
    return x!;
  }

  override function reval() -> Value {
    /* values of Random objects are set externally before a call to reval()---
     * that is its point---so the current value is that set, and is correct */
    return x!;
  }

  override function grad(d:Value) {
    if this.d? {
      this.d <- this.d! + d;  // accumulate
    } else {
      this.d <- d;  // start accumulation
    }
  }
  
  override function label(gen:Integer) {
    //
  }

  override function prune(gen:Integer) {
    //
  }

  override function constant() {
    if !flagConstant {
      p <- nil;
      d <- nil;
      flagConstant <- true;
    }
  }

  function graftGaussian() -> Gaussian? {
    if !(hasValue() || p!.hasClamp()) {
      let q <- p!.graftGaussian();
      p <-? Distribution<Value>?(q);
      return q;
    }
    return nil;
  }
    
  function graftBeta() -> Beta? {
    if !(hasValue() || p!.hasClamp()) {
      let q <- p!.graftBeta();
      p <-? Distribution<Value>?(q);
      return q;
    }
    return nil;
  }
  
  function graftGamma() -> Gamma? {
    if !(hasValue() || p!.hasClamp()) {
      let q <- p!.graftGamma();
      p <-? Distribution<Value>?(q);
      return q;
    }
    return nil;
  }
  
  function graftInverseGamma() -> InverseGamma? {
    if !(hasValue() || p!.hasClamp()) {
      let q <- p!.graftInverseGamma();
      p <-? Distribution<Value>?(q);
      return q;
    }
    return nil;
  } 

  function graftInverseWishart() -> InverseWishart? {
    if !(hasValue() || p!.hasClamp()) {
      let q <- p!.graftInverseWishart();
      p <-? Distribution<Value>?(q);
      return q;
    }
    return nil;
  } 
  
  function graftNormalInverseGamma(compare:Distribution<Real>) -> NormalInverseGamma? {
    if !(hasValue() || p!.hasClamp()) {
      let q <- p!.graftNormalInverseGamma(compare);
      p <-? Distribution<Value>?(q);
      return q;
    }
    return nil;
  }
  
  function graftDirichlet() -> Dirichlet? {
    if !(hasValue() || p!.hasClamp()) {
      let q <- p!.graftDirichlet();
      p <-? Distribution<Value>?(q);
      return q;
    }
    return nil;
  }

  function graftRestaurant() -> Restaurant? {
    if !(hasValue() || p!.hasClamp()) {
      let q <- p!.graftRestaurant();
      p <-? Distribution<Value>?(q);
      return q;
    }
    return nil;
  }

  function graftMultivariateGaussian() -> MultivariateGaussian? {
    if !(hasValue() || p!.hasClamp()) {
      let q <- p!.graftMultivariateGaussian();
      p <-? Distribution<Value>?(q);
      return q;
    }
    return nil;
  }

  function graftMultivariateNormalInverseGamma(compare:Distribution<Real>) ->
      MultivariateNormalInverseGamma? {
    if !(hasValue() || p!.hasClamp()) {
      let q <- p!.graftMultivariateNormalInverseGamma(compare);
      p <-? Distribution<Value>?(q);
      return q;
    }
    return nil;
  }

  function graftMatrixGaussian() -> MatrixGaussian? {
    if !(hasValue() || p!.hasClamp()) {
      let q <- p!.graftMatrixGaussian();
      p <-? Distribution<Value>?(q);
      return q;
    }
    return nil;
  }

  function graftMatrixNormalInverseWishart(compare:Distribution<Real[_,_]>) ->
      MatrixNormalInverseWishart? {
    if !(hasValue() || p!.hasClamp()) {
      let q <- p!.graftMatrixNormalInverseWishart(compare);
      p <-? Distribution<Value>?(q);
      return q;
    }
    return nil;
  }

  function graftDiscrete() -> Discrete? {
    if !(hasValue() || p!.hasClamp()) {
      let q <- p!.graftDiscrete();
      p <-? Distribution<Value>?(q);
      return q;
    }
    return nil;
  }

  function graftBoundedDiscrete() -> BoundedDiscrete? {
    if !(hasValue() || p!.hasClamp()) {
      let q <- p!.graftBoundedDiscrete();
      p <-? Distribution<Value>?(q);
      return q;
    }
    return nil;
  }

  override function read(buffer:Buffer) {
    this <-? buffer.get<Value>();
  }

  override function write(buffer:Buffer) {
    if hasValue() || hasDistribution() {
      buffer.set(value());
    } else {
      buffer.setNil();
    }
  }
}

/**
 * Create a Random.
 */
function Random<Value>() -> Random<Value> {
  o:Random<Value>;
  return o;
}

/**
 * Create a Random.
 *
 * - x: Value to assign.
 */
function Random<Value>(x:Value) -> Random<Value> {
  o:Random<Value>;
  o <- x;
  return o;
}

/**
 * Create a Random.
 *
 * - x: Optional value to assign.
 */
function Random<Value>(x:Value?) -> Random<Value> {
  o:Random<Value>;
  if x? {
    o <- x!;
  }
  return o;
}
