/**
 * Random variate.
 *
 * - Value: Value type.
 *
 * Random objects, like all [Expression](../../classes/Expression/) objects,
 * are stateful. Random objects in the pilot state are considered
 * *variables*, meaning that a call to `grad()` will compute gradients with
 * respect to them, and a further call to `move()` will apply a Markov kernel
 * to update their value. Random objects in the value state are considered
 * *constants*.
 */
final class Random<Value> < Expression<Value>(nil, false) {  
  /**
   * Associated distribution.
   */
  p:Distribution<Value>?;

  /**
   * Value assignment.
   */
  operator <- x:Value! {
    assert !this.hasValue();
    prune();
    this.x <- x;
    if this.p? {
      handle_delay_observe(this);
    }
    this.constant();
  }

  /**
   * Set the value.
   */
  function set(x:Value!) {
    this.x <- x;
    this.d <- nil;
  }

  /**
   * Assume a distribution for the random variate. When a value for the
   * random variate is required, it will be simulated from this distribution
   * and trigger an *update* on the delayed sampling graph.
   *
   * - p: The distribution.
   */
  function assume(p:Distribution<Value>) {
    assert !hasDistribution();
    p.graft(this);
    this.p <- p;
  }

  override function isRandom() -> Boolean {
    return true;
  }

  override function doEval() {
    assert !this.x?;
    prune();
    handle_delay_simulate(this);
    assert this.x?;
  }

  override function doMove() {
    /* don't re-evaluate here; the purpose of calling move() on an Expression
     * is to re-evaluate it after modifying the value of one or more Random
     * arguments using move(), so if this has a value, it is the intended
     * value already */
    if !this.x? {
      prune();
      handle_delay_simulate(this);
    }
    assert this.x?;
  }

  override function doShallowGrad() {
    // specifically, don't clear the gradient here, unlike in Expression, as
    // Randoms form the arguments with respect to which gradients are computed
  }

  override function doConstant() {
    p <- nil;
  }

  override function graft(node:Delay) {
    super.graft(node);
    p <- nil;
  }

  override function graftReplace(node:Delay) {
    super.graftReplace(node);
    p <- nil;
  }

  override function prune() -> Delay {
    assert !this.coparent? || this.child?;
    if this.child? {
      if this.coparent? && this.n != 1 {
        /* defer to co-parent to restore the $M$-path between this and it */
        this.coparent!.prune();
        assert !this.coparent?;
      }

      /* restore distribution, conditioned on the value of the child */
      this.p <- Distribution<Value>?(this.child!.prune())!;
      this.child <- nil;

      if this.coparent? && this.n == 1 {
        /* restore the $M$-path between this and the co-parent */
        this.coparent!.graftReplace(p!);
        this.p!.graft(this);
        this.coparent!.coparent <- nil;
        this.coparent <- nil;
      }

      assert this.p?;
    }
    assert !this.coparent?;
    assert !this.child?;
    return this;
  }

  /**
   * Does this have a distribution?
   */
  function hasDistribution() -> Boolean {
    return this.p? || this.child?;
  }

  /**
   * Get the distribution.
   */
  function getDistribution() -> Distribution<Value> {
    assert this.p? || this.child?;
    prune();
    assert this.p?;
    return this.p!;
  }

  function hasGaussian() -> Boolean {
    return !this.hasValue() && this.hasDistribution() &&
        this.getDistribution().isGaussian();
  }

  function getGaussian() -> (Expression<Real>, Expression<Real>) {
    return this.getDistribution().getGaussian()!;
  }

  function hasBeta() -> Boolean {
    return !this.hasValue() && this.hasDistribution() &&
        this.getDistribution().isBeta();
  }

  function getBeta() -> (Expression<Real>, Expression<Real>) {
    return this.getDistribution().getBeta()!;
  }

  function hasGamma() -> Boolean {
    return !this.hasValue() && this.hasDistribution() &&
        this.getDistribution().isGamma();
  }

  function getGamma() -> (Expression<Real>, Expression<Real>) {
    return this.getDistribution().getGamma()!;
  }

  function hasInverseGamma() -> Boolean {
    return !this.hasValue() && this.hasDistribution() &&
        this.getDistribution().isInverseGamma();
  } 

  function getInverseGamma() -> (Expression<Real>, Expression<Real>) {
    return this.getDistribution().getInverseGamma()!;
  }

  function hasInverseWishart() -> Boolean {
    return !this.hasValue() && this.hasDistribution() &&
        this.getDistribution().isInverseWishart();
  } 

  function getInverseWishart() -> (Expression<Real[_,_]>, Expression<Real>) {
    return this.getDistribution().getInverseWishart()!;
  } 

  function hasNormalInverseGamma() -> Boolean {
    return !this.hasValue() && this.hasDistribution() &&
        this.getDistribution().isNormalInverseGamma();
  }

  function getNormalInverseGamma() -> (Expression<Real>, Expression<Real>,
      Expression<Real>, Expression<Real>) {
    return this.getDistribution().getNormalInverseGamma()!;
  }

  function hasDirichlet() -> Boolean {
    return !this.hasValue() && this.hasDistribution() &&
        this.getDistribution().isDirichlet();
  }

  function getDirichlet() -> Expression<Real[_]> {
    return this.getDistribution().getDirichlet()!;
  }

  function hasRestaurant() -> Boolean {
    return !this.hasValue() && this.hasDistribution() &&
        this.getDistribution().isRestaurant();
  }

  function getRestaurant() -> (Expression<Real>, Expression<Real>,
      Expression<Integer[_]>) {
    return this.getDistribution().getRestaurant()!;
  }

  function hasMultivariateGaussian() -> Boolean {
    return !this.hasValue() && this.hasDistribution() &&
        this.getDistribution().isMultivariateGaussian();
  }

  function getMultivariateGaussian() -> (Expression<Real[_]>,
      Expression<Real[_,_]>) {
    return this.getDistribution().getMultivariateGaussian()!;
  }

  function hasMultivariateNormalInverseGamma() -> Boolean {
    return !this.hasValue() && this.hasDistribution() &&
        this.getDistribution().isMultivariateNormalInverseGamma();
  }

  function getMultivariateNormalInverseGamma() -> (Expression<Real[_]>,
      Expression<Real[_,_]>, Expression<Real>, Expression<Real>) {
    return this.getDistribution().getMultivariateNormalInverseGamma()!;
  }

  function hasMatrixGaussian() -> Boolean {
    return !this.hasValue() && this.hasDistribution() &&
        this.getDistribution().isMatrixGaussian();
  }

  function getMatrixGaussian() -> (Expression<Real[_,_]>,
      Expression<Real[_,_]>, Expression<Real[_,_]>) {
    return this.getDistribution().getMatrixGaussian()!;
  }

  function hasMatrixNormalInverseWishart() -> Boolean {
    return !this.hasValue() && this.hasDistribution() &&
        this.getDistribution().isMatrixNormalInverseWishart();
  }

  function getMatrixNormalInverseWishart() -> (Expression<Real[_,_]>,
      Expression<Real[_,_]>, Expression<Real[_,_]>, Expression<Real>) {
    return this.getDistribution().getMatrixNormalInverseWishart()!;
  }

  function hasDiscrete() -> Boolean {
    return !this.hasValue() && this.hasDistribution() &&
        this.getDistribution().isDiscrete();
  }

  function getDiscrete() -> DiscreteDistribution {
    return this.getDistribution().getDiscrete()!;
  }

  function hasBoundedDiscrete() -> Boolean {
    return !this.hasValue() && this.hasDistribution() &&
        this.getDistribution().isBoundedDiscrete();
  }

  function getBoundedDiscrete() -> BoundedDiscreteDistribution {
    return this.getDistribution().getBoundedDiscrete()!;
  }

  override function read(buffer:Buffer) {
    this <-? buffer.get<Value>();
  }

  override function write(buffer:Buffer) {
    if this.hasValue() || this.hasDistribution() {
      buffer.set(this.value()!);
    } else {
      buffer.setNil();
    }
  }
}

/**
 * Create a Random.
 */
function make_random<Value>() -> Random<Value> {
  o:Random<Value>;
  return o;
}

/**
 * Box a value in a Random.
 *
 * - x: Value to assign.
 */
function make_random<Value>(x:Value?) -> Random<Value> {
  o:Random<Value>;
  o <-? x;
  return o;
}

/**
 * Box a value in a Random.
 *
 * - x: Value to assign.
 */
function make_random<Value>(x:Value!) -> Random<Value> {
  o:Random<Value>;
  o <- x;
  return o;
}

/**
 * Box a value in a Random.
 *
 * - x: Optional value to assign.
 */
function make_random<Value>(x:Value!?) -> Random<Value> {
  o:Random<Value>;
  if x? {
    o <- x!;
  }
  return o;
}

/**
 * Box a value in a Random (identity operation).
 *
 * - x: Existing object.
 */
function make_random<Value>(x:Random<Value>) -> Random<Value> {
  return x;
}
