/**
 * Lazy `canonical`.
 */
final class MultivariateCanonical(m:Expression<Real[_]>) <
    MultivariateUnaryExpression<Expression<Real[_]>,Real[_]>(m) {
  override function doRows() -> Integer {
    return m!.rows();
  }

  override function doCompute() {
    x <- m!.eval();
  }

  override function doGrad(gen:Integer) {
    m!.countGrad(gen, d!);
  }
}

/**
 * Lazy `canonical`.
 */
function canonical(m:Expression<Real[_]>) -> Expression<Real[_]> {
  if !m.isRandom() {
    /* just an identity function */
    return m;
  } else {  
    /* Random objects should be wrapped to allow the accumulation of
     * gradients by element if necessary; see note in split() also */
    return construct<MultivariateCanonical>(m);
  }
}
