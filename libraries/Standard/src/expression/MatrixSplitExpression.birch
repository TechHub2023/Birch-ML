/**
 * Boxed and split matrix expression.
 *
 * - Value: Result type.
 * - Form: Form type.
 */
final class MatrixSplitExpression<Value,Form>(x:Value[_,_], f:Form) <
    BoxedForm<Value[_,_],Form>(x, f) {
  function grad(d:Value!, i:Integer, j:Integer) {
    if this.f? {
      if this.visitCount == 0 {
        assert !this.d?;
        this.d <- matrix<Value>(0, this.rows(), this.columns());
      }
      assert this.d?;
      this.d![i,j] <- this.d![i,j] + d;
      this.visitCount <- this.visitCount + 1;
      if this.visitCount >= this.linkCount {
        assert this.visitCount == this.linkCount || this.linkCount == 0;
        global.grad(this.f!, this.d!);  // upstream gradients accumulated
        this.d <- nil;  // clear intermediate gradients to save memory
        this.visitCount <- 0;  // reset for next time
      }
    }
  }
}

/**
 * Box and split a matrix expression into a matrix of expressions.
 *
 * - f: Form of the expression.
 */
function matrix_split<Form>(f:Form) -> {
  link(f);
  return matrix_split_impl(peek(f), f);
}
function matrix_split_impl<Value,Form>(x:Value[_,_], f:Form) -> {
  return construct<MatrixSplitExpression<Value,Form>>(x, f);
}

function length<Value,Form>(x:MatrixSplitExpression<Value,Form>) -> Integer {
  return x.length();
}

function size<Value,Form>(x:MatrixSplitExpression<Value,Form>) -> Integer {
  return x.size();
}

function rows<Value,Form>(x:MatrixSplitExpression<Value,Form>) -> Integer {
  return x.rows();
}

function columns<Value,Form>(x:MatrixSplitExpression<Value,Form>) -> Integer {
  return x.columns();
}

function value<Value,Form>(x:MatrixSplitExpression<Value,Form>) -> Value[_,_] {
  return x.value();
}

function peek<Value,Form>(x:MatrixSplitExpression<Value,Form>) -> Value[_,_] {
  return x.peek();
}

function eval<Value,Form>(x:MatrixSplitExpression<Value,Form>) -> Value[_,_] {
  return x.eval();
}

function grad<Value,Form>(x:MatrixSplitExpression<Value,Form>,
    d:Value!, i:Integer, j:Integer) {
  x.grad(d, i, j);
}

function link<Value,Form>(x:MatrixSplitExpression<Value,Form>) {
  x.link();
}

function label<Value,Form>(x:MatrixSplitExpression<Value,Form>, gen:Integer) {
  x.label(gen);
}

function constant<Value,Form>(x:MatrixSplitExpression<Value,Form>,
    gen:Integer) {
  x.constant(gen);
}

function constant<Value,Form>(x:MatrixSplitExpression<Value,Form>) {
  x.constant();
}
