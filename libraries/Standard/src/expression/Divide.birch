/**
 * Lazy divide.
 */
final class Divide(l:Expression<Real>, r:Expression<Real>) <
    ScalarBinaryExpression<Expression<Real>,Expression<Real>,Real>(l, r) {  
  override function doCompute() {
    x <- global.eval(l!)/global.eval(r!);
  }

  override function doGrad(gen:Integer) {
    count_grad(l!, gen, d!/global.eval(r!));
    count_grad(r!, gen, -d!*global.eval(l!)/pow(global.eval(r!), 2.0));
  }

  override function graftLinearGaussian() -> TransformLinear<Gaussian>? {
    t:TransformLinear<Gaussian>?;
    if !hasValue() {
      l1:Gaussian?;
      if (t <- graft_linear_gaussian(l!))? {
        t!.divide(r!);
      } else if (l1 <- graft_gaussian(l!))? {
        t <- TransformLinear<Gaussian>(1.0/r!, l1!);
      }
    }
    return t;
  }

  override function graftDotMultivariateGaussian() ->
      TransformDot<MultivariateGaussian>? {
    t:TransformDot<MultivariateGaussian>?;
    if !hasValue() {
      if (t <- graft_dot_multivariate_gaussian(l!))? {
        t!.divide(r!);
      }
    }
    return t;
  }
  
  override function graftLinearNormalInverseGamma(compare:Distribution<Real>) ->
      TransformLinear<NormalInverseGamma>? {
    t:TransformLinear<NormalInverseGamma>?;
    if !hasValue() {
      l1:NormalInverseGamma?;
      if (t <- graft_linear_normal_inverse_gamma(l!, compare))? {
        t!.divide(r!);
      } else if (l1 <- graft_normal_inverse_gamma(l!, compare))? {
        t <- TransformLinear<NormalInverseGamma>(1.0/r!, l1!);
      }
    }
    return t;
  }

  override function graftDotMultivariateNormalInverseGamma(compare:Distribution<Real>) ->
      TransformDot<MultivariateNormalInverseGamma>? {
    t:TransformDot<MultivariateNormalInverseGamma>?;
    if !hasValue() {
      if (t <- graft_dot_multivariate_normal_inverse_gamma(l!, compare))? {
        t!.divide(r!);
      }
    }
    return t;
  }

  override function graftScaledGamma() -> TransformLinear<Gamma>? {
    t:TransformLinear<Gamma>?;
    if !hasValue() {
      l1:Gamma?;
      if (t <- graft_scaled_gamma(l!))? {
        t!.divide(r!);
      } else if (l1 <- graft_gamma(l!))? {
        t <- TransformLinear<Gamma>(1.0/r!, l1!);
      }
    }
    return t;
  }
}

/**
 * Lazy divide.
 */
operator (l:Expression<Real>/r:Expression<Real>) -> Divide {
  return construct<Divide>(l, r);
}

/**
 * Lazy divide.
 */
operator (l:Real/r:Expression<Real>) -> Divide {
  return box(l)/r;
}

/**
 * Lazy divide.
 */
operator (l:Expression<Real>/r:Real) -> Divide {
  return l/box(r);
}
