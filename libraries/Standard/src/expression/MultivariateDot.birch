/**
 * Lazy `dot`.
 */
final class MultivariateDot(l:Expression<Real[_]>, r:Expression<Real[_,_]>) <
    MultivariateBinaryExpression<Expression<Real[_]>,Expression<Real[_,_]>,
    Real[_]>(l, r) {
  override function doRows() -> Integer {
    return r!.columns();
  }

  override function doCompute() {
    x <- dot(l!.eval(), r!.eval());
  }

  override function doGrad(gen:Integer) {
    l!.countGrad(gen, r!.eval()*d!);
    r!.countGrad(gen, outer(l!.eval(), d!));
  }

  override function graftDotMatrixGaussian() ->
      TransformDotMultivariate<MatrixGaussian>? {
    if !hasValue() {
      x1:TransformLinearMatrix<MatrixGaussian>?;
      x2:MatrixGaussian?;
      
      if (x1 <- r!.graftLinearMatrixGaussian())? {
        return TransformDotMultivariate<MatrixGaussian>(dot(l!, x1!.A), x1!.X, dot(l!, x1!.C));
      } else if (x2 <- r!.graftMatrixGaussian())? {
        return TransformDotMultivariate<MatrixGaussian>(l!, x2!);
      }
    }
    return nil;
  }

  override function graftDotMatrixNormalInverseWishart(compare:Distribution<LLT>) ->
      TransformDotMultivariate<MatrixNormalInverseWishart>? {
    if !hasValue() {
      x1:TransformLinearMatrix<MatrixNormalInverseWishart>?;
      x2:MatrixNormalInverseWishart?;
    
      if (x1 <- r!.graftLinearMatrixNormalInverseWishart(compare))? {
        return TransformDotMultivariate<MatrixNormalInverseWishart>(dot(l!, x1!.A), x1!.X, dot(l!, x1!.C));
      } else if (x2 <- r!.graftMatrixNormalInverseWishart(compare))? {
        return TransformDotMultivariate<MatrixNormalInverseWishart>(l!, x2!);
      }
    }
    return nil;
  }
}

/**
 * Lazy `dot`.
 */
function dot(l:Expression<Real[_]>, r:Expression<Real[_,_]>) ->
    MultivariateDot {
  assert l.rows() == r.rows();
  return construct<MultivariateDot>(l, r);
}

/**
 * Lazy `dot`.
 */
function dot(l:Real[_], r:Expression<Real[_,_]>) -> MultivariateDot {
  return dot(box(l), r);
}

/**
 * Lazy `dot`.
 */
function dot(l:Expression<Real[_]>, r:Real[_,_]) -> MultivariateDot {
  return dot(l, box(r));
}
