/**
 * Lazy `dot`.
 */
final class MultivariateDot(l:Expression<Real[_]>, r:Expression<Real[_,_]>) <
    MultivariateBinaryExpression<Expression<Real[_]>,Expression<Real[_,_]>,
    Real[_]>(l, r) {
  override function doRows() -> Integer {
    return global.columns(r!);
  }

  override function doCompute() {
    x <- dot(global.eval(l!), global.eval(r!));
  }

  override function doGrad(gen:Integer) {
    count_grad(l!, gen, global.eval(r!)*d!);
    count_grad(r!, gen, outer(global.eval(l!), d!));
  }

  override function graftDotMatrixGaussian() ->
      TransformDotMultivariate<MatrixGaussian>? {
    if !hasValue() {
      x1:TransformLinearMatrix<MatrixGaussian>?;
      x2:MatrixGaussian?;
      
      if (x1 <- graft_linear_matrix_gaussian(r!))? {
        return TransformDotMultivariate<MatrixGaussian>(dot(l!, x1!.A), x1!.X, dot(l!, x1!.C));
      } else if (x2 <- graft_matrix_gaussian(r!))? {
        return TransformDotMultivariate<MatrixGaussian>(l!, x2!);
      }
    }
    return nil;
  }

  override function graftDotMatrixNormalInverseWishart(compare:Distribution<LLT>) ->
      TransformDotMultivariate<MatrixNormalInverseWishart>? {
    if !hasValue() {
      x1:TransformLinearMatrix<MatrixNormalInverseWishart>?;
      x2:MatrixNormalInverseWishart?;
    
      if (x1 <- graft_linear_matrix_normal_inverse_wishart(r!, compare))? {
        return TransformDotMultivariate<MatrixNormalInverseWishart>(dot(l!, x1!.A), x1!.X, dot(l!, x1!.C));
      } else if (x2 <- graft_matrix_normal_inverse_wishart(r!, compare))? {
        return TransformDotMultivariate<MatrixNormalInverseWishart>(l!, x2!);
      }
    }
    return nil;
  }
}

/**
 * Lazy `dot`.
 */
function dot(l:Expression<Real[_]>, r:Expression<Real[_,_]>) ->
    MultivariateDot {
  assert global.rows(l) == global.rows(r);
  return construct<MultivariateDot>(l, r);
}

/**
 * Lazy `dot`.
 */
function dot(l:Real[_], r:Expression<Real[_,_]>) -> MultivariateDot {
  return dot(box(l), r);
}

/**
 * Lazy `dot`.
 */
function dot(l:Expression<Real[_]>, r:Real[_,_]) -> MultivariateDot {
  return dot(l, box(r));
}
