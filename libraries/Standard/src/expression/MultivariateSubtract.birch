/**
 * Lazy multivariate subtract.
 */
final class MultivariateSubtract(l:Expression<Real[_]>,
    r:Expression<Real[_]>) < MultivariateBinaryExpression<Expression<Real[_]>,
    Expression<Real[_]>,Real[_]>(l, r) {
  override function doRows() -> Integer {
    return l!.rows();
  }

  override function doCompute() {
    x <- l!.eval() - r!.eval();
  }

  override function doGrad(gen:Integer) {
    l!.countGrad(gen, d!);
    r!.countGrad(gen, -d!);
  }

  override function graftLinearMultivariateGaussian() ->
      TransformLinearMultivariate<MultivariateGaussian>? {
    t:TransformLinearMultivariate<MultivariateGaussian>?;
    if !hasValue() {
      x1:MultivariateGaussian?;

      if (t <- l!.graftLinearMultivariateGaussian())? {
        t!.subtract(r!);
      } else if (t <- r!.graftLinearMultivariateGaussian())? {
        t!.negateAndAdd(l!);
      } else if (x1 <- l!.graftMultivariateGaussian())? {
        t <- TransformLinearMultivariate<MultivariateGaussian>(box(identity(r!.rows())), x1!, -r!);
      } else if (x1 <- r!.graftMultivariateGaussian())? {
        t <- TransformLinearMultivariate<MultivariateGaussian>(box(diagonal(-1.0, r!.rows())), x1!, l!);
      }
    }
    return t;
  }
  
  override function graftLinearMultivariateNormalInverseGamma(compare:Distribution<Real>) ->
      TransformLinearMultivariate<MultivariateNormalInverseGamma>? {
    t:TransformLinearMultivariate<MultivariateNormalInverseGamma>?;
    if !hasValue() {
      x1:MultivariateNormalInverseGamma?;

      if (t <- l!.graftLinearMultivariateNormalInverseGamma(compare))? {
        t!.subtract(r!);
      } else if (t <- r!.graftLinearMultivariateNormalInverseGamma(compare))? {
        t!.negateAndAdd(l!);
      } else if (x1 <- l!.graftMultivariateNormalInverseGamma(compare))? {
        t <- TransformLinearMultivariate<MultivariateNormalInverseGamma>(box(identity(r!.rows())), x1!, -r!);
      } else if (x1 <- r!.graftMultivariateNormalInverseGamma(compare))? {
        t <- TransformLinearMultivariate<MultivariateNormalInverseGamma>(box(diagonal(-1.0, r!.rows())), x1!, l!);
      }
    }
    return t;
  }

  override function graftDotMatrixNormalInverseWishart(compare:Distribution<LLT>) ->
      TransformDotMultivariate<MatrixNormalInverseWishart>? {
    t:TransformDotMultivariate<MatrixNormalInverseWishart>?;
    if !hasValue() {
      if (t <- l!.graftDotMatrixNormalInverseWishart(compare))? {
        t!.subtract(r!);
      } else if (t <- r!.graftDotMatrixNormalInverseWishart(compare))? {
        t!.negateAndAdd(l!);
      }
    }
    return t;
  }
}

/**
 * Lazy subtract.
 */
operator (l:Expression<Real[_]> - r:Expression<Real[_]>) ->
    MultivariateSubtract {
  assert l.rows() == r.rows();
  return construct<MultivariateSubtract>(l, r);
}

/**
 * Lazy subtract.
 */
operator (l:Real[_] - r:Expression<Real[_]>) -> MultivariateSubtract {
  return box(l) - r;
}

/**
 * Lazy subtract.
 */
operator (l:Expression<Real[_]> - r:Real[_]) -> MultivariateSubtract {
  return l - box(r);
}
