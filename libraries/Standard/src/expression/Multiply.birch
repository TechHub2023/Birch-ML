/**
 * Lazy multiply.
 */
final class Multiply<Left,Right,Value>(l:Left, r:Right) <
    ScalarBinaryExpression<Left,Right,Value>(l, r) {  
  override function doCompute() {
    x <- global.eval(l!)*global.eval(r!);
  }

  override function doGrad(gen:Integer) {
    count_grad(l!, gen, d!*global.eval(r!));
    count_grad(r!, gen, d!*global.eval(l!));
  }

  override function graftScaledGamma() -> TransformLinear<Gamma>? {
    t:TransformLinear<Gamma>?;
    if !hasValue() {
      x1:Gamma?;
    
      if (t <- graft_scaled_gamma(l!))? {
        t!.multiply(Real(r!));
      } else if (t <- graft_scaled_gamma(r!))? {
        t!.multiply(Real(l!));
      } else if (x1 <- graft_gamma(l!))? {
        t <- TransformLinear<Gamma>(Real(r!), x1!);
      } else if (x1 <- graft_gamma(r!))? {
        t <- TransformLinear<Gamma>(Real(l!), x1!);
      }
    }
    return t;
  }

  override function graftLinearGaussian() -> TransformLinear<Gaussian>? {
    t:TransformLinear<Gaussian>?;
    if !hasValue() {
      x1:Gaussian?;
    
      if (t <- graft_linear_gaussian(l!))? {
        t!.multiply(Real(r!));
      } else if (t <- graft_linear_gaussian(r!))? {
        t!.multiply(Real(l!));
      } else if (x1 <- graft_gaussian(l!))? {
        t <- TransformLinear<Gaussian>(Real(r!), x1!);
      } else if (x1 <- graft_gaussian(r!))? {
        t <- TransformLinear<Gaussian>(Real(l!), x1!);
      }
    }
    return t;
  }

  override function graftDotMultivariateGaussian() ->
      TransformDot<MultivariateGaussian>? {
    t:TransformDot<MultivariateGaussian>?;
    if !hasValue() {
      if (t <- graft_dot_multivariate_gaussian(l!))? {
        t!.multiply(Real(r!));
      } else if (t <- graft_dot_multivariate_gaussian(r!))? {
        t!.multiply(Real(l!));
      }
    }
    return t;
  }
 
  override function graftLinearNormalInverseGamma(compare:Distribution<Real>) ->
      TransformLinear<NormalInverseGamma>? {
    t:TransformLinear<NormalInverseGamma>?;
    if !hasValue() {
      x1:NormalInverseGamma?;
    
      if (t <- graft_linear_normal_inverse_gamma(l!, compare))? {
        t!.multiply(Real(r!));
      } else if (t <- graft_linear_normal_inverse_gamma(r!, compare))? {
        t!.multiply(Real(l!));
      } else if (x1 <- graft_normal_inverse_gamma(l!, compare))? {
        t <- TransformLinear<NormalInverseGamma>(Real(r!), x1!);
      } else if (x1 <- graft_normal_inverse_gamma(r!, compare))? {
        t <- TransformLinear<NormalInverseGamma>(Real(l!), x1!);
      }
    }
    return t;
  }

  override function graftDotMultivariateNormalInverseGamma(compare:Distribution<Real>) ->
      TransformDot<MultivariateNormalInverseGamma>? {
    t:TransformDot<MultivariateNormalInverseGamma>?;
    if !hasValue() {
      if (t <- graft_dot_multivariate_normal_inverse_gamma(l!, compare))? {
        t!.multiply(Real(r!));
      } else if (t <- graft_dot_multivariate_normal_inverse_gamma(r!, compare))? {
        t!.multiply(Real(l!));
      }
    }
    return t;
  }

  override function graftDiscrete() -> Discrete? {
    t:Discrete?;
    if !hasValue() {
      t <- graftBoundedDiscrete();
      if !t? {
        x1:Discrete?;
        if (x1 <- graft_discrete(l!))? {
          t <- LinearDiscrete(Integer(r!), x1!, box(0));
        } else if (x1 <- graft_discrete(r!))? {
          t <- LinearDiscrete(Integer(l!), x1!, box(0));
        }
      }
    }
    return t;
  }

  override function graftBoundedDiscrete() -> BoundedDiscrete? {
    t:BoundedDiscrete?;
    if !hasValue() {
      let l1 <- graft_bounded_discrete(l!);
      let r1 <- graft_bounded_discrete(r!);
      if l1? {
        t <- LinearBoundedDiscrete(Integer(r!), l1!, box(0));
      } else if r1? {
        t <- LinearBoundedDiscrete(Integer(l!), r1!, box(0));
      }
    }
    return t;
  }
}

/**
 * Lazy multiply.
 */
operator (l:Expression<Real>*r:Expression<Real>) ->
    Multiply<Expression<Real>,Expression<Real>,Real> {
  return construct<Multiply<Expression<Real>,Expression<Real>,Real>>(l, r);
}

/**
 * Lazy multiply.
 */
operator (l:Real*r:Expression<Real>) ->
    Multiply<Expression<Real>,Expression<Real>,Real> {
  return box(l)*r;
}

/**
 * Lazy multiply.
 */
operator (l:Expression<Real>*r:Real) ->
    Multiply<Expression<Real>,Expression<Real>,Real> {
  return l*box(r);
}

/**
 * Lazy multiply.
 */
operator (l:Expression<Integer>*r:Expression<Integer>) ->
    Multiply<Expression<Integer>,Expression<Integer>,Integer> {
  return construct<Multiply<Expression<Integer>,Expression<Integer>,Integer>>(l, r);
}

/**
 * Lazy multiply.
 */
operator (l:Integer*r:Expression<Integer>) ->
    Multiply<Expression<Integer>,Expression<Integer>,Integer> {
  return box(l)*r;
}

/**
 * Lazy multiply.
 */
operator (l:Expression<Integer>*r:Integer) ->
    Multiply<Expression<Integer>,Expression<Integer>,Integer> {
  return l*box(r);
}
