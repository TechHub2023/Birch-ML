/**
 * Lazy multiply.
 */
final class Multiply(l:Expression<Real>, r:Expression<Real>) <
    ScalarBinaryExpression<Expression<Real>,Expression<Real>,Real>(l, r) {  
  override function doCompute() {
    x <- l!.eval()*r!.eval();
  }

  override function doGrad(gen:Integer) {
    l!.countGrad(gen, d!*r!.eval());
    r!.countGrad(gen, d!*l!.eval());
  }

  override function graftScaledGamma() -> TransformLinear<Gamma>? {
    t:TransformLinear<Gamma>?;
    if !hasValue() {
      x1:Gamma?;
    
      if (t <- l!.graftScaledGamma())? {
        t!.multiply(r!);
      } else if (t <- r!.graftScaledGamma())? {
        t!.multiply(l!);
      } else if (x1 <- l!.graftGamma())? {
        t <- TransformLinear<Gamma>(r!, x1!);
      } else if (x1 <- r!.graftGamma())? {
        t <- TransformLinear<Gamma>(l!, x1!);
      }
    }
    return t;
  }

  override function graftLinearGaussian() -> TransformLinear<Gaussian>? {
    t:TransformLinear<Gaussian>?;
    if !hasValue() {
      x1:Gaussian?;
    
      if (t <- l!.graftLinearGaussian())? {
        t!.multiply(r!);
      } else if (t <- r!.graftLinearGaussian())? {
        t!.multiply(l!);
      } else if (x1 <- l!.graftGaussian())? {
        t <- TransformLinear<Gaussian>(r!, x1!);
      } else if (x1 <- r!.graftGaussian())? {
        t <- TransformLinear<Gaussian>(l!, x1!);
      }
    }
    return t;
  }

  override function graftDotMultivariateGaussian() ->
      TransformDot<MultivariateGaussian>? {
    t:TransformDot<MultivariateGaussian>?;
    if !hasValue() {
      if (t <- l!.graftDotMultivariateGaussian())? {
        t!.multiply(r!);
      } else if (t <- r!.graftDotMultivariateGaussian())? {
        t!.multiply(l!);
      }
    }
    return t;
  }
 
  override function graftLinearNormalInverseGamma(compare:Distribution<Real>) ->
      TransformLinear<NormalInverseGamma>? {
    t:TransformLinear<NormalInverseGamma>?;
    if !hasValue() {
      x1:NormalInverseGamma?;
    
      if (t <- l!.graftLinearNormalInverseGamma(compare))? {
        t!.multiply(r!);
      } else if (t <- r!.graftLinearNormalInverseGamma(compare))? {
        t!.multiply(l!);
      } else if (x1 <- l!.graftNormalInverseGamma(compare))? {
        t <- TransformLinear<NormalInverseGamma>(r!, x1!);
      } else if (x1 <- r!.graftNormalInverseGamma(compare))? {
        t <- TransformLinear<NormalInverseGamma>(l!, x1!);
      }
    }
    return t;
  }

  override function graftDotMultivariateNormalInverseGamma(compare:Distribution<Real>) ->
      TransformDot<MultivariateNormalInverseGamma>? {
    t:TransformDot<MultivariateNormalInverseGamma>?;
    if !hasValue() {
      if (t <- l!.graftDotMultivariateNormalInverseGamma(compare))? {
        t!.multiply(r!);
      } else if (t <- r!.graftDotMultivariateNormalInverseGamma(compare))? {
        t!.multiply(l!);
      }
    }
    return t;
  }
}

/**
 * Lazy multiply.
 */
operator (l:Expression<Real>*r:Expression<Real>) -> Multiply {
  return construct<Multiply>(l, r);
}

/**
 * Lazy multiply.
 */
operator (l:Real*r:Expression<Real>) -> Multiply {
  return box(l)*r;
}

/**
 * Lazy multiply.
 */
operator (l:Expression<Real>*r:Real) -> Multiply {
  return l*box(r);
}
