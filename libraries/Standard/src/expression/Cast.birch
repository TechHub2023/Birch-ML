/**
 * Lazy cast.
 */
final class Cast<From,To>(m:From) < ScalarUnaryExpression<From,To>(m) {
  override function doCompute() {
    x <- To?(m!.eval())!;
  }

  override function doGrad(gen:Integer) {
    m!.countGrad(gen, d!);
  }
}

/**
 * Lazy cast.
 */
function Real(m:Expression<Real>) -> Expression<Real> {
  return m;
}

/**
 * Lazy cast.
 */
function Real(m:Expression<Integer>) -> Cast<Expression<Integer>,Real> {
  return construct<Cast<Expression<Integer>,Real>>(m);
}

/**
 * Lazy cast.
 */
function Real(m:Expression<Boolean>) -> Cast<Expression<Boolean>,Real> {
  return construct<Cast<Expression<Boolean>,Real>>(m);
}

/**
 * Lazy cast.
 */
function Integer(m:Expression<Real>) -> Cast<Expression<Real>,Integer> {
  return construct<Cast<Expression<Real>,Integer>>(m);
}

/**
 * Lazy cast.
 */
function Integer(m:Expression<Integer>) -> Expression<Integer> {
  return m;
}

/**
 * Lazy cast.
 */
function Integer(m:Expression<Boolean>) -> Cast<Expression<Boolean>,Integer> {
  return construct<Cast<Expression<Boolean>,Integer>>(m);
}

/**
 * Lazy cast.
 */
function Boolean(m:Expression<Real>) -> Cast<Expression<Real>,Boolean> {
  return construct<Cast<Expression<Real>,Boolean>>(m);
}

/**
 * Lazy cast.
 */
function Boolean(m:Expression<Integer>) -> Cast<Expression<Integer>,Boolean> {
  return construct<Cast<Expression<Integer>,Boolean>>(m);
}

/**
 * Lazy cast.
 */
function Boolean(m:Expression<Boolean>) -> Expression<Boolean> {
  return m;
}
