/**
 * Lazy negation.
 */
final class Negate<Middle,Value>(m:Middle) <
    ScalarUnaryExpression<Middle,Value>(m) {
  override function doCompute() {
    x <- -m!.eval();
  }

  override function doGrad(gen:Integer) {
    m!.countGrad(gen, -d!);
  }

  override function graftLinearGaussian() -> TransformLinear<Gaussian>? {
    t:TransformLinear<Gaussian>?;
    if !hasValue() {
      x1:Gaussian?;
      if (t <- m!.graftLinearGaussian())? {
        t!.negate();
      } else if (x1 <- m!.graftGaussian())? {
        t <- TransformLinear<Gaussian>(box(-1.0), x1!, box(0.0));
      }
    }
    return t;
  }

  override function graftDotMultivariateGaussian() ->
      TransformDot<MultivariateGaussian>? {
    t:TransformDot<MultivariateGaussian>?;
    if !hasValue() {
      if (t <- m!.graftDotMultivariateGaussian())? {
        t!.negate();
      }
    }
    return t;
  }
  
  override function graftLinearNormalInverseGamma(compare:Distribution<Real>) ->
      TransformLinear<NormalInverseGamma>? {
    t:TransformLinear<NormalInverseGamma>?;
    if !hasValue() {
      x1:NormalInverseGamma?;
      if (t <- m!.graftLinearNormalInverseGamma(compare))? {
        t!.negate();
      } else if (x1 <- m!.graftNormalInverseGamma(compare))? {
        t <- TransformLinear<NormalInverseGamma>(box(-1.0), x1!, box(0.0));
      }
    }
    return t;
  }

  override function graftDotMultivariateNormalInverseGamma(compare:Distribution<Real>) ->
      TransformDot<MultivariateNormalInverseGamma>? {
    t:TransformDot<MultivariateNormalInverseGamma>?;
    if !hasValue() {
      if (t <- m!.graftDotMultivariateNormalInverseGamma(compare))? {
        t!.negate();
      }
    }
    return t;
  }

  override function graftDiscrete() -> Discrete? {
    t:Discrete?;
    if !hasValue() {
      t <- graftBoundedDiscrete();
      if !t? {
        m1:Discrete?;
        if (m1 <- m!.graftDiscrete())? {
          t <- LinearDiscrete(box(-1), m1!, box(0));
        }
      }
    }
    return t;
  }

  override function graftBoundedDiscrete() -> BoundedDiscrete? {
    t:BoundedDiscrete?;
    if !hasValue() {
      m1:BoundedDiscrete?;
      if (m1 <- m!.graftBoundedDiscrete())? {
        t <- LinearBoundedDiscrete(box(-1), m1!, box(0));
      }
    }
    return t;
  }
}

/**
 * Lazy negation.
 */
operator (-m:Expression<Real>) -> Negate<Expression<Real>,Real> {
  return construct<Negate<Expression<Real>,Real>>(m);
}

/**
 * Lazy negation.
 */
operator (-x:Expression<Integer>) -> Negate<Expression<Integer>,Integer> {
  return construct<Negate<Expression<Integer>,Integer>>(x);
}
