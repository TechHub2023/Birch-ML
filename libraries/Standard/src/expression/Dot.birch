/**
 * Lazy `dot`.
 */
final class Dot(l:Expression<Real[_]>, r:Expression<Real[_]>) <
    ScalarBinaryExpression<Expression<Real[_]>,Expression<Real[_]>,Real>(l, r) {
  override function doCompute() {
    x <- dot(l!.eval(), r!.eval());
  }

  override function doGrad(gen:Integer) {
    l!.countGrad(gen, d!*r!.eval());
    r!.countGrad(gen, d!*l!.eval());
  }

  override function graftDotMultivariateGaussian() ->
      TransformDot<MultivariateGaussian>? {
    if !hasValue() {
      x1:TransformLinearMultivariate<MultivariateGaussian>?;
      x2:MultivariateGaussian?;
      
      if (x1 <- r!.graftLinearMultivariateGaussian())? {
        return TransformDot<MultivariateGaussian>(x1!.A*l!, x1!.x, dot(x1!.c, l!));
      } else if (x1 <- l!.graftLinearMultivariateGaussian())? {
        return TransformDot<MultivariateGaussian>(x1!.A*r!, x1!.x, dot(x1!.c, r!));
      } else if (x2 <- r!.graftMultivariateGaussian())? {
        return TransformDot<MultivariateGaussian>(l!, x2!, box(0.0));
      } else if (x2 <- l!.graftMultivariateGaussian())? {
        return TransformDot<MultivariateGaussian>(r!, x2!, box(0.0));
      }
    }
    return nil;
  }

  override function graftDotMultivariateNormalInverseGamma(
      compare:Distribution<Real>) ->
      TransformDot<MultivariateNormalInverseGamma>? {
    if !hasValue() {
      x1:TransformLinearMultivariate<MultivariateNormalInverseGamma>?;
      x2:MultivariateNormalInverseGamma?;
    
      if (x1 <- r!.graftLinearMultivariateNormalInverseGamma(compare))? {
        return TransformDot<MultivariateNormalInverseGamma>(transpose(x1!.A)*l!, x1!.x, dot(l!, x1!.c));
      } else if (x1 <- l!.graftLinearMultivariateNormalInverseGamma(compare))? {
        return TransformDot<MultivariateNormalInverseGamma>(x1!.A*r!, x1!.x, dot(x1!.c, r!));
      } else if (x2 <- r!.graftMultivariateNormalInverseGamma(compare))? {
        return TransformDot<MultivariateNormalInverseGamma>(l!, x2!, box(0.0));
      } else if (x2 <- l!.graftMultivariateNormalInverseGamma(compare))? {
        return TransformDot<MultivariateNormalInverseGamma>(r!, x2!, box(0.0));
      }
    }
    return nil;
  }
}

/**
 * Lazy `dot`.
 */
function dot(l:Expression<Real[_]>, z:Expression<Real[_]>) -> Dot {
  assert l.rows() == z.rows();
  return construct<Dot>(l, z);
}

/**
 * Lazy `dot`.
 */
function dot(l:Real[_], z:Expression<Real[_]>) -> Dot {
  return dot(box(l), z);
}

/**
 * Lazy `dot`.
 */
function dot(l:Expression<Real[_]>, z:Real[_]) -> Dot {
  return dot(l, box(z));
}

/**
 * Lazy `dot`.
 */
function dot(l:Expression<Real[_]>) -> Dot {
  return dot(l, l);
}
