/**
 * Lazy `dot`.
 */
final class Dot(l:Expression<Real[_]>, r:Expression<Real[_]>) <
    ScalarBinaryExpression<Expression<Real[_]>,Expression<Real[_]>,Real>(l, r) {
  override function doCompute() {
    x <- dot(global.eval(l!), global.eval(r!));
  }

  override function doGrad(gen:Integer) {
    count_grad(l!, gen, d!*global.eval(r!));
    count_grad(r!, gen, d!*global.eval(l!));
  }

  override function graftDotMultivariateGaussian() ->
      TransformDot<MultivariateGaussian>? {
    if !hasValue() {
      x1:TransformLinearMultivariate<MultivariateGaussian>?;
      x2:MultivariateGaussian?;
      
      if (x1 <- graft_linear_multivariate_gaussian(r!))? {
        return TransformDot<MultivariateGaussian>(x1!.A*l!, x1!.x, dot(x1!.c, l!));
      } else if (x1 <- graft_linear_multivariate_gaussian(l!))? {
        return TransformDot<MultivariateGaussian>(x1!.A*r!, x1!.x, dot(x1!.c, r!));
      } else if (x2 <- graft_multivariate_gaussian(r!))? {
        return TransformDot<MultivariateGaussian>(l!, x2!, box(0.0));
      } else if (x2 <- graft_multivariate_gaussian(l!))? {
        return TransformDot<MultivariateGaussian>(r!, x2!, box(0.0));
      }
    }
    return nil;
  }

  override function graftDotMultivariateNormalInverseGamma(
      compare:Distribution<Real>) ->
      TransformDot<MultivariateNormalInverseGamma>? {
    if !hasValue() {
      x1:TransformLinearMultivariate<MultivariateNormalInverseGamma>?;
      x2:MultivariateNormalInverseGamma?;
    
      if (x1 <- graft_linear_multivariate_normal_inverse_gamma(r!, compare))? {
        return TransformDot<MultivariateNormalInverseGamma>(transpose(x1!.A)*l!, x1!.x, dot(l!, x1!.c));
      } else if (x1 <- graft_linear_multivariate_normal_inverse_gamma(l!, compare))? {
        return TransformDot<MultivariateNormalInverseGamma>(x1!.A*r!, x1!.x, dot(x1!.c, r!));
      } else if (x2 <- graft_multivariate_normal_inverse_gamma(r!, compare))? {
        return TransformDot<MultivariateNormalInverseGamma>(l!, x2!, box(0.0));
      } else if (x2 <- graft_multivariate_normal_inverse_gamma(l!, compare))? {
        return TransformDot<MultivariateNormalInverseGamma>(r!, x2!, box(0.0));
      }
    }
    return nil;
  }
}

/**
 * Lazy `dot`.
 */
function dot(l:Expression<Real[_]>, z:Expression<Real[_]>) -> Dot {
  assert global.rows(l) == global.rows(z);
  return construct<Dot>(l, z);
}

/**
 * Lazy `dot`.
 */
function dot(l:Real[_], z:Expression<Real[_]>) -> Dot {
  return dot(box(l), z);
}

/**
 * Lazy `dot`.
 */
function dot(l:Expression<Real[_]>, z:Real[_]) -> Dot {
  return dot(l, box(z));
}

/**
 * Lazy `dot`.
 */
function dot(l:Expression<Real[_]>) -> Dot {
  return dot(l, l);
}
