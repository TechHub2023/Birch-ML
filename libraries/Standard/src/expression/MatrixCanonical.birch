/**
 * Lazy `canonical`.
 */
final class MatrixCanonical<Argument>(m:Argument) <
    MatrixUnaryExpression<Argument,Real[_,_]>(m) {
  override function doRows() -> Integer {
    return global.rows(m!);
  }
  
  override function doColumns() -> Integer {
    return global.columns(m!);
  }

  override function doCompute() {
    x <- canonical(global.eval(m!));
  }

  override function doGrad(gen:Integer) {
    count_grad(m!, gen, d!);
  }
}

/**
 * Lazy `canonical`.
 */
function canonical(m:Expression<LLT>) -> Expression<Real[_,_]> {
  return construct<MatrixCanonical<Expression<LLT>>>(m);
}

/**
 * Lazy `canonical`.
 */
function canonical(m:Expression<Real[_,_]>) -> Expression<Real[_,_]> {
  if !m.isRandom() {
    /* just an identity function */
    return m;
  } else {  
    /* Random objects should be wrapped to allow the accumulation of
     * gradients by element if necessary; see note in split() also */
    return construct<MatrixCanonical<Expression<Real[_,_]>>>(m);
  }
}
