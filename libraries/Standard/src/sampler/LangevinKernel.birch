/**
 * Langevin Markov kernel, with Metropolis adjustment.
 *
 * ```mermaid
 * classDiagram
 *    Kernel <|-- LangevinKernel
 *    link Kernel "../Kernel/"
 *    link LangevinKernel "../LangevinKernel/"
 * ```
 */
class LangevinKernel < Kernel {
  /**
   * Ensemble standard deviation vector across particles.
   */
  σ2:Real[_];

  override function adapt(t:Integer, x:Array<Particle>, w:Real[_]) {
    assert x.size() == length(w);

    σ2 <- vector(0.0, 0);
    let N <- length(w);
    if N > 0 {
      x[1].hoist();
      let π <- x[1].π;
      if π? {
        let (y, g) <- π!.args();
        let P <- length(y);
        Y:Real[P,N];
        Y[1..P,1] <- where(isfinite(y), y, 0.0);

        let incompatible <- false;
        dynamic parallel for n in 2..N {
          x[n].hoist();
          let π <- x[n].π;
          if π? {
            let (y, g) <- π!.args();
            if length(y) == P {
              Y[1..P,n] <- where(isfinite(y), y, 0.0);
            } else {
              incompatible <- true;
            }
          } else {
            incompatible <- true;
          }
        }
        if !incompatible {
          let v <- norm_exp(w);  // normalized weights
          let μ <- Y*v;
          σ2 <- pow(Y, 2.0)*v - pow(μ, 2.0);
        }
      }
    }
  }

  override function pre(x:Particle) {
    x.hoist();
    if x.π? {
      x.π!.grad(1.0);
    }
  }

  override function move(y:Particle) -> Real {
    let naccepts <- 0;
    if y.π? {
      let π <- y.π!;

      /* initial state */
      let p <- π.eval();
      let (x, g) <- π.args();

      /* scale */
      δ:Real[_];
      let m <- length(x);
      if length(σ2) == m {
        δ <- scale*σ2;
      } else {
        δ <- vector(scale, m);
      }

      /* mean of proposal from initial state */
      let μ <- x + hadamard(g, δ);

      /* moves */
      let accept <- true;  // was most recent particle accepted?
      for n in 1..nmoves {
        /* proposed state */
        cpp{{
        auto z = numbirch::standard_gaussian(m);
        }}
        let p' <- π.move(μ + hadamard(sqrt(2.0*δ), z));
        π.grad(1.0);
        let (x', g') <- π.args();
        let μ' <- x' + hadamard(g', δ);

        /* proposal correction */
        let q <- (pow(x - μ', 2.0) - pow(x' - μ, 2.0))/δ;
        let r <- -0.25*sum(where(isfinite(q), q, 0.0));

        /* accept/reject */
        accept <- log(simulate_uniform(0.0, 1.0)) <= p' - p + r;
        if accept {
          naccepts <- naccepts + 1;
          p <- p';
          x <- x';
          g <- g';
          μ <- μ';
        }
      }
      if !accept {
        /* last proposal was rejected, restore correct arguments */
        π.move(x);
      }
    }
    return cast<Real>(naccepts)/nmoves;
  }

  override function post(x:Particle) {
    x.π <- nil;
    x.constant(nlags);
  }
}
