/**
 * Langevin Markov kernel, with Metropolis adjustment.
 *
 * ```mermaid
 * classDiagram
 *    Kernel <|-- LangevinKernel
 *    link Kernel "../Kernel/"
 *    link LangevinKernel "../LangevinKernel/"
 * ```
 */
class LangevinKernel < Kernel {
  /**
   * Ensemble standard deviation vector across particles.
   */
  σ2:Real[_];

  override function adapt(t:Integer, x:Array<Particle>, w:Real[_]) {
    σ2 <- vector(0.0, 0);
    s:Real[_];  // sum of states
    s2:Real[_];  // sum of squared states
    let v <- norm_exp(w);  // normalized weights
    let N <- x.size();
    let first <- true;
    for n in 1..N {
      let π <- x[n].π;
      if π? {
        let (y, g) <- π!.args();

        /* skip when weight is zero, as this will have no effect on the
         * computation, unless that weight results from NaN values, which will
         * still propagate */
        if v[n] > 0.0 {
          let z <- v[n]*y;
          let z2 <- v[n]*mul(y, y);
          if first {
            s <- z;
            s2 <- z2;
            first <- false;
          } else if length(y) == length(s) {
            s <- s + z;
            s2 <- s2 + z2;
          } else {
            return;  // mismatched states, cannot adapt
          }
        }
      } else {
        return;  // mismatched states, cannot adapt
      }
    }
    if !first {
      σ2 <- s2 - mul(s, s);
    }
  }

  override function lag(t:Integer, π:Expression<Real>) {
    ///@todo Can label() and constant() be combined into one pass?
    π.label(t);
    π.constant(t - nlags);
  }

  override function precompute(t:Integer, π:Expression<Real>) {
    π.grad(1.0);
  }

  override function move(t:Integer, π:Expression<Real>) -> Real {
    /* initial state */
    let p <- π.eval();
    let (x, g) <- π.args();

    /* scale */
    δ:Real[_];
    let m <- length(x);
    if length(σ2) == m {
      δ <- scale*σ2;
    } else {
      δ <- vector(scale, m);
    }

    /* mean of proposal from initial state */
    let μ <- x + mul(g, δ);

    /* moves */
    let naccepts <- 0;
    let accept <- true;  // was most recent particle accepted?
    for n in 1..nmoves {
      /* proposed state */
      cpp{{
      auto z = numbirch::standard_gaussian(m);
      }}
      let p' <- π.move(μ + mul(sqrt(2.0*δ), z));
      π.grad(1.0);
      let (x', g') <- π.args();
      let μ' <- x' + mul(g', δ);

      /* proposal correction */
      let r <- transform_reduce(x' - μ, x - μ', δ, 0.0,
          \(a:Real, b:Real) -> {
            return a + b;
          },
          \(z':Real, z:Real, δ:Real) -> {
            let r <- -0.25*(z*z - z'*z')/δ;
            if isnan(r) {
              return 0.0;
            } else {
              return r;
            }
          });

      /* accept/reject */
      accept <- log(simulate_uniform(0.0, 1.0)) <= p' - p + r;
      if accept {
        naccepts <- naccepts + 1;
        p <- p';
        x <- x';
        g <- g';
        μ <- μ';
      }
    }
    if !accept {
      /* last proposal was rejected, restore correct arguments */
      π.move(x);
    }
    return cast<Real>(naccepts)/nmoves;
  }
}
