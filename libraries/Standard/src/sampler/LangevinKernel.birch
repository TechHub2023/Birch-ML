/**
 * Langevin Markov kernel, with Metropolis adjustment.
 *
 * ```mermaid
 * classDiagram
 *    Kernel <|-- LangevinKernel
 *    link Kernel "../Kernel/"
 *    link LangevinKernel "../LangevinKernel/"
 * ```
 */
class LangevinKernel < Kernel {
  /**
   * Ensemble standard deviation vector across particles.
   */
  σ2:Real[_];

  override function adapt(t:Integer, x:Array<Particle>, w:Real[_]) {
    σ2 <- vector(0.0, 0);
    s:Real[_];  // sum of states
    s2:Real[_];  // sum of squared states
    let v <- norm_exp(w);  // normalized weights
    let N <- x.size();
    let first <- true;
    for n in 1..N {
      x[n].hoist();
      let π <- x[n].π;
      if π? {
        let (y, g) <- π!.args();

        /* skip when weight is zero, as this will have no effect on the
         * computation, unless that weight results from NaN values, which will
         * still propagate */
        if v[n] > 0.0 {
          let z <- v[n]*y;
          let z2 <- v[n]*pow(y, 2.0);
          if first {
            s <- z;
            s2 <- z2;
            first <- false;
          } else if length(y) == length(s) {
            s <- s + z;
            s2 <- s2 + z2;
          } else {
            return;  // mismatched states, cannot adapt
          }
        }
        x[n].π <- nil;
      } else {
        return;  // mismatched states, cannot adapt
      }
    }
    if !first {
      σ2 <- s2 - pow(s, 2.0);
    }
  }

  override function pre(x:Particle) {
    x.hoist();
    if x.π? {
      x.π!.grad(1.0);
    }
  }

  override function move(y:Particle) -> Real {
    let naccepts <- 0;
    if y.π? {
      let π <- y.π!;

      /* initial state */
      let p <- π.eval();
      let (x, g) <- π.args();

      /* scale */
      δ:Real[_];
      let m <- length(x);
      if length(σ2) == m {
        δ <- scale*σ2;
      } else {
        δ <- vector(scale, m);
      }

      /* mean of proposal from initial state */
      let μ <- x + hadamard(g, δ);

      /* moves */
      let accept <- true;  // was most recent particle accepted?
      for n in 1..nmoves {
        /* proposed state */
        cpp{{
        auto z = numbirch::standard_gaussian(m);
        }}
        let p' <- π.move(μ + hadamard(sqrt(2.0*δ), z));
        π.grad(1.0);
        let (x', g') <- π.args();
        let μ' <- x' + hadamard(g', δ);

        /* proposal correction */
        let r <- transform_reduce(x' - μ, x - μ', δ, 0.0,
            \(a:Real, b:Real) -> {
              return a + b;
            },
            \(z':Real, z:Real, δ:Real) -> {
              let r <- -0.25*(z*z - z'*z')/δ;
              if isfinite(r) {
                return r;
              } else {
                return 0.0;
              }
            });

        /* accept/reject */
        accept <- log(simulate_uniform(0.0, 1.0)) <= p' - p + r;
        if accept {
          naccepts <- naccepts + 1;
          p <- p';
          x <- x';
          g <- g';
          μ <- μ';
        }
      }
      if !accept {
        /* last proposal was rejected, restore correct arguments */
        π.move(x);
      }
    }
    return cast<Real>(naccepts)/nmoves;
  }

  override function post(x:Particle) {
    x.π <- nil;
    x.constant(nlags);
  }
}
