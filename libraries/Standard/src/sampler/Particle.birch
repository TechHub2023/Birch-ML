/**
 * Particle for use with ParticleFilter.
 *
 * - m: Model.
 */
class Particle(m:Model) {
  /**
   * Model.
   */
  m:Model <- m;

  /**
   * Distribution and Random objects for move, by step.
   */
  Ξ:Array<Array<Delay>>;

  /**
   * Factors for move, by step.
   */
  Φ:Array<Array<Expression<Real>>>;

  /**
   * Factors for move, by step.
   */
  π:Expression<Real>?;

  function hoist() {
    π <- nil;
    for i in 1..Ξ.size() {
      for j in 1..Ξ[i].size() {
        if !Ξ[i][j].isSubordinate() {
          let ξ <- Ξ[i][j].hoist();
          if ξ? {
            if π? {
              π <- box(π! + ξ!);
            } else {
              π <- ξ!;
            }
          }
        }
      }
    }
    for i in 1..Φ.size() {
      for j in 1..Φ[i].size() {
        let φ <- Φ[i][j];
        if π? {
          π <- box(π! + φ);
        } else {
          π <- φ;
        }
      }
    }
  }

  function constant(nlags:Integer) {
    π <- nil;
    while Ξ.size() >= nlags {
      for j in 1..Ξ.front().size() {
        Ξ.front()[j].constant();
      }
      Ξ.popFront();
    }
    while Φ.size() >= nlags {
      for j in 1..Φ.front().size() {
        Φ.front()[j].constant();
      }
      Φ.popFront();
    }
  }

  override function read(buffer:Buffer) {
    m.read(buffer);
  }

  override function write(buffer:Buffer) {
    m.write(buffer);
  }

  override function read(t:Integer, buffer:Buffer) {
    m.read(t, buffer);
  }

  override function write(t:Integer, buffer:Buffer) {
    m.write(t, buffer);
  }
}
