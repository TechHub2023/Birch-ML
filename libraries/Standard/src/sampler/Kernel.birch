/**
 * Markov kernel.
 *
 * ```mermaid
 * classDiagram
 *    Kernel <|-- LangevinKernel
 *    link Kernel "../Kernel/"
 *    link LangevinKernel "../LangevinKernel/"
 * ```
 *
 * A Kernel is applied to a Particle. It applies an invariant update to the
 * Random objects encountered in the execution of that particle, as though
 * probabilistic events had been handled this way *post hoc*. Mathematically,
 * these Random objects constitute a sample from some target distribution. A
 * Kernel object represents a Markov kernel that is applied to the sample to
 * update it in a manner invariant to that target distribution.
 */
abstract class Kernel {
  /**
   * Number of lags.
   */
  nlags:Integer <- 0;

  /**
   * Number of moves.
   */
  nmoves:Integer <- 1;

  /**
   * Scale of each move.
   */
  scale:Real <- 1.0;

  /**
   * Adapt the kernel to the current ensemble of particles.
   */
  abstract function adapt(t:Integer, x:Array<Particle>, w:Real[_]);

  /**
   * Perform pre-computations prior to copying a particle. This is typically
   * called during resampling to perform computations that will be the same
   * for all offspring (e.g. gradient at current arguments).
   *
   * - x: Particle.
   */
  abstract function pre(x:Particle);

  /**
   * Move a particle.
   *
   * - x: Particle.
   *
   * Returns: Acceptance rate of moves.
   */
  abstract function move(x:Particle) -> Real;

  /**
   * Perform post-computations after moving a particle.
   *
   * - x: Particle.
   */
  abstract function post(x:Particle);

  override function read(buffer:Buffer) {
    super.read(buffer);
    nlags <-? buffer.get<Integer>("nlags");
    nmoves <-? buffer.get<Integer>("nmoves");
    scale <-? buffer.get<Real>("scale");
  }
  
  override function write(buffer:Buffer) {
    super.write(buffer);
    buffer.set("nlags", nlags);
    buffer.set("nmoves", nmoves);
    buffer.set("scale", scale);
  }
}
