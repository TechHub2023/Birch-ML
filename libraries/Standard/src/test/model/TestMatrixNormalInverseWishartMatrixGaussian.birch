class TestMatrixNormalInverseWishartMatrixGaussian < Model {
  V:Random<LLT>;
  X:Random<Real[_,_]>;
  Y:Random<Real[_,_]>;

  n:Real <- 5;
  p:Real <- 2;

  M:Real[n,p];
  U:Real[n,n];
  k:Real;
  Ψ:Real[p,p];

  function initialize() {
    k <- p + 1.0 + simulate_uniform(0.0, 10.0);
    for i in 1..n {
      for j in 1..n {
        U[i,j] <- simulate_uniform(-2.0, 2.0);
      }
      for j in 1..p {
        M[i,j] <- simulate_uniform(-10.0, 10.0);
      }
    }
    for i in 1..p {
      for j in 1..p {
        Ψ[i,j] <- simulate_uniform(-10.0, 10.0);
      }
    }
    U <- U*transpose(U) + diagonal(1.0e-2, n);
    Ψ <- Ψ*transpose(Ψ) + diagonal(1.0e-2, p);
  }

  function simulate() {
    V ~ InverseWishart(Ψ, k);
    X ~ Gaussian(M, U, V);
    Y ~ Gaussian(X, V);
  }

  function forward() -> Real[_] {
    V.value();
    X.value();
    Y.value();
    return vectorize();
  }

  function backward() -> Real[_] {
    assert !Y.hasValue();
    Y.value();
    assert !X.hasValue();
    X.value();
    assert !V.hasValue();
    V.value();
    return vectorize();
  }

  function forwardLazy() -> Real[_] {
    V.eval();
    X.eval();
    Y.eval();
    return vectorize();
  }

  function backwardLazy() -> Real[_] {
    assert !Y.hasValue();
    Y.eval();
    assert !X.hasValue();
    X.eval();
    assert !V.hasValue();
    V.eval();
    return vectorize();
  }

  function marginal() -> Distribution<Real[_,_]> {
    return Y.getDistribution();
  }

  function vectorize() -> Real[_] {
    y:Real[size()];
    let k <- 0;
    for i in 1..V.rows() {
      y[k + 1 .. k + V.columns()] <- canonical(V.value())[i,1..V.columns()];
      k <- k + V.columns();
    }
    for i in 1..X.rows() {
      y[k + 1 .. k + X.columns()] <- X.value()[i,1..X.columns()];
      k <- k + X.columns();
    }
    for i in 1..Y.rows() {
      y[k + 1 .. k + Y.columns()] <- Y.value()[i,1..Y.columns()];
      k <- k + Y.columns();
    }
    return y;
  }

  function size() -> Integer {
    return p*p + 2*n*p;
  }
}
