/**
 * @file
 *
 * Standard headers that should be included for all C++ files generated by
 * the compiler.
 */
#pragma once

#include "libbirch/external.hpp"
#include "libbirch/assert.hpp"
#include "libbirch/thread.hpp"
#include "libbirch/memory.hpp"
#include "libbirch/stacktrace.hpp"
#include "libbirch/macro.hpp"
#include "libbirch/type.hpp"

#include "libbirch/Array.hpp"
#include "libbirch/Inplace.hpp"
#include "libbirch/Shared.hpp"
#include "libbirch/Any.hpp"
#include "libbirch/Eigen.hpp"
#include "libbirch/Allocator.hpp"

namespace libbirch {
/**
 * Make an array.
 *
 * @ingroup libbirch
 *
 * @tparam T Value type.
 *
 * @param values Values.
 *
 * @return The array.
 */
template<class T>
auto make_array_from_sequence(const std::initializer_list<T>& values) {
  return Array<T,typename DefaultShape<1>::type>(values);
}

/**
 * Make an array.
 *
 * @ingroup libbirch
 *
 * @tparam T Value type.
 *
 * @param values Values.
 *
 * @return The array.
 */
template<class T>
auto make_array_from_sequence(
      const std::initializer_list<std::initializer_list<T>>& values) {
  return Array<T,typename DefaultShape<2>::type>(values);
}

/**
 * Make an array.
 *
 * @ingroup libbirch
 *
 * @tparam T Value type.
 * @tparam F Shape type.
 * @tparam L Lambda type.
 *
 * @param l Lambda called to construct each element.
 * @param shape Shape.
 *
 * @return The array.
 */
template<class T, class F, class L>
auto make_array_from_lambda(const F& shape, const L& l) {
  return Array<T,F>(l, shape);
}

/**
 * Make an array and assign a value to it.
 *
 * @ingroup libbirch
 *
 * @tparam T Value type.
 * @tparam F Shape type.
 * @tparam Value Initial value type.
 *
 * @param shape Shape.
 * @param value Initial value.
 *
 * @return The array.
 */
template<class T, class F, class Value>
auto make_array_from_value(const F& shape, const Value& value) {
  return Array<T,F>(shape, value);
}

/**
 * Make an array.
 *
 * @ingroup libbirch
 *
 * @tparam T Element type.
 * @tparam F Shape type.
 * @tparam Args Constructor argument types.
 *
 * @param shape Shape.
 * @param args Constructor arguments.
 *
 * @return The array.
 */
template<class T, class F, class... Args>
auto make_array(const F& shape, Args&&... args) {
  return Array<T,F>(shape, std::forward<Args>(args)...);
}

/**
 * Make a value or object.
 *
 * @tparam T Type.
 * @tparam Args Constructor parameter types.
 *
 * @param args Constructor arguments.
 *
 * @return A default-constructed value of the given type.
 */
template<class T, class... Args>
T make(Args&&... args) {
  return T(std::forward<Args>(args)...);
}

/**
 * Make a value or object.
 *
 * @tparam T Type.
 * @tparam Args Argument types.
 * 
 * @param args Arguments.
 *
 * @return If the type is constructible with the given arguments, then an
 * optional with a so-constructed value, otherwise an optional with no value.
 */
template<class T, class... Args, std::enable_if_t<
    !is_pointer<T>::value &&
    std::is_constructible<T,Args...>::value,int> = 0>
std::optional<T> make_optional(Args&&... args) {
  return T(std::forward<Args>(args)...);
}

/**
 * Make a value or object.
 *
 * @tparam T Type.
 * @tparam Args Argument types.
 * 
 * @param args Arguments.
 *
 * @return If the type is constructible with the given arguments, then an
 * optional with a so-constructed value, otherwise an optional with no value.
 */
template<class T, class... Args, std::enable_if_t<
    !is_pointer<T>::value &&
    !std::is_constructible<T,Args...>::value,int> = 0>
std::optional<T> make_optional(Args&&... args) {
  return std::nullopt;
}

/**
 * Make a value or object.
 *
 * @tparam T Type.
 * @tparam Args Argument types.
 * 
 * @param args Arguments.
 *
 * @return If the type is constructible with the given arguments, then an
 * optional with a so-constructed value, otherwise an optional with no value.
 */
template<class T, class... Args, std::enable_if_t<
    is_pointer<T>::value &&
    std::is_constructible<typename T::value_type,Args...>::value,int> = 0>
std::optional<T> make_optional(Args&&... args) {
  return T(std::forward<Args>(args)...);
}

/**
 * Make a value or object.
 *
 * @tparam T Type.
 * @tparam Args Argument types.
 * 
 * @param args Arguments.
 *
 * @return If the type is constructible with the given arguments, then an
 * optional with a so-constructed value, otherwise an optional with no value.
 */
template<class T, class... Args, std::enable_if_t<
    is_pointer<T>::value &&
    !std::is_constructible<typename T::value_type,Args...>::value,int> = 0>
std::optional<T> make_optional(Args&&... args) {
  return std::nullopt;
}

/**
 * Identity cast of anything.
 */
template<class To, class From,
    std::enable_if_t<std::is_same<To,From>::value,int> = 0>
std::optional<To> cast(const From& from) {
  return from;
}

/**
 * Non-identity cast of a pointer.
 */
template<class To, class From,
    std::enable_if_t<!std::is_same<To,From>::value &&
    is_pointer<To>::value && is_pointer<From>::value,int> = 0>
std::optional<To> cast(const From& from) {
  auto ptr = dynamic_cast<typename To::value_type*>(from.get());
  if (ptr) {
    return To(ptr);
  } else {
    return std::nullopt;
  }
}

/**
 * Non-identity cast of a non-pointer.
 */
template<class To, class From,
    std::enable_if_t<!std::is_same<To,From>::value &&
    (!is_pointer<To>::value || !is_pointer<From>::value),int> = 0>
std::optional<To> cast(const From& from) {
  return static_cast<To>(from);
}

/**
 * Cast of an optional of anything.
 */
template<class To, class From>
std::optional<To> cast(const std::optional<From>& from) {
  if (from.has_value()) {
    return cast<To>(from.value());
  } else {
    return std::nullopt;
  }
}

/**
 * Optional assign. Corresponds to the `<-?` operator in Birch.
 *
 * @param to Target.
 * @param from Source.
 *
 * If @p from has a value, then assign it to @p to, otherwise do nothing.
 */
template<class To, class From>
auto optional_assign(To& to, const std::optional<From>& from) {
  if (from.has_value()) {
    to = from.value();
  }
  return to;
}

/**
 * Optional assign to an object. Corresponds to the `<-?` operator in Birch.
 *
 * @param to Target.
 * @param from Source.
 *
 * If @p from has a value, then assign it to @p to, otherwise do nothing.
 */
template<class To, class From, std::enable_if_t<is_value<From>::value,int> = 0>
auto optional_assign(const To& to, const std::optional<From>& from) {
  if (from.has_value()) {
    to = from.value();
  }
  return to;
}

}
